"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oauth4webapi";
exports.ids = ["vendor-chunks/oauth4webapi"];
exports.modules = {

/***/ "(rsc)/./node_modules/oauth4webapi/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/oauth4webapi/build/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTHORIZATION_RESPONSE_ERROR: () => (/* binding */ AUTHORIZATION_RESPONSE_ERROR),\n/* harmony export */   AuthorizationResponseError: () => (/* binding */ AuthorizationResponseError),\n/* harmony export */   ClientSecretBasic: () => (/* binding */ ClientSecretBasic),\n/* harmony export */   ClientSecretJwt: () => (/* binding */ ClientSecretJwt),\n/* harmony export */   ClientSecretPost: () => (/* binding */ ClientSecretPost),\n/* harmony export */   DPoP: () => (/* binding */ DPoP),\n/* harmony export */   HTTP_REQUEST_FORBIDDEN: () => (/* binding */ HTTP_REQUEST_FORBIDDEN),\n/* harmony export */   INVALID_REQUEST: () => (/* binding */ INVALID_REQUEST),\n/* harmony export */   INVALID_RESPONSE: () => (/* binding */ INVALID_RESPONSE),\n/* harmony export */   INVALID_SERVER_METADATA: () => (/* binding */ INVALID_SERVER_METADATA),\n/* harmony export */   JSON_ATTRIBUTE_COMPARISON: () => (/* binding */ JSON_ATTRIBUTE_COMPARISON),\n/* harmony export */   JWT_CLAIM_COMPARISON: () => (/* binding */ JWT_CLAIM_COMPARISON),\n/* harmony export */   JWT_TIMESTAMP_CHECK: () => (/* binding */ JWT_TIMESTAMP_CHECK),\n/* harmony export */   JWT_USERINFO_EXPECTED: () => (/* binding */ JWT_USERINFO_EXPECTED),\n/* harmony export */   KEY_SELECTION: () => (/* binding */ KEY_SELECTION),\n/* harmony export */   MISSING_SERVER_METADATA: () => (/* binding */ MISSING_SERVER_METADATA),\n/* harmony export */   None: () => (/* binding */ None),\n/* harmony export */   OperationProcessingError: () => (/* binding */ OperationProcessingError),\n/* harmony export */   PARSE_ERROR: () => (/* binding */ PARSE_ERROR),\n/* harmony export */   PrivateKeyJwt: () => (/* binding */ PrivateKeyJwt),\n/* harmony export */   REQUEST_PROTOCOL_FORBIDDEN: () => (/* binding */ REQUEST_PROTOCOL_FORBIDDEN),\n/* harmony export */   RESPONSE_BODY_ERROR: () => (/* binding */ RESPONSE_BODY_ERROR),\n/* harmony export */   RESPONSE_IS_NOT_CONFORM: () => (/* binding */ RESPONSE_IS_NOT_CONFORM),\n/* harmony export */   RESPONSE_IS_NOT_JSON: () => (/* binding */ RESPONSE_IS_NOT_JSON),\n/* harmony export */   ResponseBodyError: () => (/* binding */ ResponseBodyError),\n/* harmony export */   TlsClientAuth: () => (/* binding */ TlsClientAuth),\n/* harmony export */   UNSUPPORTED_OPERATION: () => (/* binding */ UNSUPPORTED_OPERATION),\n/* harmony export */   UnsupportedOperationError: () => (/* binding */ UnsupportedOperationError),\n/* harmony export */   WWWAuthenticateChallengeError: () => (/* binding */ WWWAuthenticateChallengeError),\n/* harmony export */   WWW_AUTHENTICATE_CHALLENGE: () => (/* binding */ WWW_AUTHENTICATE_CHALLENGE),\n/* harmony export */   _expectedIssuer: () => (/* binding */ _expectedIssuer),\n/* harmony export */   _nodiscoverycheck: () => (/* binding */ _nodiscoverycheck),\n/* harmony export */   _nopkce: () => (/* binding */ _nopkce),\n/* harmony export */   allowInsecureRequests: () => (/* binding */ allowInsecureRequests),\n/* harmony export */   authorizationCodeGrantRequest: () => (/* binding */ authorizationCodeGrantRequest),\n/* harmony export */   backchannelAuthenticationGrantRequest: () => (/* binding */ backchannelAuthenticationGrantRequest),\n/* harmony export */   backchannelAuthenticationRequest: () => (/* binding */ backchannelAuthenticationRequest),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   checkProtocol: () => (/* binding */ checkProtocol),\n/* harmony export */   clientCredentialsGrantRequest: () => (/* binding */ clientCredentialsGrantRequest),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   customFetch: () => (/* binding */ customFetch),\n/* harmony export */   deviceAuthorizationRequest: () => (/* binding */ deviceAuthorizationRequest),\n/* harmony export */   deviceCodeGrantRequest: () => (/* binding */ deviceCodeGrantRequest),\n/* harmony export */   discoveryRequest: () => (/* binding */ discoveryRequest),\n/* harmony export */   dynamicClientRegistrationRequest: () => (/* binding */ dynamicClientRegistrationRequest),\n/* harmony export */   expectNoNonce: () => (/* binding */ expectNoNonce),\n/* harmony export */   expectNoState: () => (/* binding */ expectNoState),\n/* harmony export */   formPostResponse: () => (/* binding */ formPostResponse),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateRandomCodeVerifier: () => (/* binding */ generateRandomCodeVerifier),\n/* harmony export */   generateRandomNonce: () => (/* binding */ generateRandomNonce),\n/* harmony export */   generateRandomState: () => (/* binding */ generateRandomState),\n/* harmony export */   genericTokenEndpointRequest: () => (/* binding */ genericTokenEndpointRequest),\n/* harmony export */   getContentType: () => (/* binding */ getContentType),\n/* harmony export */   getValidatedIdTokenClaims: () => (/* binding */ getValidatedIdTokenClaims),\n/* harmony export */   introspectionRequest: () => (/* binding */ introspectionRequest),\n/* harmony export */   isDPoPNonceError: () => (/* binding */ isDPoPNonceError),\n/* harmony export */   issueRequestObject: () => (/* binding */ issueRequestObject),\n/* harmony export */   jweDecrypt: () => (/* binding */ jweDecrypt),\n/* harmony export */   jwksCache: () => (/* binding */ jwksCache),\n/* harmony export */   modifyAssertion: () => (/* binding */ modifyAssertion),\n/* harmony export */   nopkce: () => (/* binding */ nopkce),\n/* harmony export */   processAuthorizationCodeResponse: () => (/* binding */ processAuthorizationCodeResponse),\n/* harmony export */   processBackchannelAuthenticationGrantResponse: () => (/* binding */ processBackchannelAuthenticationGrantResponse),\n/* harmony export */   processBackchannelAuthenticationResponse: () => (/* binding */ processBackchannelAuthenticationResponse),\n/* harmony export */   processClientCredentialsResponse: () => (/* binding */ processClientCredentialsResponse),\n/* harmony export */   processDeviceAuthorizationResponse: () => (/* binding */ processDeviceAuthorizationResponse),\n/* harmony export */   processDeviceCodeResponse: () => (/* binding */ processDeviceCodeResponse),\n/* harmony export */   processDiscoveryResponse: () => (/* binding */ processDiscoveryResponse),\n/* harmony export */   processDynamicClientRegistrationResponse: () => (/* binding */ processDynamicClientRegistrationResponse),\n/* harmony export */   processGenericTokenEndpointResponse: () => (/* binding */ processGenericTokenEndpointResponse),\n/* harmony export */   processIntrospectionResponse: () => (/* binding */ processIntrospectionResponse),\n/* harmony export */   processPushedAuthorizationResponse: () => (/* binding */ processPushedAuthorizationResponse),\n/* harmony export */   processRefreshTokenResponse: () => (/* binding */ processRefreshTokenResponse),\n/* harmony export */   processResourceDiscoveryResponse: () => (/* binding */ processResourceDiscoveryResponse),\n/* harmony export */   processRevocationResponse: () => (/* binding */ processRevocationResponse),\n/* harmony export */   processUserInfoResponse: () => (/* binding */ processUserInfoResponse),\n/* harmony export */   protectedResourceRequest: () => (/* binding */ protectedResourceRequest),\n/* harmony export */   pushedAuthorizationRequest: () => (/* binding */ pushedAuthorizationRequest),\n/* harmony export */   refreshTokenGrantRequest: () => (/* binding */ refreshTokenGrantRequest),\n/* harmony export */   resolveEndpoint: () => (/* binding */ resolveEndpoint),\n/* harmony export */   resourceDiscoveryRequest: () => (/* binding */ resourceDiscoveryRequest),\n/* harmony export */   revocationRequest: () => (/* binding */ revocationRequest),\n/* harmony export */   skipAuthTimeCheck: () => (/* binding */ skipAuthTimeCheck),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   userInfoRequest: () => (/* binding */ userInfoRequest),\n/* harmony export */   validateApplicationLevelSignature: () => (/* binding */ validateApplicationLevelSignature),\n/* harmony export */   validateAuthResponse: () => (/* binding */ validateAuthResponse),\n/* harmony export */   validateCodeIdTokenResponse: () => (/* binding */ validateCodeIdTokenResponse),\n/* harmony export */   validateDetachedSignatureResponse: () => (/* binding */ validateDetachedSignatureResponse),\n/* harmony export */   validateJwtAccessToken: () => (/* binding */ validateJwtAccessToken),\n/* harmony export */   validateJwtAuthResponse: () => (/* binding */ validateJwtAuthResponse)\n/* harmony export */ });\nlet USER_AGENT;\nif (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n    const NAME = \"oauth4webapi\";\n    const VERSION = \"v3.8.3\";\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n    if (input == null) {\n        return false;\n    }\n    try {\n        return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];\n    } catch  {\n        return false;\n    }\n}\nconst ERR_INVALID_ARG_VALUE = \"ERR_INVALID_ARG_VALUE\";\nconst ERR_INVALID_ARG_TYPE = \"ERR_INVALID_ARG_TYPE\";\nfunction CodedTypeError(message, code, cause) {\n    const err = new TypeError(message, {\n        cause\n    });\n    Object.assign(err, {\n        code\n    });\n    return err;\n}\nconst allowInsecureRequests = Symbol();\nconst clockSkew = Symbol();\nconst clockTolerance = Symbol();\nconst customFetch = Symbol();\nconst modifyAssertion = Symbol();\nconst jweDecrypt = Symbol();\nconst jwksCache = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === \"string\") {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nlet encodeBase64Url;\nif (Uint8Array.prototype.toBase64) {\n    encodeBase64Url = (input)=>{\n        if (input instanceof ArrayBuffer) {\n            input = new Uint8Array(input);\n        }\n        return input.toBase64({\n            alphabet: \"base64url\",\n            omitPadding: true\n        });\n    };\n} else {\n    const CHUNK_SIZE = 0x8000;\n    encodeBase64Url = (input)=>{\n        if (input instanceof ArrayBuffer) {\n            input = new Uint8Array(input);\n        }\n        const arr = [];\n        for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){\n            arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n        }\n        return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    };\n}\nlet decodeBase64Url;\nif (Uint8Array.fromBase64) {\n    decodeBase64Url = (input)=>{\n        try {\n            return Uint8Array.fromBase64(input, {\n                alphabet: \"base64url\"\n            });\n        } catch (cause) {\n            throw CodedTypeError(\"The input to be decoded is not correctly encoded.\", ERR_INVALID_ARG_VALUE, cause);\n        }\n    };\n} else {\n    decodeBase64Url = (input)=>{\n        try {\n            const binary = atob(input.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n            const bytes = new Uint8Array(binary.length);\n            for(let i = 0; i < binary.length; i++){\n                bytes[i] = binary.charCodeAt(i);\n            }\n            return bytes;\n        } catch (cause) {\n            throw CodedTypeError(\"The input to be decoded is not correctly encoded.\", ERR_INVALID_ARG_VALUE, cause);\n        }\n    };\n}\nfunction b64u(input) {\n    if (typeof input === \"string\") {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass UnsupportedOperationError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = UNSUPPORTED_OPERATION;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass OperationProcessingError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        if (options?.code) {\n            this.code = options?.code;\n        }\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nfunction OPE(message, code, cause) {\n    return new OperationProcessingError(message, {\n        code,\n        cause\n    });\n}\nasync function calculateJwkThumbprint(jwk) {\n    let components;\n    switch(jwk.kty){\n        case \"EC\":\n            components = {\n                crv: jwk.crv,\n                kty: jwk.kty,\n                x: jwk.x,\n                y: jwk.y\n            };\n            break;\n        case \"OKP\":\n            components = {\n                crv: jwk.crv,\n                kty: jwk.kty,\n                x: jwk.x\n            };\n            break;\n        case \"AKP\":\n            components = {\n                alg: jwk.alg,\n                kty: jwk.kty,\n                pub: jwk.pub\n            };\n            break;\n        case \"RSA\":\n            components = {\n                e: jwk.e,\n                kty: jwk.kty,\n                n: jwk.n\n            };\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported JWK key type\", {\n                cause: jwk\n            });\n    }\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(JSON.stringify(components))));\n}\nfunction assertCryptoKey(key, it) {\n    if (!(key instanceof CryptoKey)) {\n        throw CodedTypeError(`${it} must be a CryptoKey`, ERR_INVALID_ARG_TYPE);\n    }\n}\nfunction assertPrivateKey(key, it) {\n    assertCryptoKey(key, it);\n    if (key.type !== \"private\") {\n        throw CodedTypeError(`${it} must be a private CryptoKey`, ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction assertPublicKey(key, it) {\n    assertCryptoKey(key, it);\n    if (key.type !== \"public\") {\n        throw CodedTypeError(`${it} must be a public CryptoKey`, ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, \"\");\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== \"object\" || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (looseInstanceOf(input, Headers)) {\n        input = Object.fromEntries(input.entries());\n    }\n    const headers = new Headers(input ?? {});\n    if (USER_AGENT && !headers.has(\"user-agent\")) {\n        headers.set(\"user-agent\", USER_AGENT);\n    }\n    if (headers.has(\"authorization\")) {\n        throw CodedTypeError('\"options.headers\" must not include the \"authorization\" header name', ERR_INVALID_ARG_VALUE);\n    }\n    return headers;\n}\nfunction signal(url, value) {\n    if (value !== undefined) {\n        if (typeof value === \"function\") {\n            value = value(url.href);\n        }\n        if (!(value instanceof AbortSignal)) {\n            throw CodedTypeError('\"options.signal\" must return or be an instance of AbortSignal', ERR_INVALID_ARG_TYPE);\n        }\n        return value;\n    }\n    return undefined;\n}\nfunction replaceDoubleSlash(pathname) {\n    if (pathname.includes(\"//\")) {\n        return pathname.replace(\"//\", \"/\");\n    }\n    return pathname;\n}\nfunction prependWellKnown(url, wellKnown, allowTerminatingSlash = false) {\n    if (url.pathname === \"/\") {\n        url.pathname = wellKnown;\n    } else {\n        url.pathname = replaceDoubleSlash(`${wellKnown}/${allowTerminatingSlash ? url.pathname : url.pathname.replace(/(\\/)$/, \"\")}`);\n    }\n    return url;\n}\nfunction appendWellKnown(url, wellKnown) {\n    url.pathname = replaceDoubleSlash(`${url.pathname}/${wellKnown}`);\n    return url;\n}\nasync function performDiscovery(input, urlName, transform, options) {\n    if (!(input instanceof URL)) {\n        throw CodedTypeError(`\"${urlName}\" must be an instance of URL`, ERR_INVALID_ARG_TYPE);\n    }\n    checkProtocol(input, options?.[allowInsecureRequests] !== true);\n    const url = transform(new URL(input.href));\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return (options?.[customFetch] || fetch)(url.href, {\n        body: undefined,\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n    return performDiscovery(issuerIdentifier, \"issuerIdentifier\", (url)=>{\n        switch(options?.algorithm){\n            case undefined:\n            case \"oidc\":\n                appendWellKnown(url, \".well-known/openid-configuration\");\n                break;\n            case \"oauth2\":\n                prependWellKnown(url, \".well-known/oauth-authorization-server\");\n                break;\n            default:\n                throw CodedTypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"', ERR_INVALID_ARG_VALUE);\n        }\n        return url;\n    }, options);\n}\nfunction assertNumber(input, allow0, it, code, cause) {\n    try {\n        if (typeof input !== \"number\" || !Number.isFinite(input)) {\n            throw CodedTypeError(`${it} must be a number`, ERR_INVALID_ARG_TYPE, cause);\n        }\n        if (input > 0) return;\n        if (allow0) {\n            if (input !== 0) {\n                throw CodedTypeError(`${it} must be a non-negative number`, ERR_INVALID_ARG_VALUE, cause);\n            }\n            return;\n        }\n        throw CodedTypeError(`${it} must be a positive number`, ERR_INVALID_ARG_VALUE, cause);\n    } catch (err) {\n        if (code) {\n            throw OPE(err.message, code, cause);\n        }\n        throw err;\n    }\n}\nfunction assertString(input, it, code, cause) {\n    try {\n        if (typeof input !== \"string\") {\n            throw CodedTypeError(`${it} must be a string`, ERR_INVALID_ARG_TYPE, cause);\n        }\n        if (input.length === 0) {\n            throw CodedTypeError(`${it} must not be empty`, ERR_INVALID_ARG_VALUE, cause);\n        }\n    } catch (err) {\n        if (code) {\n            throw OPE(err.message, code, cause);\n        }\n        throw err;\n    }\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    const expected = expectedIssuerIdentifier;\n    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {\n        throw CodedTypeError('\"expectedIssuerIdentifier\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform Authorization Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.issuer, '\"response\" body \"issuer\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    if (expected !== _nodiscoverycheck && new URL(json.issuer).href !== expected.href) {\n        throw OPE('\"response\" body \"issuer\" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, {\n            expected: expected.href,\n            body: json,\n            attribute: \"issuer\"\n        });\n    }\n    return json;\n}\nfunction assertApplicationJson(response) {\n    assertContentType(response, \"application/json\");\n}\nfunction notJson(response, ...types) {\n    let msg = '\"response\" content-type must be ';\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `${types.join(\", \")}, or ${last}`;\n    } else if (types.length === 2) {\n        msg += `${types[0]} or ${types[1]}`;\n    } else {\n        msg += types[0];\n    }\n    return OPE(msg, RESPONSE_IS_NOT_JSON, response);\n}\nfunction assertContentTypes(response, ...types) {\n    if (!types.includes(getContentType(response))) {\n        throw notJson(response, ...types);\n    }\n}\nfunction assertContentType(response, contentType) {\n    if (getContentType(response) !== contentType) {\n        throw notJson(response, contentType);\n    }\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n    return randomBytes();\n}\nfunction generateRandomState() {\n    return randomBytes();\n}\nfunction generateRandomNonce() {\n    return randomBytes();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n    assertString(codeVerifier, \"codeVerifier\");\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return {\n            key: input\n        };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined) {\n        assertString(input.kid, '\"kid\"');\n    }\n    return {\n        key: input.key,\n        kid: input.kid\n    };\n}\nfunction psAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"PS256\";\n        case \"SHA-384\":\n            return \"PS384\";\n        case \"SHA-512\":\n            return \"PS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\", {\n                cause: key\n            });\n    }\n}\nfunction rsAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"RS256\";\n        case \"SHA-384\":\n            return \"RS384\";\n        case \"SHA-512\":\n            return \"RS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\", {\n                cause: key\n            });\n    }\n}\nfunction esAlg(key) {\n    switch(key.algorithm.namedCurve){\n        case \"P-256\":\n            return \"ES256\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-521\":\n            return \"ES512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\", {\n                cause: key\n            });\n    }\n}\nfunction keyToJws(key) {\n    switch(key.algorithm.name){\n        case \"RSA-PSS\":\n            return psAlg(key);\n        case \"RSASSA-PKCS1-v1_5\":\n            return rsAlg(key);\n        case \"ECDSA\":\n            return esAlg(key);\n        case \"Ed25519\":\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n            return key.algorithm.name;\n        case \"EdDSA\":\n            return \"Ed25519\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\", {\n                cause: key\n            });\n    }\n}\nfunction getClockSkew(client) {\n    const skew = client?.[clockSkew];\n    return typeof skew === \"number\" && Number.isFinite(skew) ? skew : 0;\n}\nfunction getClockTolerance(client) {\n    const tolerance = client?.[clockTolerance];\n    return typeof tolerance === \"number\" && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1 ? tolerance : 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction assertAs(as) {\n    if (typeof as !== \"object\" || as === null) {\n        throw CodedTypeError('\"as\" must be an object', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(as.issuer, '\"as.issuer\"');\n}\nfunction assertClient(client) {\n    if (typeof client !== \"object\" || client === null) {\n        throw CodedTypeError('\"client\" must be an object', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(client.client_id, '\"client.client_id\"');\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/(?:[-_.!~*'()]|%20)/g, (substring)=>{\n        switch(substring){\n            case \"-\":\n            case \"_\":\n            case \".\":\n            case \"!\":\n            case \"~\":\n            case \"*\":\n            case \"'\":\n            case \"(\":\n            case \")\":\n                return `%${substring.charCodeAt(0).toString(16).toUpperCase()}`;\n            case \"%20\":\n                return \"+\";\n            default:\n                throw new Error();\n        }\n    });\n}\nfunction ClientSecretPost(clientSecret) {\n    assertString(clientSecret, '\"clientSecret\"');\n    return (_as, client, body, _headers)=>{\n        body.set(\"client_id\", client.client_id);\n        body.set(\"client_secret\", clientSecret);\n    };\n}\nfunction ClientSecretBasic(clientSecret) {\n    assertString(clientSecret, '\"clientSecret\"');\n    return (_as, client, _body, headers)=>{\n        const username = formUrlEncode(client.client_id);\n        const password = formUrlEncode(clientSecret);\n        const credentials = btoa(`${username}:${password}`);\n        headers.set(\"authorization\", `Basic ${credentials}`);\n    };\n}\nfunction clientAssertionPayload(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id\n    };\n}\nfunction PrivateKeyJwt(clientPrivateKey, options) {\n    const { key, kid } = getKeyAndKid(clientPrivateKey);\n    assertPrivateKey(key, '\"clientPrivateKey.key\"');\n    return async (as, client, body, _headers)=>{\n        const header = {\n            alg: keyToJws(key),\n            kid\n        };\n        const payload = clientAssertionPayload(as, client);\n        options?.[modifyAssertion]?.(header, payload);\n        body.set(\"client_id\", client.client_id);\n        body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n        body.set(\"client_assertion\", await signJwt(header, payload, key));\n    };\n}\nfunction ClientSecretJwt(clientSecret, options) {\n    assertString(clientSecret, '\"clientSecret\"');\n    const modify = options?.[modifyAssertion];\n    let key;\n    return async (as, client, body, _headers)=>{\n        key ||= await crypto.subtle.importKey(\"raw\", buf(clientSecret), {\n            hash: \"SHA-256\",\n            name: \"HMAC\"\n        }, false, [\n            \"sign\"\n        ]);\n        const header = {\n            alg: \"HS256\"\n        };\n        const payload = clientAssertionPayload(as, client);\n        modify?.(header, payload);\n        const data = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n        const hmac = await crypto.subtle.sign(key.algorithm, key, buf(data));\n        body.set(\"client_id\", client.client_id);\n        body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n        body.set(\"client_assertion\", `${data}.${b64u(new Uint8Array(hmac))}`);\n    };\n}\nfunction None() {\n    return (_as, client, body, _headers)=>{\n        body.set(\"client_id\", client.client_id);\n    };\n}\nfunction TlsClientAuth() {\n    return None();\n}\nasync function signJwt(header, payload, key) {\n    if (!key.usages.includes(\"sign\")) {\n        throw CodedTypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"', ERR_INVALID_ARG_VALUE);\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nasync function issueRequestObject(as, client, parameters, privateKey, options) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    assertPrivateKey(key, '\"privateKey.key\"');\n    parameters.set(\"client_id\", client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id\n    };\n    let resource;\n    if (parameters.has(\"resource\") && (resource = parameters.getAll(\"resource\")) && resource.length > 1) {\n        claims.resource = resource;\n    }\n    {\n        let value = parameters.get(\"max_age\");\n        if (value !== null) {\n            claims.max_age = parseInt(value, 10);\n            assertNumber(claims.max_age, true, '\"max_age\" parameter');\n        }\n    }\n    {\n        let value = parameters.get(\"claims\");\n        if (value !== null) {\n            try {\n                claims.claims = JSON.parse(value);\n            } catch (cause) {\n                throw OPE('failed to parse the \"claims\" parameter as JSON', PARSE_ERROR, cause);\n            }\n            if (!isJsonObject(claims.claims)) {\n                throw CodedTypeError('\"claims\" parameter must be a JSON with a top level object', ERR_INVALID_ARG_VALUE);\n            }\n        }\n    }\n    {\n        let value = parameters.get(\"authorization_details\");\n        if (value !== null) {\n            try {\n                claims.authorization_details = JSON.parse(value);\n            } catch (cause) {\n                throw OPE('failed to parse the \"authorization_details\" parameter as JSON', PARSE_ERROR, cause);\n            }\n            if (!Array.isArray(claims.authorization_details)) {\n                throw CodedTypeError('\"authorization_details\" parameter must be a JSON with a top level array', ERR_INVALID_ARG_VALUE);\n            }\n        }\n    }\n    const header = {\n        alg: keyToJws(key),\n        typ: \"oauth-authz-req+jwt\",\n        kid\n    };\n    options?.[modifyAssertion]?.(header, claims);\n    return signJwt(header, claims, key);\n}\nlet jwkCache;\nasync function getSetPublicJwkCache(key, alg) {\n    const { kty, e, n, x, y, crv, pub } = await crypto.subtle.exportKey(\"jwk\", key);\n    const jwk = {\n        kty,\n        e,\n        n,\n        x,\n        y,\n        crv,\n        pub\n    };\n    if (kty === \"AKP\") jwk.alg = alg;\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nasync function publicJwk(key, alg) {\n    jwkCache ||= new WeakMap();\n    return jwkCache.get(key) || getSetPublicJwkCache(key, alg);\n}\nconst URLParse = URL.parse ? (url, base)=>URL.parse(url, base) : (url, base)=>{\n    try {\n        return new URL(url, base);\n    } catch  {\n        return null;\n    }\n};\nfunction checkProtocol(url, enforceHttps) {\n    if (enforceHttps && url.protocol !== \"https:\") {\n        throw OPE(\"only requests to HTTPS are allowed\", HTTP_REQUEST_FORBIDDEN, url);\n    }\n    if (url.protocol !== \"https:\" && url.protocol !== \"http:\") {\n        throw OPE(\"only HTTP and HTTPS requests are allowed\", REQUEST_PROTOCOL_FORBIDDEN, url);\n    }\n}\nfunction validateEndpoint(value, endpoint, useMtlsAlias, enforceHttps) {\n    let url;\n    if (typeof value !== \"string\" || !(url = URLParse(value))) {\n        throw OPE(`authorization server metadata does not contain a valid ${useMtlsAlias ? `\"as.mtls_endpoint_aliases.${endpoint}\"` : `\"as.${endpoint}\"`}`, value === undefined ? MISSING_SERVER_METADATA : INVALID_SERVER_METADATA, {\n            attribute: useMtlsAlias ? `mtls_endpoint_aliases.${endpoint}` : endpoint\n        });\n    }\n    checkProtocol(url, enforceHttps);\n    return url;\n}\nfunction resolveEndpoint(as, endpoint, useMtlsAlias, enforceHttps) {\n    if (useMtlsAlias && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias, enforceHttps);\n    }\n    return validateEndpoint(as[endpoint], endpoint, useMtlsAlias, enforceHttps);\n}\nasync function pushedAuthorizationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"pushed_authorization_request_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, \"POST\");\n    }\n    const response = await authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nclass DPoPHandler {\n    #header;\n    #privateKey;\n    #publicKey;\n    #clockSkew;\n    #modifyAssertion;\n    #map;\n    #jkt;\n    constructor(client, keyPair, options){\n        assertPrivateKey(keyPair?.privateKey, '\"DPoP.privateKey\"');\n        assertPublicKey(keyPair?.publicKey, '\"DPoP.publicKey\"');\n        if (!keyPair.publicKey.extractable) {\n            throw CodedTypeError('\"DPoP.publicKey.extractable\" must be true', ERR_INVALID_ARG_VALUE);\n        }\n        this.#modifyAssertion = options?.[modifyAssertion];\n        this.#clockSkew = getClockSkew(client);\n        this.#privateKey = keyPair.privateKey;\n        this.#publicKey = keyPair.publicKey;\n        branded.add(this);\n    }\n    #get(key) {\n        this.#map ||= new Map();\n        let item = this.#map.get(key);\n        if (item) {\n            this.#map.delete(key);\n            this.#map.set(key, item);\n        }\n        return item;\n    }\n    #set(key, val) {\n        this.#map ||= new Map();\n        this.#map.delete(key);\n        if (this.#map.size === 100) {\n            this.#map.delete(this.#map.keys().next().value);\n        }\n        this.#map.set(key, val);\n    }\n    async calculateThumbprint() {\n        if (!this.#jkt) {\n            const jwk = await crypto.subtle.exportKey(\"jwk\", this.#publicKey);\n            this.#jkt ||= await calculateJwkThumbprint(jwk);\n        }\n        return this.#jkt;\n    }\n    async addProof(url, headers, htm, accessToken) {\n        const alg = keyToJws(this.#privateKey);\n        this.#header ||= {\n            alg,\n            typ: \"dpop+jwt\",\n            jwk: await publicJwk(this.#publicKey, alg)\n        };\n        const nonce = this.#get(url.origin);\n        const now = epochTime() + this.#clockSkew;\n        const payload = {\n            iat: now,\n            jti: randomBytes(),\n            htm,\n            nonce,\n            htu: `${url.origin}${url.pathname}`,\n            ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : undefined\n        };\n        this.#modifyAssertion?.(this.#header, payload);\n        headers.set(\"dpop\", await signJwt(this.#header, payload, this.#privateKey));\n    }\n    cacheNonce(response, url) {\n        try {\n            const nonce = response.headers.get(\"dpop-nonce\");\n            if (nonce) {\n                this.#set(url.origin, nonce);\n            }\n        } catch  {}\n    }\n}\nfunction isDPoPNonceError(err) {\n    if (err instanceof WWWAuthenticateChallengeError) {\n        const { 0: challenge, length } = err.cause;\n        return length === 1 && challenge.scheme === \"dpop\" && challenge.parameters.error === \"use_dpop_nonce\";\n    }\n    if (err instanceof ResponseBodyError) {\n        return err.error === \"use_dpop_nonce\";\n    }\n    return false;\n}\nfunction DPoP(client, keyPair, options) {\n    return new DPoPHandler(client, keyPair, options);\n}\nclass ResponseBodyError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = RESPONSE_BODY_ERROR;\n        this.cause = options.cause;\n        this.error = options.cause.error;\n        this.status = options.response.status;\n        this.error_description = options.cause.error_description;\n        Object.defineProperty(this, \"response\", {\n            enumerable: false,\n            value: options.response\n        });\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass AuthorizationResponseError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = AUTHORIZATION_RESPONSE_ERROR;\n        this.cause = options.cause;\n        this.error = options.cause.get(\"error\");\n        this.error_description = options.cause.get(\"error_description\") ?? undefined;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass WWWAuthenticateChallengeError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = WWW_AUTHENTICATE_CHALLENGE;\n        this.cause = options.cause;\n        this.status = options.response.status;\n        this.response = options.response;\n        Object.defineProperty(this, \"response\", {\n            enumerable: false\n        });\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst tokenMatch = \"[a-zA-Z0-9!#$%&\\\\'\\\\*\\\\+\\\\-\\\\.\\\\^_`\\\\|~]+\";\nconst token68Match = \"[a-zA-Z0-9\\\\-\\\\._\\\\~\\\\+\\\\/]+={0,2}\";\nconst quotedMatch = '\"((?:[^\"\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*)\"';\nconst quotedParamMatcher = \"(\" + tokenMatch + \")\\\\s*=\\\\s*\" + quotedMatch;\nconst paramMatcher = \"(\" + tokenMatch + \")\\\\s*=\\\\s*(\" + tokenMatch + \")\";\nconst schemeRE = new RegExp(\"^[,\\\\s]*(\" + tokenMatch + \")\");\nconst quotedParamRE = new RegExp(\"^[,\\\\s]*\" + quotedParamMatcher + \"[,\\\\s]*(.*)\");\nconst unquotedParamRE = new RegExp(\"^[,\\\\s]*\" + paramMatcher + \"[,\\\\s]*(.*)\");\nconst token68ParamRE = new RegExp(\"^(\" + token68Match + \")(?:$|[,\\\\s])(.*)\");\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    const header = response.headers.get(\"www-authenticate\");\n    if (header === null) {\n        return undefined;\n    }\n    const challenges = [];\n    let rest = header;\n    while(rest){\n        let match = rest.match(schemeRE);\n        const scheme = match?.[\"1\"].toLowerCase();\n        if (!scheme) {\n            return undefined;\n        }\n        const afterScheme = rest.substring(match[0].length);\n        if (afterScheme && !afterScheme.match(/^[\\s,]/)) {\n            return undefined;\n        }\n        const spaceMatch = afterScheme.match(/^\\s+(.*)$/);\n        const hasParameters = !!spaceMatch;\n        rest = spaceMatch ? spaceMatch[1] : undefined;\n        const parameters = {};\n        let token68;\n        if (hasParameters) {\n            while(rest){\n                let key;\n                let value;\n                if (match = rest.match(quotedParamRE)) {\n                    ;\n                    [, key, value, rest] = match;\n                    if (value.includes(\"\\\\\")) {\n                        try {\n                            value = JSON.parse(`\"${value}\"`);\n                        } catch  {}\n                    }\n                    parameters[key.toLowerCase()] = value;\n                    continue;\n                }\n                if (match = rest.match(unquotedParamRE)) {\n                    ;\n                    [, key, value, rest] = match;\n                    parameters[key.toLowerCase()] = value;\n                    continue;\n                }\n                if (match = rest.match(token68ParamRE)) {\n                    if (Object.keys(parameters).length) {\n                        break;\n                    }\n                    ;\n                    [, token68, rest] = match;\n                    break;\n                }\n                return undefined;\n            }\n        } else {\n            rest = afterScheme || undefined;\n        }\n        const challenge = {\n            scheme,\n            parameters\n        };\n        if (token68) {\n            challenge.token68 = token68;\n        }\n        challenges.push(challenge);\n    }\n    if (!challenges.length) {\n        return undefined;\n    }\n    return challenges;\n}\nasync function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 201, \"Pushed Authorization Request Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.request_uri, '\"response\" body \"request_uri\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    let expiresIn = typeof json.expires_in !== \"number\" ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    json.expires_in = expiresIn;\n    return json;\n}\nasync function parseOAuthResponseErrorBody(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        assertApplicationJson(response);\n        try {\n            const json = await response.clone().json();\n            if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n                return json;\n            }\n        } catch  {}\n    }\n    return undefined;\n}\nasync function checkOAuthBodyError(response, expected, label) {\n    if (response.status !== expected) {\n        checkAuthenticationChallenges(response);\n        let err;\n        if (err = await parseOAuthResponseErrorBody(response)) {\n            await response.body?.cancel();\n            throw new ResponseBodyError(\"server responded with an error in the response body\", {\n                cause: err,\n                response\n            });\n        }\n        throw OPE(`\"response\" is not a conform ${label} response (unexpected HTTP status code)`, RESPONSE_IS_NOT_CONFORM, response);\n    }\n}\nfunction assertDPoP(option) {\n    if (!branded.has(option)) {\n        throw CodedTypeError('\"options.DPoP\" is not a valid DPoPHandle', ERR_INVALID_ARG_VALUE);\n    }\n}\nasync function resourceRequest(accessToken, method, url, headers, body, options) {\n    assertString(accessToken, '\"accessToken\"');\n    if (!(url instanceof URL)) {\n        throw CodedTypeError('\"url\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    checkProtocol(url, options?.[allowInsecureRequests] !== true);\n    headers = prepareHeaders(headers);\n    if (options?.DPoP) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, method.toUpperCase(), accessToken);\n    }\n    headers.set(\"authorization\", `${headers.has(\"dpop\") ? \"DPoP\" : \"Bearer\"} ${accessToken}`);\n    const response = await (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    const response = await resourceRequest(accessToken, method, url, headers, body, options);\n    checkAuthenticationChallenges(response);\n    return response;\n}\nasync function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"userinfo_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set(\"accept\", \"application/jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n        headers.append(\"accept\", \"application/jwt\");\n    }\n    return resourceRequest(accessToken, \"GET\", url, headers, null, {\n        ...options,\n        [clockSkew]: getClockSkew(client)\n    });\n}\nlet jwksMap;\nfunction setJwksCache(as, jwks, uat, cache) {\n    jwksMap ||= new WeakMap();\n    jwksMap.set(as, {\n        jwks,\n        uat,\n        get age () {\n            return epochTime() - this.uat;\n        }\n    });\n    if (cache) {\n        Object.assign(cache, {\n            jwks: structuredClone(jwks),\n            uat\n        });\n    }\n}\nfunction isFreshJwksCache(input) {\n    if (typeof input !== \"object\" || input === null) {\n        return false;\n    }\n    if (!(\"uat\" in input) || typeof input.uat !== \"number\" || epochTime() - input.uat >= 300) {\n        return false;\n    }\n    if (!(\"jwks\" in input) || !isJsonObject(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isJsonObject)) {\n        return false;\n    }\n    return true;\n}\nfunction clearJwksCache(as, cache) {\n    jwksMap?.delete(as);\n    delete cache?.jwks;\n    delete cache?.uat;\n}\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(header);\n    if (!jwksMap?.has(as) && isFreshJwksCache(options?.[jwksCache])) {\n        setJwksCache(as, options?.[jwksCache].jwks, options?.[jwksCache].uat);\n    }\n    let jwks;\n    let age;\n    if (jwksMap?.has(as)) {\n        ;\n        ({ jwks, age } = jwksMap.get(as));\n        if (age >= 300) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    } else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        setJwksCache(as, jwks, epochTime(), options?.[jwksCache]);\n    }\n    let kty;\n    switch(alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            kty = \"RSA\";\n            break;\n        case \"ES\":\n            kty = \"EC\";\n            break;\n        case \"Ed\":\n            kty = \"OKP\";\n            break;\n        case \"ML\":\n            kty = \"AKP\";\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported JWS algorithm\", {\n                cause: {\n                    alg\n                }\n            });\n    }\n    const candidates = jwks.keys.filter((jwk)=>{\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== \"sig\") {\n            return false;\n        }\n        if (jwk.key_ops?.includes(\"verify\") === false) {\n            return false;\n        }\n        switch(true){\n            case alg === \"ES256\" && jwk.crv !== \"P-256\":\n            case alg === \"ES384\" && jwk.crv !== \"P-384\":\n            case alg === \"ES512\" && jwk.crv !== \"P-521\":\n            case alg === \"Ed25519\" && jwk.crv !== \"Ed25519\":\n            case alg === \"EdDSA\" && jwk.crv !== \"Ed25519\":\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw OPE(\"error when selecting a JWT verification key, no applicable keys found\", KEY_SELECTION, {\n            header,\n            candidates,\n            jwks_uri: new URL(as.jwks_uri)\n        });\n    }\n    if (length !== 1) {\n        throw OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required', KEY_SELECTION, {\n            header,\n            candidates,\n            jwks_uri: new URL(as.jwks_uri)\n        });\n    }\n    return importJwk(alg, jwk);\n}\nconst skipSubjectCheck = Symbol();\nfunction getContentType(input) {\n    return input.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as, client, expectedSubject, response, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    checkAuthenticationChallenges(response);\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform UserInfo Endpoint response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    let json;\n    if (getContentType(response) === \"application/jwt\") {\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported, undefined), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as));\n        jwtRefs.set(response, jwt);\n        json = claims;\n    } else {\n        if (client.userinfo_signed_response_alg) {\n            throw OPE(\"JWT UserInfo Response expected\", JWT_USERINFO_EXPECTED, response);\n        }\n        json = await getResponseJsonBody(response);\n    }\n    assertString(json.sub, '\"response\" body \"sub\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    switch(expectedSubject){\n        case skipSubjectCheck:\n            break;\n        default:\n            assertString(expectedSubject, '\"expectedSubject\"');\n            if (json.sub !== expectedSubject) {\n                throw OPE('unexpected \"response\" body \"sub\" property value', JSON_ATTRIBUTE_COMPARISON, {\n                    expected: expectedSubject,\n                    body: json,\n                    attribute: \"sub\"\n                });\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, clientAuthentication, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers);\n    headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n    return (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method: \"POST\",\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n}\nasync function tokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {\n    const url = resolveEndpoint(as, \"token_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    parameters.set(\"grant_type\", grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, \"POST\");\n    }\n    const response = await authenticatedRequest(as, client, clientAuthentication, url, parameters, headers, options);\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nasync function refreshTokenGrantRequest(as, client, clientAuthentication, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(refreshToken, '\"refreshToken\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"refresh_token\", refreshToken);\n    return tokenEndpointRequest(as, client, clientAuthentication, \"refresh_token\", parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nconst jwtRefs = new WeakMap();\nfunction getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw CodedTypeError('\"ref\" was already garbage collected or did not resolve from the proper sources', ERR_INVALID_ARG_VALUE);\n    }\n    return claims;\n}\nasync function validateApplicationLevelSignature(as, ref, options) {\n    assertAs(as);\n    if (!jwtRefs.has(ref)) {\n        throw CodedTypeError('\"ref\" does not contain a processed JWT Response to verify the signature of', ERR_INVALID_ARG_VALUE);\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwtRefs.get(ref).split(\".\");\n    const header = JSON.parse(buf(b64u(protectedHeader)));\n    if (header.alg.startsWith(\"HS\")) {\n        throw new UnsupportedOperationError(\"unsupported JWS algorithm\", {\n            cause: {\n                alg: header.alg\n            }\n        });\n    }\n    let key;\n    key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, b64u(encodedSignature));\n}\nasync function processGenericAccessTokenResponse(as, client, response, additionalRequiredIdTokenClaims, decryptFn, recognizedTokenTypes) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Token Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.access_token, '\"response\" body \"access_token\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    assertString(json.token_type, '\"response\" body \"token_type\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    json.token_type = json.token_type.toLowerCase();\n    if (json.expires_in !== undefined) {\n        let expiresIn = typeof json.expires_in !== \"number\" ? parseFloat(json.expires_in) : json.expires_in;\n        assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n            body: json\n        });\n        json.expires_in = expiresIn;\n    }\n    if (json.refresh_token !== undefined) {\n        assertString(json.refresh_token, '\"response\" body \"refresh_token\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (json.scope !== undefined && typeof json.scope !== \"string\") {\n        throw OPE('\"response\" body \"scope\" property must be a string', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (json.id_token !== undefined) {\n        assertString(json.id_token, '\"response\" body \"id_token\" property', INVALID_RESPONSE, {\n            body: json\n        });\n        const requiredClaims = [\n            \"aud\",\n            \"exp\",\n            \"iat\",\n            \"iss\",\n            \"sub\"\n        ];\n        if (client.require_auth_time === true) {\n            requiredClaims.push(\"auth_time\");\n        }\n        if (client.default_max_age !== undefined) {\n            assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n            requiredClaims.push(\"auth_time\");\n        }\n        if (additionalRequiredIdTokenClaims?.length) {\n            requiredClaims.push(...additionalRequiredIdTokenClaims);\n        }\n        const { claims, jwt } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, \"RS256\"), getClockSkew(client), getClockTolerance(client), decryptFn).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));\n        if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n            if (claims.azp === undefined) {\n                throw OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, {\n                    claims,\n                    claim: \"aud\"\n                });\n            }\n            if (claims.azp !== client.client_id) {\n                throw OPE('unexpected ID Token \"azp\" (authorized party) claim value', JWT_CLAIM_COMPARISON, {\n                    expected: client.client_id,\n                    claims,\n                    claim: \"azp\"\n                });\n            }\n        }\n        if (claims.auth_time !== undefined) {\n            assertNumber(claims.auth_time, true, 'ID Token \"auth_time\" (authentication time)', INVALID_RESPONSE, {\n                claims\n            });\n        }\n        jwtRefs.set(response, jwt);\n        idTokenClaims.set(json, claims);\n    }\n    if (recognizedTokenTypes?.[json.token_type] !== undefined) {\n        recognizedTokenTypes[json.token_type](response, json);\n    } else if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n        throw new UnsupportedOperationError(\"unsupported `token_type` value\", {\n            cause: {\n                body: json\n            }\n        });\n    }\n    return json;\n}\nfunction checkAuthenticationChallenges(response) {\n    let challenges;\n    if (challenges = parseWwwAuthenticateChallenges(response)) {\n        throw new WWWAuthenticateChallengeError(\"server responded with a challenge in the WWW-Authenticate HTTP Header\", {\n            cause: challenges,\n            response\n        });\n    }\n}\nasync function processRefreshTokenResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw OPE('unexpected JWT \"aud\" (audience) claim value', JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: result.claims,\n                claim: \"aud\"\n            });\n        }\n    } else if (result.claims.aud !== expected) {\n        throw OPE('unexpected JWT \"aud\" (audience) claim value', JWT_CLAIM_COMPARISON, {\n            expected,\n            claims: result.claims,\n            claim: \"aud\"\n        });\n    }\n    return result;\n}\nfunction validateOptionalIssuer(as, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(as, result);\n    }\n    return result;\n}\nfunction validateIssuer(as, result) {\n    const expected = as[_expectedIssuer]?.(result) ?? as.issuer;\n    if (result.claims.iss !== expected) {\n        throw OPE('unexpected JWT \"iss\" (issuer) claim value', JWT_CLAIM_COMPARISON, {\n            expected,\n            claims: result.claims,\n            claim: \"iss\"\n        });\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nconst nopkce = Symbol();\nasync function authorizationCodeGrantRequest(as, client, clientAuthentication, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw CodedTypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()', ERR_INVALID_ARG_VALUE);\n    }\n    assertString(redirectUri, '\"redirectUri\"');\n    const code = getURLSearchParameter(callbackParameters, \"code\");\n    if (!code) {\n        throw OPE('no authorization code in \"callbackParameters\"', INVALID_RESPONSE);\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"redirect_uri\", redirectUri);\n    parameters.set(\"code\", code);\n    if (codeVerifier !== nopkce) {\n        assertString(codeVerifier, '\"codeVerifier\"');\n        parameters.set(\"code_verifier\", codeVerifier);\n    }\n    return tokenEndpointRequest(as, client, clientAuthentication, \"authorization_code\", parameters, options);\n}\nconst jwtClaimNames = {\n    aud: \"audience\",\n    c_hash: \"code hash\",\n    client_id: \"client id\",\n    exp: \"expiration time\",\n    iat: \"issued at\",\n    iss: \"issuer\",\n    jti: \"jwt id\",\n    nonce: \"nonce\",\n    s_hash: \"state hash\",\n    sub: \"subject\",\n    ath: \"access token hash\",\n    htm: \"http method\",\n    htu: \"http uri\",\n    cnf: \"confirmation\",\n    auth_time: \"authentication time\"\n};\nfunction validatePresence(required, result) {\n    for (const claim of required){\n        if (result.claims[claim] === undefined) {\n            throw OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`, INVALID_RESPONSE, {\n                claims: result.claims\n            });\n        }\n    }\n    return result;\n}\nconst expectNoNonce = Symbol();\nconst skipAuthTimeCheck = Symbol();\nasync function processAuthorizationCodeResponse(as, client, response, options) {\n    if (typeof options?.expectedNonce === \"string\" || typeof options?.maxAge === \"number\" || options?.requireIdToken) {\n        return processAuthorizationCodeOpenIDResponse(as, client, response, options.expectedNonce, options.maxAge, options[jweDecrypt], options.recognizedTokenTypes);\n    }\n    return processAuthorizationCodeOAuth2Response(as, client, response, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge, decryptFn, recognizedTokenTypes) {\n    const additionalRequiredClaims = [];\n    switch(expectedNonce){\n        case undefined:\n            expectedNonce = expectNoNonce;\n            break;\n        case expectNoNonce:\n            break;\n        default:\n            assertString(expectedNonce, '\"expectedNonce\" argument');\n            additionalRequiredClaims.push(\"nonce\");\n    }\n    maxAge ??= client.default_max_age;\n    switch(maxAge){\n        case undefined:\n            maxAge = skipAuthTimeCheck;\n            break;\n        case skipAuthTimeCheck:\n            break;\n        default:\n            assertNumber(maxAge, true, '\"maxAge\" argument');\n            additionalRequiredClaims.push(\"auth_time\");\n    }\n    const result = await processGenericAccessTokenResponse(as, client, response, additionalRequiredClaims, decryptFn, recognizedTokenTypes);\n    assertString(result.id_token, '\"response\" body \"id_token\" property', INVALID_RESPONSE, {\n        body: result\n    });\n    const claims = getValidatedIdTokenClaims(result);\n    if (maxAge !== skipAuthTimeCheck) {\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw OPE(\"too much time has elapsed since the last End-User authentication\", JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance,\n                claim: \"auth_time\"\n            });\n        }\n    }\n    if (expectedNonce === expectNoNonce) {\n        if (claims.nonce !== undefined) {\n            throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n                expected: undefined,\n                claims,\n                claim: \"nonce\"\n            });\n        }\n    } else if (claims.nonce !== expectedNonce) {\n        throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n            expected: expectedNonce,\n            claims,\n            claim: \"nonce\"\n        });\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response, decryptFn, recognizedTokenTypes) {\n    const result = await processGenericAccessTokenResponse(as, client, response, undefined, decryptFn, recognizedTokenTypes);\n    const claims = getValidatedIdTokenClaims(result);\n    if (claims) {\n        if (client.default_max_age !== undefined) {\n            assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n            const now = epochTime() + getClockSkew(client);\n            const tolerance = getClockTolerance(client);\n            if (claims.auth_time + client.default_max_age < now - tolerance) {\n                throw OPE(\"too much time has elapsed since the last End-User authentication\", JWT_TIMESTAMP_CHECK, {\n                    claims,\n                    now,\n                    tolerance,\n                    claim: \"auth_time\"\n                });\n            }\n        }\n        if (claims.nonce !== undefined) {\n            throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n                expected: undefined,\n                claims,\n                claim: \"nonce\"\n            });\n        }\n    }\n    return result;\n}\nconst WWW_AUTHENTICATE_CHALLENGE = \"OAUTH_WWW_AUTHENTICATE_CHALLENGE\";\nconst RESPONSE_BODY_ERROR = \"OAUTH_RESPONSE_BODY_ERROR\";\nconst UNSUPPORTED_OPERATION = \"OAUTH_UNSUPPORTED_OPERATION\";\nconst AUTHORIZATION_RESPONSE_ERROR = \"OAUTH_AUTHORIZATION_RESPONSE_ERROR\";\nconst JWT_USERINFO_EXPECTED = \"OAUTH_JWT_USERINFO_EXPECTED\";\nconst PARSE_ERROR = \"OAUTH_PARSE_ERROR\";\nconst INVALID_RESPONSE = \"OAUTH_INVALID_RESPONSE\";\nconst INVALID_REQUEST = \"OAUTH_INVALID_REQUEST\";\nconst RESPONSE_IS_NOT_JSON = \"OAUTH_RESPONSE_IS_NOT_JSON\";\nconst RESPONSE_IS_NOT_CONFORM = \"OAUTH_RESPONSE_IS_NOT_CONFORM\";\nconst HTTP_REQUEST_FORBIDDEN = \"OAUTH_HTTP_REQUEST_FORBIDDEN\";\nconst REQUEST_PROTOCOL_FORBIDDEN = \"OAUTH_REQUEST_PROTOCOL_FORBIDDEN\";\nconst JWT_TIMESTAMP_CHECK = \"OAUTH_JWT_TIMESTAMP_CHECK_FAILED\";\nconst JWT_CLAIM_COMPARISON = \"OAUTH_JWT_CLAIM_COMPARISON_FAILED\";\nconst JSON_ATTRIBUTE_COMPARISON = \"OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED\";\nconst KEY_SELECTION = \"OAUTH_KEY_SELECTION_FAILED\";\nconst MISSING_SERVER_METADATA = \"OAUTH_MISSING_SERVER_METADATA\";\nconst INVALID_SERVER_METADATA = \"OAUTH_INVALID_SERVER_METADATA\";\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== \"string\" || normalizeTyp(result.header.typ) !== expected) {\n        throw OPE('unexpected JWT \"typ\" header parameter value', INVALID_RESPONSE, {\n            header: result.header\n        });\n    }\n    return result;\n}\nasync function clientCredentialsGrantRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, clientAuthentication, \"client_credentials\", new URLSearchParams(parameters), options);\n}\nasync function genericTokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(grantType, '\"grantType\"');\n    return tokenEndpointRequest(as, client, clientAuthentication, grantType, new URLSearchParams(parameters), options);\n}\nasync function processGenericTokenEndpointResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function processClientCredentialsResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function revocationRequest(as, client, clientAuthentication, token, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(token, '\"token\"');\n    const url = resolveEndpoint(as, \"revocation_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete(\"accept\");\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nasync function processRevocationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Revocation Endpoint\");\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw CodedTypeError('\"response\" body has been used already', ERR_INVALID_ARG_VALUE);\n    }\n}\nasync function introspectionRequest(as, client, clientAuthentication, token, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(token, '\"token\"');\n    const url = resolveEndpoint(as, \"introspection_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set(\"accept\", \"application/token-introspection+jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n    }\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nasync function processIntrospectionResponse(as, client, response, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Introspection Endpoint\");\n    let json;\n    if (getContentType(response) === \"application/token-introspection+jwt\") {\n        assertReadableResponse(response);\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported, \"RS256\"), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(checkJwtType.bind(undefined, \"token-introspection+jwt\")).then(validatePresence.bind(undefined, [\n            \"aud\",\n            \"iat\",\n            \"iss\"\n        ])).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));\n        jwtRefs.set(response, jwt);\n        if (!isJsonObject(claims.token_introspection)) {\n            throw OPE('JWT \"token_introspection\" claim must be a JSON object', INVALID_RESPONSE, {\n                claims\n            });\n        }\n        json = claims.token_introspection;\n    } else {\n        assertReadableResponse(response);\n        json = await getResponseJsonBody(response);\n    }\n    if (typeof json.active !== \"boolean\") {\n        throw OPE('\"response\" body \"active\" property must be a boolean', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, \"jwks_uri\", false, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwk-set+json\");\n    return (options?.[customFetch] || fetch)(url.href, {\n        body: undefined,\n        headers: Object.fromEntries(headers.entries()),\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n}\nasync function processJwksResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform JSON Web Key Set response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response, (response)=>assertContentTypes(response, \"application/json\", \"application/jwk-set+json\"));\n    if (!Array.isArray(json.keys)) {\n        throw OPE('\"response\" body \"keys\" property must be an array', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw OPE('\"response\" body \"keys\" property members must be JWK formatted objects', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nfunction supported(alg) {\n    switch(alg){\n        case \"PS256\":\n        case \"ES256\":\n        case \"RS256\":\n        case \"PS384\":\n        case \"ES384\":\n        case \"RS384\":\n        case \"PS512\":\n        case \"ES512\":\n        case \"RS512\":\n        case \"Ed25519\":\n        case \"EdDSA\":\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction checkSupportedJwsAlg(header) {\n    if (!supported(header.alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier', {\n            cause: {\n                alg: header.alg\n            }\n        });\n    }\n}\nfunction checkRsaKeyAlgorithm(key) {\n    const { algorithm } = key;\n    if (typeof algorithm.modulusLength !== \"number\" || algorithm.modulusLength < 2048) {\n        throw new UnsupportedOperationError(`unsupported ${algorithm.name} modulusLength`, {\n            cause: key\n        });\n    }\n}\nfunction ecdsaHashName(key) {\n    const { algorithm } = key;\n    switch(algorithm.namedCurve){\n        case \"P-256\":\n            return \"SHA-256\";\n        case \"P-384\":\n            return \"SHA-384\";\n        case \"P-521\":\n            return \"SHA-512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported ECDSA namedCurve\", {\n                cause: key\n            });\n    }\n}\nfunction keyToSubtle(key) {\n    switch(key.algorithm.name){\n        case \"ECDSA\":\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key)\n            };\n        case \"RSA-PSS\":\n            {\n                checkRsaKeyAlgorithm(key);\n                switch(key.algorithm.hash.name){\n                    case \"SHA-256\":\n                    case \"SHA-384\":\n                    case \"SHA-512\":\n                        return {\n                            name: key.algorithm.name,\n                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n                        };\n                    default:\n                        throw new UnsupportedOperationError(\"unsupported RSA-PSS hash name\", {\n                            cause: key\n                        });\n                }\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            checkRsaKeyAlgorithm(key);\n            return key.algorithm.name;\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n        case \"Ed25519\":\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\", {\n        cause: key\n    });\n}\nasync function validateJwsSignature(protectedHeader, payload, key, signature) {\n    const data = buf(`${protectedHeader}.${payload}`);\n    const algorithm = keyToSubtle(key);\n    const verified = await crypto.subtle.verify(algorithm, key, signature, data);\n    if (!verified) {\n        throw OPE(\"JWT signature verification failed\", INVALID_RESPONSE, {\n            key,\n            data,\n            signature,\n            algorithm\n        });\n    }\n}\nasync function validateJwt(jws, checkAlg, clockSkew, clockTolerance, decryptJwt) {\n    let { 0: protectedHeader, 1: payload, length } = jws.split(\".\");\n    if (length === 5) {\n        if (decryptJwt !== undefined) {\n            jws = await decryptJwt(jws);\n            ({ 0: protectedHeader, 1: payload, length } = jws.split(\".\"));\n        } else {\n            throw new UnsupportedOperationError(\"JWE decryption is not configured\", {\n                cause: jws\n            });\n        }\n    }\n    if (length !== 3) {\n        throw OPE(\"Invalid JWT\", INVALID_RESPONSE, jws);\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    } catch (cause) {\n        throw OPE(\"failed to parse JWT Header body as base64url encoded JSON\", PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(header)) {\n        throw OPE(\"JWT Header must be a top level object\", INVALID_RESPONSE, jws);\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new UnsupportedOperationError('no JWT \"crit\" header parameter extensions are supported', {\n            cause: {\n                header\n            }\n        });\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    } catch (cause) {\n        throw OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(claims)) {\n        throw OPE(\"JWT Payload must be a top level object\", INVALID_RESPONSE, jws);\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== \"number\") {\n            throw OPE('unexpected JWT \"exp\" (expiration time) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw OPE('unexpected JWT \"exp\" (expiration time) claim value, expiration is past current timestamp', JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance: clockTolerance,\n                claim: \"exp\"\n            });\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== \"number\") {\n            throw OPE('unexpected JWT \"iat\" (issued at) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== \"string\") {\n            throw OPE('unexpected JWT \"iss\" (issuer) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== \"number\") {\n            throw OPE('unexpected JWT \"nbf\" (not before) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw OPE('unexpected JWT \"nbf\" (not before) claim value', JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance: clockTolerance,\n                claim: \"nbf\"\n            });\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n            throw OPE('unexpected JWT \"aud\" (audience) claim type', INVALID_RESPONSE, {\n                claims\n            });\n        }\n    }\n    return {\n        header,\n        claims,\n        jwt: jws\n    };\n}\nasync function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE);\n    }\n    const response = getURLSearchParameter(parameters, \"response\");\n    if (!response) {\n        throw OPE('\"parameters\" does not contain a JARM response', INVALID_RESPONSE);\n    }\n    const { claims, header, jwt } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported, \"RS256\"), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validatePresence.bind(undefined, [\n        \"aud\",\n        \"exp\",\n        \"iss\"\n    ])).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwt.split(\".\");\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)){\n        if (typeof value === \"string\" && key !== \"aud\") {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(data, header, claimName) {\n    let algorithm;\n    switch(header.alg){\n        case \"RS256\":\n        case \"PS256\":\n        case \"ES256\":\n            algorithm = \"SHA-256\";\n            break;\n        case \"RS384\":\n        case \"PS384\":\n        case \"ES384\":\n            algorithm = \"SHA-384\";\n            break;\n        case \"RS512\":\n        case \"PS512\":\n        case \"ES512\":\n        case \"Ed25519\":\n        case \"EdDSA\":\n            algorithm = \"SHA-512\";\n            break;\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n            algorithm = {\n                name: \"cSHAKE256\",\n                length: 512\n            };\n            break;\n        default:\n            throw new UnsupportedOperationError(`unsupported JWS algorithm for ${claimName} calculation`, {\n                cause: {\n                    alg: header.alg\n                }\n            });\n    }\n    const digest = await crypto.subtle.digest(algorithm, buf(data));\n    return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, header, claimName) {\n    const expected = await idTokenHash(data, header, claimName);\n    return actual === expected;\n}\nasync function validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    return validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, true);\n}\nasync function validateCodeIdTokenResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    return validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, false);\n}\nasync function consumeStream(request) {\n    if (request.bodyUsed) {\n        throw CodedTypeError(\"form_post Request instances must contain a readable body\", ERR_INVALID_ARG_VALUE, {\n            cause: request\n        });\n    }\n    return request.text();\n}\nasync function formPostResponse(request) {\n    if (request.method !== \"POST\") {\n        throw CodedTypeError(\"form_post responses are expected to use the POST method\", ERR_INVALID_ARG_VALUE, {\n            cause: request\n        });\n    }\n    if (getContentType(request) !== \"application/x-www-form-urlencoded\") {\n        throw CodedTypeError(\"form_post responses are expected to use the application/x-www-form-urlencoded content-type\", ERR_INVALID_ARG_VALUE, {\n            cause: request\n        });\n    }\n    return consumeStream(request);\n}\nasync function validateHybridResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options, fapi) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        if (!parameters.hash.length) {\n            throw CodedTypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters', ERR_INVALID_ARG_VALUE);\n        }\n        parameters = new URLSearchParams(parameters.hash.slice(1));\n    } else if (looseInstanceOf(parameters, Request)) {\n        parameters = new URLSearchParams(await formPostResponse(parameters));\n    } else if (parameters instanceof URLSearchParams) {\n        parameters = new URLSearchParams(parameters);\n    } else {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, URL, or Response', ERR_INVALID_ARG_TYPE);\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    parameters.delete(\"id_token\");\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            break;\n        default:\n            assertString(expectedState, '\"expectedState\" argument');\n    }\n    const result = validateAuthResponse({\n        ...as,\n        authorization_response_iss_parameter_supported: false\n    }, client, parameters, expectedState);\n    if (!id_token) {\n        throw OPE('\"parameters\" does not contain an ID Token', INVALID_RESPONSE);\n    }\n    const code = getURLSearchParameter(parameters, \"code\");\n    if (!code) {\n        throw OPE('\"parameters\" does not contain an Authorization Code', INVALID_RESPONSE);\n    }\n    const requiredClaims = [\n        \"aud\",\n        \"exp\",\n        \"iat\",\n        \"iss\",\n        \"sub\",\n        \"nonce\",\n        \"c_hash\"\n    ];\n    const state = parameters.get(\"state\");\n    if (fapi && (typeof expectedState === \"string\" || state !== null)) {\n        requiredClaims.push(\"s_hash\");\n    }\n    if (maxAge !== undefined) {\n        assertNumber(maxAge, true, '\"maxAge\" argument');\n    } else if (client.default_max_age !== undefined) {\n        assertNumber(client.default_max_age, true, '\"client.default_max_age\"');\n    }\n    maxAge ??= client.default_max_age ?? skipAuthTimeCheck;\n    if (client.require_auth_time || maxAge !== skipAuthTimeCheck) {\n        requiredClaims.push(\"auth_time\");\n    }\n    const { claims, header, jwt } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, \"RS256\"), getClockSkew(client), getClockTolerance(client), options?.[jweDecrypt]).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));\n    const clockSkew = getClockSkew(client);\n    const now = epochTime() + clockSkew;\n    if (claims.iat < now - 3600) {\n        throw OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past', JWT_TIMESTAMP_CHECK, {\n            now,\n            claims,\n            claim: \"iat\"\n        });\n    }\n    assertString(claims.c_hash, 'ID Token \"c_hash\" (code hash) claim value', INVALID_RESPONSE, {\n        claims\n    });\n    if (claims.auth_time !== undefined) {\n        assertNumber(claims.auth_time, true, 'ID Token \"auth_time\" (authentication time)', INVALID_RESPONSE, {\n            claims\n        });\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw OPE(\"too much time has elapsed since the last End-User authentication\", JWT_TIMESTAMP_CHECK, {\n                claims,\n                now,\n                tolerance,\n                claim: \"auth_time\"\n            });\n        }\n    }\n    assertString(expectedNonce, '\"expectedNonce\" argument');\n    if (claims.nonce !== expectedNonce) {\n        throw OPE('unexpected ID Token \"nonce\" claim value', JWT_CLAIM_COMPARISON, {\n            expected: expectedNonce,\n            claims,\n            claim: \"nonce\"\n        });\n    }\n    if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n        if (claims.azp === undefined) {\n            throw OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, {\n                claims,\n                claim: \"aud\"\n            });\n        }\n        if (claims.azp !== client.client_id) {\n            throw OPE('unexpected ID Token \"azp\" (authorized party) claim value', JWT_CLAIM_COMPARISON, {\n                expected: client.client_id,\n                claims,\n                claim: \"azp\"\n            });\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = jwt.split(\".\");\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    if (await idTokenHashMatches(code, claims.c_hash, header, \"c_hash\") !== true) {\n        throw OPE('invalid ID Token \"c_hash\" (code hash) claim value', JWT_CLAIM_COMPARISON, {\n            code,\n            alg: header.alg,\n            claim: \"c_hash\",\n            claims\n        });\n    }\n    if (fapi && state !== null || claims.s_hash !== undefined) {\n        assertString(claims.s_hash, 'ID Token \"s_hash\" (state hash) claim value', INVALID_RESPONSE, {\n            claims\n        });\n        assertString(state, '\"state\" response parameter', INVALID_RESPONSE, {\n            parameters\n        });\n        if (await idTokenHashMatches(state, claims.s_hash, header, \"s_hash\") !== true) {\n            throw OPE('invalid ID Token \"s_hash\" (state hash) claim value', JWT_CLAIM_COMPARISON, {\n                state,\n                alg: header.alg,\n                claim: \"s_hash\",\n                claims\n            });\n        }\n    }\n    return result;\n}\nfunction checkSigningAlgorithm(client, issuer, fallback, header) {\n    if (client !== undefined) {\n        if (typeof client === \"string\" ? header.alg !== client : !client.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: client,\n                reason: \"client configuration\"\n            });\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: issuer,\n                reason: \"authorization server metadata\"\n            });\n        }\n        return;\n    }\n    if (fallback !== undefined) {\n        if (typeof fallback === \"string\" ? header.alg !== fallback : typeof fallback === \"function\" ? !fallback(header.alg) : !fallback.includes(header.alg)) {\n            throw OPE('unexpected JWT \"alg\" header parameter', INVALID_RESPONSE, {\n                header,\n                expected: fallback,\n                reason: \"default value\"\n            });\n        }\n        return;\n    }\n    throw OPE('missing client or server configuration to verify used JWT \"alg\" header parameter', undefined, {\n        client,\n        issuer,\n        fallback\n    });\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw OPE(`\"${name}\" parameter must be provided only once`, INVALID_RESPONSE);\n    }\n    return value;\n}\nconst skipStateCheck = Symbol();\nconst expectNoState = Symbol();\nfunction validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw CodedTypeError('\"parameters\" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (getURLSearchParameter(parameters, \"response\")) {\n        throw OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()', INVALID_RESPONSE, {\n            parameters\n        });\n    }\n    const iss = getURLSearchParameter(parameters, \"iss\");\n    const state = getURLSearchParameter(parameters, \"state\");\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw OPE('response parameter \"iss\" (issuer) missing', INVALID_RESPONSE, {\n            parameters\n        });\n    }\n    if (iss && iss !== as.issuer) {\n        throw OPE('unexpected \"iss\" (issuer) response parameter value', INVALID_RESPONSE, {\n            expected: as.issuer,\n            parameters\n        });\n    }\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw OPE('unexpected \"state\" response parameter encountered', INVALID_RESPONSE, {\n                    expected: undefined,\n                    parameters\n                });\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            assertString(expectedState, '\"expectedState\" argument');\n            if (state !== expectedState) {\n                throw OPE(state === undefined ? 'response parameter \"state\" missing' : 'unexpected \"state\" response parameter value', INVALID_RESPONSE, {\n                    expected: expectedState,\n                    parameters\n                });\n            }\n    }\n    const error = getURLSearchParameter(parameters, \"error\");\n    if (error) {\n        throw new AuthorizationResponseError(\"authorization response from the server is an error\", {\n            cause: parameters\n        });\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    const token = getURLSearchParameter(parameters, \"token\");\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg) {\n    switch(alg){\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n            return {\n                name: \"RSA-PSS\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"ES256\":\n        case \"ES384\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: `P-${alg.slice(-3)}`\n            };\n        case \"ES512\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-521\"\n            };\n        case \"EdDSA\":\n            return \"Ed25519\";\n        case \"Ed25519\":\n        case \"ML-DSA-44\":\n        case \"ML-DSA-65\":\n        case \"ML-DSA-87\":\n            return alg;\n        default:\n            throw new UnsupportedOperationError(\"unsupported JWS algorithm\", {\n                cause: {\n                    alg\n                }\n            });\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey(\"jwk\", key, algToSubtle(alg), true, [\n        \"verify\"\n    ]);\n}\nasync function deviceAuthorizationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"device_authorization_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nasync function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Device Authorization Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.device_code, '\"response\" body \"device_code\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    assertString(json.user_code, '\"response\" body \"user_code\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    assertString(json.verification_uri, '\"response\" body \"verification_uri\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    let expiresIn = typeof json.expires_in !== \"number\" ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    json.expires_in = expiresIn;\n    if (json.verification_uri_complete !== undefined) {\n        assertString(json.verification_uri_complete, '\"response\" body \"verification_uri_complete\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (json.interval !== undefined) {\n        assertNumber(json.interval, false, '\"response\" body \"interval\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nasync function deviceCodeGrantRequest(as, client, clientAuthentication, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(deviceCode, '\"deviceCode\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"device_code\", deviceCode);\n    return tokenEndpointRequest(as, client, clientAuthentication, \"urn:ietf:params:oauth:grant-type:device_code\", parameters, options);\n}\nasync function processDeviceCodeResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function generateKeyPair(alg, options) {\n    assertString(alg, '\"alg\"');\n    const algorithm = algToSubtle(alg);\n    if (alg.startsWith(\"PS\") || alg.startsWith(\"RS\")) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ])\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\nfunction normalizeHtu(htu) {\n    const url = new URL(htu);\n    url.search = \"\";\n    url.hash = \"\";\n    return url.href;\n}\nasync function validateDPoP(request, accessToken, accessTokenClaims, options) {\n    const headerValue = request.headers.get(\"dpop\");\n    if (headerValue === null) {\n        throw OPE(\"operation indicated DPoP use but the request has no DPoP HTTP Header\", INVALID_REQUEST, {\n            headers: request.headers\n        });\n    }\n    if (request.headers.get(\"authorization\")?.toLowerCase().startsWith(\"dpop \") === false) {\n        throw OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`, INVALID_REQUEST, {\n            headers: request.headers\n        });\n    }\n    if (typeof accessTokenClaims.cnf?.jkt !== \"string\") {\n        throw OPE(\"operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim\", INVALID_REQUEST, {\n            claims: accessTokenClaims\n        });\n    }\n    const clockSkew = getClockSkew(options);\n    const proof = await validateJwt(headerValue, checkSigningAlgorithm.bind(undefined, options?.signingAlgorithms, undefined, supported), clockSkew, getClockTolerance(options), undefined).then(checkJwtType.bind(undefined, \"dpop+jwt\")).then(validatePresence.bind(undefined, [\n        \"iat\",\n        \"jti\",\n        \"ath\",\n        \"htm\",\n        \"htu\"\n    ]));\n    const now = epochTime() + clockSkew;\n    const diff = Math.abs(now - proof.claims.iat);\n    if (diff > 300) {\n        throw OPE(\"DPoP Proof iat is not recent enough\", JWT_TIMESTAMP_CHECK, {\n            now,\n            claims: proof.claims,\n            claim: \"iat\"\n        });\n    }\n    if (proof.claims.htm !== request.method) {\n        throw OPE(\"DPoP Proof htm mismatch\", JWT_CLAIM_COMPARISON, {\n            expected: request.method,\n            claims: proof.claims,\n            claim: \"htm\"\n        });\n    }\n    if (typeof proof.claims.htu !== \"string\" || normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n        throw OPE(\"DPoP Proof htu mismatch\", JWT_CLAIM_COMPARISON, {\n            expected: normalizeHtu(request.url),\n            claims: proof.claims,\n            claim: \"htu\"\n        });\n    }\n    {\n        const expected = b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken)));\n        if (proof.claims.ath !== expected) {\n            throw OPE(\"DPoP Proof ath mismatch\", JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: proof.claims,\n                claim: \"ath\"\n            });\n        }\n    }\n    {\n        const expected = await calculateJwkThumbprint(proof.header.jwk);\n        if (accessTokenClaims.cnf.jkt !== expected) {\n            throw OPE(\"JWT Access Token confirmation mismatch\", JWT_CLAIM_COMPARISON, {\n                expected,\n                claims: accessTokenClaims,\n                claim: \"cnf.jkt\"\n            });\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = headerValue.split(\".\");\n    const signature = b64u(encodedSignature);\n    const { jwk, alg } = proof.header;\n    if (!jwk) {\n        throw OPE(\"DPoP Proof is missing the jwk header parameter\", INVALID_REQUEST, {\n            header: proof.header\n        });\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== \"public\") {\n        throw OPE(\"DPoP Proof jwk header parameter must contain a public key\", INVALID_REQUEST, {\n            header: proof.header\n        });\n    }\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n}\nasync function validateJwtAccessToken(as, request, expectedAudience, options) {\n    assertAs(as);\n    if (!looseInstanceOf(request, Request)) {\n        throw CodedTypeError('\"request\" must be an instance of Request', ERR_INVALID_ARG_TYPE);\n    }\n    assertString(expectedAudience, '\"expectedAudience\"');\n    const authorization = request.headers.get(\"authorization\");\n    if (authorization === null) {\n        throw OPE('\"request\" is missing an Authorization HTTP Header', INVALID_REQUEST, {\n            headers: request.headers\n        });\n    }\n    let { 0: scheme, 1: accessToken, length } = authorization.split(\" \");\n    scheme = scheme.toLowerCase();\n    switch(scheme){\n        case \"dpop\":\n        case \"bearer\":\n            break;\n        default:\n            throw new UnsupportedOperationError(\"unsupported Authorization HTTP Header scheme\", {\n                cause: {\n                    headers: request.headers\n                }\n            });\n    }\n    if (length !== 2) {\n        throw OPE(\"invalid Authorization HTTP Header format\", INVALID_REQUEST, {\n            headers: request.headers\n        });\n    }\n    const requiredClaims = [\n        \"iss\",\n        \"exp\",\n        \"aud\",\n        \"sub\",\n        \"iat\",\n        \"jti\",\n        \"client_id\"\n    ];\n    if (options?.requireDPoP || scheme === \"dpop\" || request.headers.has(\"dpop\")) {\n        requiredClaims.push(\"cnf\");\n    }\n    const { claims, header } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, options?.signingAlgorithms, undefined, supported), getClockSkew(options), getClockTolerance(options), undefined).then(checkJwtType.bind(undefined, \"at+jwt\")).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, expectedAudience)).catch(reassignRSCode);\n    for (const claim of [\n        \"client_id\",\n        \"jti\",\n        \"sub\"\n    ]){\n        if (typeof claims[claim] !== \"string\") {\n            throw OPE(`unexpected JWT \"${claim}\" claim type`, INVALID_REQUEST, {\n                claims\n            });\n        }\n    }\n    if (\"cnf\" in claims) {\n        if (!isJsonObject(claims.cnf)) {\n            throw OPE('unexpected JWT \"cnf\" (confirmation) claim value', INVALID_REQUEST, {\n                claims\n            });\n        }\n        const { 0: cnf, length } = Object.keys(claims.cnf);\n        if (length) {\n            if (length !== 1) {\n                throw new UnsupportedOperationError(\"multiple confirmation claims are not supported\", {\n                    cause: {\n                        claims\n                    }\n                });\n            }\n            if (cnf !== \"jkt\") {\n                throw new UnsupportedOperationError(\"unsupported JWT Confirmation method\", {\n                    cause: {\n                        claims\n                    }\n                });\n            }\n        }\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature } = accessToken.split(\".\");\n    const signature = b64u(encodedSignature);\n    const key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n    if (options?.requireDPoP || scheme === \"dpop\" || claims.cnf?.jkt !== undefined || request.headers.has(\"dpop\")) {\n        await validateDPoP(request, accessToken, claims, options).catch(reassignRSCode);\n    }\n    return claims;\n}\nfunction reassignRSCode(err) {\n    if (err instanceof OperationProcessingError && err?.code === INVALID_REQUEST) {\n        err.code = INVALID_RESPONSE;\n    }\n    throw err;\n}\nasync function backchannelAuthenticationRequest(as, client, clientAuthentication, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, \"backchannel_authentication_endpoint\", client.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);\n}\nasync function processBackchannelAuthenticationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 200, \"Backchannel Authentication Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.auth_req_id, '\"response\" body \"auth_req_id\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    let expiresIn = typeof json.expires_in !== \"number\" ? parseFloat(json.expires_in) : json.expires_in;\n    assertNumber(expiresIn, true, '\"response\" body \"expires_in\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    json.expires_in = expiresIn;\n    if (json.interval !== undefined) {\n        assertNumber(json.interval, false, '\"response\" body \"interval\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nasync function backchannelAuthenticationGrantRequest(as, client, clientAuthentication, authReqId, options) {\n    assertAs(as);\n    assertClient(client);\n    assertString(authReqId, '\"authReqId\"');\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"auth_req_id\", authReqId);\n    return tokenEndpointRequest(as, client, clientAuthentication, \"urn:openid:params:grant-type:ciba\", parameters, options);\n}\nasync function processBackchannelAuthenticationGrantResponse(as, client, response, options) {\n    return processGenericAccessTokenResponse(as, client, response, undefined, options?.[jweDecrypt], options?.recognizedTokenTypes);\n}\nasync function dynamicClientRegistrationRequest(as, metadata, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, \"registration_endpoint\", metadata.use_mtls_endpoint_aliases, options?.[allowInsecureRequests] !== true);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.set(\"content-type\", \"application/json\");\n    const method = \"POST\";\n    if (options?.DPoP) {\n        assertDPoP(options.DPoP);\n        await options.DPoP.addProof(url, headers, method, options.initialAccessToken);\n    }\n    if (options?.initialAccessToken) {\n        headers.set(\"authorization\", `${headers.has(\"dpop\") ? \"DPoP\" : \"Bearer\"} ${options.initialAccessToken}`);\n    }\n    const response = await (options?.[customFetch] || fetch)(url.href, {\n        body: JSON.stringify(metadata),\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: \"manual\",\n        signal: signal(url, options?.signal)\n    });\n    options?.DPoP?.cacheNonce(response, url);\n    return response;\n}\nasync function processDynamicClientRegistrationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    await checkOAuthBodyError(response, 201, \"Dynamic Client Registration Endpoint\");\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.client_id, '\"response\" body \"client_id\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    if (json.client_secret !== undefined) {\n        assertString(json.client_secret, '\"response\" body \"client_secret\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    if (json.client_secret) {\n        assertNumber(json.client_secret_expires_at, true, '\"response\" body \"client_secret_expires_at\" property', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nasync function resourceDiscoveryRequest(resourceIdentifier, options) {\n    return performDiscovery(resourceIdentifier, \"resourceIdentifier\", (url)=>{\n        prependWellKnown(url, \".well-known/oauth-protected-resource\", true);\n        return url;\n    }, options);\n}\nasync function processResourceDiscoveryResponse(expectedResourceIdentifier, response) {\n    const expected = expectedResourceIdentifier;\n    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {\n        throw CodedTypeError('\"expectedResourceIdentifier\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw CodedTypeError('\"response\" must be an instance of Response', ERR_INVALID_ARG_TYPE);\n    }\n    if (response.status !== 200) {\n        throw OPE('\"response\" is not a conform Resource Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);\n    }\n    assertReadableResponse(response);\n    const json = await getResponseJsonBody(response);\n    assertString(json.resource, '\"response\" body \"resource\" property', INVALID_RESPONSE, {\n        body: json\n    });\n    if (expected !== _nodiscoverycheck && new URL(json.resource).href !== expected.href) {\n        throw OPE('\"response\" body \"resource\" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, {\n            expected: expected.href,\n            body: json,\n            attribute: \"resource\"\n        });\n    }\n    return json;\n}\nasync function getResponseJsonBody(response, check = assertApplicationJson) {\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        check(response);\n        throw OPE('failed to parse \"response\" body as JSON', PARSE_ERROR, cause);\n    }\n    if (!isJsonObject(json)) {\n        throw OPE('\"response\" body must be a top level object', INVALID_RESPONSE, {\n            body: json\n        });\n    }\n    return json;\n}\nconst _nopkce = nopkce;\nconst _nodiscoverycheck = Symbol();\nconst _expectedIssuer = Symbol(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb2F1dGg0d2ViYXBpL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUE7QUFDSixJQUFJLE9BQU9DLGNBQWMsZUFBZSxDQUFDQSxVQUFVQyxTQUFTLEVBQUVDLGFBQWEsaUJBQWlCO0lBQ3hGLE1BQU1DLE9BQU87SUFDYixNQUFNQyxVQUFVO0lBQ2hCTCxhQUFhLENBQUMsRUFBRUksS0FBSyxDQUFDLEVBQUVDLFFBQVEsQ0FBQztBQUNyQztBQUNBLFNBQVNDLGdCQUFnQkMsS0FBSyxFQUFFQyxRQUFRO0lBQ3BDLElBQUlELFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxPQUFRQSxpQkFBaUJDLFlBQ3JCQyxPQUFPQyxjQUFjLENBQUNILE1BQU0sQ0FBQ0ksT0FBT0MsV0FBVyxDQUFDLEtBQUtKLFNBQVNLLFNBQVMsQ0FBQ0YsT0FBT0MsV0FBVyxDQUFDO0lBQ25HLEVBQ0EsT0FBTTtRQUNGLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTUUsd0JBQXdCO0FBQzlCLE1BQU1DLHVCQUF1QjtBQUM3QixTQUFTQyxlQUFlQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsS0FBSztJQUN4QyxNQUFNQyxNQUFNLElBQUlDLFVBQVVKLFNBQVM7UUFBRUU7SUFBTTtJQUMzQ1YsT0FBT2EsTUFBTSxDQUFDRixLQUFLO1FBQUVGO0lBQUs7SUFDMUIsT0FBT0U7QUFDWDtBQUNPLE1BQU1HLHdCQUF3QlosU0FBUztBQUN2QyxNQUFNYSxZQUFZYixTQUFTO0FBQzNCLE1BQU1jLGlCQUFpQmQsU0FBUztBQUNoQyxNQUFNZSxjQUFjZixTQUFTO0FBQzdCLE1BQU1nQixrQkFBa0JoQixTQUFTO0FBQ2pDLE1BQU1pQixhQUFhakIsU0FBUztB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Olsid2VicGFjazovL3BpZ21lbnRvc3RrdHMtd2ViLy4vbm9kZV9tb2R1bGVzL29hdXRoNHdlYmFwaS9idWlsZC9pbmRleC5qcz8zZDQxIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBVU0VSX0FHRU5UO1xuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IudXNlckFnZW50Py5zdGFydHNXaXRoPy4oJ01vemlsbGEvNS4wICcpKSB7XG4gICAgY29uc3QgTkFNRSA9ICdvYXV0aDR3ZWJhcGknO1xuICAgIGNvbnN0IFZFUlNJT04gPSAndjMuOC4zJztcbiAgICBVU0VSX0FHRU5UID0gYCR7TkFNRX0vJHtWRVJTSU9OfWA7XG59XG5mdW5jdGlvbiBsb29zZUluc3RhbmNlT2YoaW5wdXQsIGV4cGVjdGVkKSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGlucHV0IGluc3RhbmNlb2YgZXhwZWN0ZWQgfHxcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dClbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gZXhwZWN0ZWQucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSAnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJztcbmNvbnN0IEVSUl9JTlZBTElEX0FSR19UWVBFID0gJ0VSUl9JTlZBTElEX0FSR19UWVBFJztcbmZ1bmN0aW9uIENvZGVkVHlwZUVycm9yKG1lc3NhZ2UsIGNvZGUsIGNhdXNlKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlLCB7IGNhdXNlIH0pO1xuICAgIE9iamVjdC5hc3NpZ24oZXJyLCB7IGNvZGUgfSk7XG4gICAgcmV0dXJuIGVycjtcbn1cbmV4cG9ydCBjb25zdCBhbGxvd0luc2VjdXJlUmVxdWVzdHMgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBjbG9ja1NrZXcgPSBTeW1ib2woKTtcbmV4cG9ydCBjb25zdCBjbG9ja1RvbGVyYW5jZSA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGN1c3RvbUZldGNoID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgbW9kaWZ5QXNzZXJ0aW9uID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgandlRGVjcnlwdCA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGp3a3NDYWNoZSA9IFN5bWJvbCgpO1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZnVuY3Rpb24gYnVmKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbn1cbmxldCBlbmNvZGVCYXNlNjRVcmw7XG5pZiAoVWludDhBcnJheS5wcm90b3R5cGUudG9CYXNlNjQpIHtcbiAgICBlbmNvZGVCYXNlNjRVcmwgPSAoaW5wdXQpID0+IHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC50b0Jhc2U2NCh7IGFscGhhYmV0OiAnYmFzZTY0dXJsJywgb21pdFBhZGRpbmc6IHRydWUgfSk7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIGNvbnN0IENIVU5LX1NJWkUgPSAweDgwMDA7XG4gICAgZW5jb2RlQmFzZTY0VXJsID0gKGlucHV0KSA9PiB7XG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5ieXRlTGVuZ3RoOyBpICs9IENIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaW5wdXQuc3ViYXJyYXkoaSwgaSArIENIVU5LX1NJWkUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ0b2EoYXJyLmpvaW4oJycpKS5yZXBsYWNlKC89L2csICcnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbiAgICB9O1xufVxubGV0IGRlY29kZUJhc2U2NFVybDtcbmlmIChVaW50OEFycmF5LmZyb21CYXNlNjQpIHtcbiAgICBkZWNvZGVCYXNlNjRVcmwgPSAoaW5wdXQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb21CYXNlNjQoaW5wdXQsIHsgYWxwaGFiZXQ6ICdiYXNlNjR1cmwnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1RoZSBpbnB1dCB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC4nLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIGNhdXNlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5lbHNlIHtcbiAgICBkZWNvZGVCYXNlNjRVcmwgPSAoaW5wdXQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoaW5wdXQucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKS5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignVGhlIGlucHV0IHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLicsIEVSUl9JTlZBTElEX0FSR19WQUxVRSwgY2F1c2UpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGI2NHUoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVjb2RlQmFzZTY0VXJsKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NFVybChpbnB1dCk7XG59XG5leHBvcnQgY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb2RlO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gVU5TVVBQT1JURURfT1BFUkFUSU9OO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZTtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmIChvcHRpb25zPy5jb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUgPSBvcHRpb25zPy5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4odGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gT1BFKG1lc3NhZ2UsIGNvZGUsIGNhdXNlKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IobWVzc2FnZSwgeyBjb2RlLCBjYXVzZSB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUp3a1RodW1icHJpbnQoandrKSB7XG4gICAgbGV0IGNvbXBvbmVudHM7XG4gICAgc3dpdGNoIChqd2sua3R5KSB7XG4gICAgICAgIGNhc2UgJ0VDJzpcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7XG4gICAgICAgICAgICAgICAgY3J2OiBqd2suY3J2LFxuICAgICAgICAgICAgICAgIGt0eTogandrLmt0eSxcbiAgICAgICAgICAgICAgICB4OiBqd2sueCxcbiAgICAgICAgICAgICAgICB5OiBqd2sueSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnT0tQJzpcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7XG4gICAgICAgICAgICAgICAgY3J2OiBqd2suY3J2LFxuICAgICAgICAgICAgICAgIGt0eTogandrLmt0eSxcbiAgICAgICAgICAgICAgICB4OiBqd2sueCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQUtQJzpcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSB7XG4gICAgICAgICAgICAgICAgYWxnOiBqd2suYWxnLFxuICAgICAgICAgICAgICAgIGt0eTogandrLmt0eSxcbiAgICAgICAgICAgICAgICBwdWI6IGp3ay5wdWIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTQSc6XG4gICAgICAgICAgICBjb21wb25lbnRzID0ge1xuICAgICAgICAgICAgICAgIGU6IGp3ay5lLFxuICAgICAgICAgICAgICAgIGt0eTogandrLmt0eSxcbiAgICAgICAgICAgICAgICBuOiBqd2subixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBKV0sga2V5IHR5cGUnLCB7IGNhdXNlOiBqd2sgfSk7XG4gICAgfVxuICAgIHJldHVybiBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKEpTT04uc3RyaW5naWZ5KGNvbXBvbmVudHMpKSkpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q3J5cHRvS2V5KGtleSwgaXQpIHtcbiAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBDcnlwdG9LZXkpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGAke2l0fSBtdXN0IGJlIGEgQ3J5cHRvS2V5YCwgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFByaXZhdGVLZXkoa2V5LCBpdCkge1xuICAgIGFzc2VydENyeXB0b0tleShrZXksIGl0KTtcbiAgICBpZiAoa2V5LnR5cGUgIT09ICdwcml2YXRlJykge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcihgJHtpdH0gbXVzdCBiZSBhIHByaXZhdGUgQ3J5cHRvS2V5YCwgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRQdWJsaWNLZXkoa2V5LCBpdCkge1xuICAgIGFzc2VydENyeXB0b0tleShrZXksIGl0KTtcbiAgICBpZiAoa2V5LnR5cGUgIT09ICdwdWJsaWMnKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGAke2l0fSBtdXN0IGJlIGEgcHVibGljIENyeXB0b0tleWAsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplVHlwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXmFwcGxpY2F0aW9uXFwvLywgJycpO1xufVxuZnVuY3Rpb24gaXNKc29uT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVIZWFkZXJzKGlucHV0KSB7XG4gICAgaWYgKGxvb3NlSW5zdGFuY2VPZihpbnB1dCwgSGVhZGVycykpIHtcbiAgICAgICAgaW5wdXQgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5wdXQuZW50cmllcygpKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0ID8/IHt9KTtcbiAgICBpZiAoVVNFUl9BR0VOVCAmJiAhaGVhZGVycy5oYXMoJ3VzZXItYWdlbnQnKSkge1xuICAgICAgICBoZWFkZXJzLnNldCgndXNlci1hZ2VudCcsIFVTRVJfQUdFTlQpO1xuICAgIH1cbiAgICBpZiAoaGVhZGVycy5oYXMoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJvcHRpb25zLmhlYWRlcnNcIiBtdXN0IG5vdCBpbmNsdWRlIHRoZSBcImF1dGhvcml6YXRpb25cIiBoZWFkZXIgbmFtZScsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gc2lnbmFsKHVybCwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKHVybC5ocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSkge1xuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wib3B0aW9ucy5zaWduYWxcIiBtdXN0IHJldHVybiBvciBiZSBhbiBpbnN0YW5jZSBvZiBBYm9ydFNpZ25hbCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXBsYWNlRG91YmxlU2xhc2gocGF0aG5hbWUpIHtcbiAgICBpZiAocGF0aG5hbWUuaW5jbHVkZXMoJy8vJykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhuYW1lO1xufVxuZnVuY3Rpb24gcHJlcGVuZFdlbGxLbm93bih1cmwsIHdlbGxLbm93biwgYWxsb3dUZXJtaW5hdGluZ1NsYXNoID0gZmFsc2UpIHtcbiAgICBpZiAodXJsLnBhdGhuYW1lID09PSAnLycpIHtcbiAgICAgICAgdXJsLnBhdGhuYW1lID0gd2VsbEtub3duO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJsLnBhdGhuYW1lID0gcmVwbGFjZURvdWJsZVNsYXNoKGAke3dlbGxLbm93bn0vJHthbGxvd1Rlcm1pbmF0aW5nU2xhc2ggPyB1cmwucGF0aG5hbWUgOiB1cmwucGF0aG5hbWUucmVwbGFjZSgvKFxcLykkLywgJycpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gYXBwZW5kV2VsbEtub3duKHVybCwgd2VsbEtub3duKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVwbGFjZURvdWJsZVNsYXNoKGAke3VybC5wYXRobmFtZX0vJHt3ZWxsS25vd259YCk7XG4gICAgcmV0dXJuIHVybDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1EaXNjb3ZlcnkoaW5wdXQsIHVybE5hbWUsIHRyYW5zZm9ybSwgb3B0aW9ucykge1xuICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcihgXCIke3VybE5hbWV9XCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxgLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGNoZWNrUHJvdG9jb2woaW5wdXQsIG9wdGlvbnM/LlthbGxvd0luc2VjdXJlUmVxdWVzdHNdICE9PSB0cnVlKTtcbiAgICBjb25zdCB1cmwgPSB0cmFuc2Zvcm0obmV3IFVSTChpbnB1dC5ocmVmKSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHJldHVybiAob3B0aW9ucz8uW2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHVybCwgb3B0aW9ucz8uc2lnbmFsKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNjb3ZlcnlSZXF1ZXN0KGlzc3VlcklkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGVyZm9ybURpc2NvdmVyeShpc3N1ZXJJZGVudGlmaWVyLCAnaXNzdWVySWRlbnRpZmllcicsICh1cmwpID0+IHtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zPy5hbGdvcml0aG0pIHtcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgY2FzZSAnb2lkYyc6XG4gICAgICAgICAgICAgICAgYXBwZW5kV2VsbEtub3duKHVybCwgJy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYXV0aDInOlxuICAgICAgICAgICAgICAgIHByZXBlbmRXZWxsS25vd24odXJsLCAnLndlbGwta25vd24vb2F1dGgtYXV0aG9yaXphdGlvbi1zZXJ2ZXInKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wib3B0aW9ucy5hbGdvcml0aG1cIiBtdXN0IGJlIFwib2lkY1wiIChkZWZhdWx0KSwgb3IgXCJvYXV0aDJcIicsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlcihpbnB1dCwgYWxsb3cwLCBpdCwgY29kZSwgY2F1c2UpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzRmluaXRlKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoYCR7aXR9IG11c3QgYmUgYSBudW1iZXJgLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgY2F1c2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhbGxvdzApIHtcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGAke2l0fSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcmAsIEVSUl9JTlZBTElEX0FSR19WQUxVRSwgY2F1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKGAke2l0fSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyYCwgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBjYXVzZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IE9QRShlcnIubWVzc2FnZSwgY29kZSwgY2F1c2UpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRTdHJpbmcoaW5wdXQsIGl0LCBjb2RlLCBjYXVzZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcihgJHtpdH0gbXVzdCBiZSBhIHN0cmluZ2AsIEVSUl9JTlZBTElEX0FSR19UWVBFLCBjYXVzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoYCR7aXR9IG11c3Qgbm90IGJlIGVtcHR5YCwgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBjYXVzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKGVyci5tZXNzYWdlLCBjb2RlLCBjYXVzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGlzY292ZXJ5UmVzcG9uc2UoZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyLCByZXNwb25zZSkge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyO1xuICAgIGlmICghKGV4cGVjdGVkIGluc3RhbmNlb2YgVVJMKSAmJiBleHBlY3RlZCAhPT0gX25vZGlzY292ZXJ5Y2hlY2spIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBBdXRob3JpemF0aW9uIFNlcnZlciBNZXRhZGF0YSByZXNwb25zZSAodW5leHBlY3RlZCBIVFRQIHN0YXR1cyBjb2RlKScsIFJFU1BPTlNFX0lTX05PVF9DT05GT1JNLCByZXNwb25zZSk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBnZXRSZXNwb25zZUpzb25Cb2R5KHJlc3BvbnNlKTtcbiAgICBhc3NlcnRTdHJpbmcoanNvbi5pc3N1ZXIsICdcInJlc3BvbnNlXCIgYm9keSBcImlzc3VlclwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwgeyBib2R5OiBqc29uIH0pO1xuICAgIGlmIChleHBlY3RlZCAhPT0gX25vZGlzY292ZXJ5Y2hlY2sgJiYgbmV3IFVSTChqc29uLmlzc3VlcikuaHJlZiAhPT0gZXhwZWN0ZWQuaHJlZikge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaXNzdWVyXCIgcHJvcGVydHkgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHZhbHVlJywgSlNPTl9BVFRSSUJVVEVfQ09NUEFSSVNPTiwgeyBleHBlY3RlZDogZXhwZWN0ZWQuaHJlZiwgYm9keToganNvbiwgYXR0cmlidXRlOiAnaXNzdWVyJyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5mdW5jdGlvbiBhc3NlcnRBcHBsaWNhdGlvbkpzb24ocmVzcG9uc2UpIHtcbiAgICBhc3NlcnRDb250ZW50VHlwZShyZXNwb25zZSwgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbn1cbmZ1bmN0aW9uIG5vdEpzb24ocmVzcG9uc2UsIC4uLnR5cGVzKSB7XG4gICAgbGV0IG1zZyA9ICdcInJlc3BvbnNlXCIgY29udGVudC10eXBlIG11c3QgYmUgJztcbiAgICBpZiAodHlwZXMubGVuZ3RoID4gMikge1xuICAgICAgICBjb25zdCBsYXN0ID0gdHlwZXMucG9wKCk7XG4gICAgICAgIG1zZyArPSBgJHt0eXBlcy5qb2luKCcsICcpfSwgb3IgJHtsYXN0fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtc2cgKz0gYCR7dHlwZXNbMF19IG9yICR7dHlwZXNbMV19YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1zZyArPSB0eXBlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIE9QRShtc2csIFJFU1BPTlNFX0lTX05PVF9KU09OLCByZXNwb25zZSk7XG59XG5mdW5jdGlvbiBhc3NlcnRDb250ZW50VHlwZXMocmVzcG9uc2UsIC4uLnR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5pbmNsdWRlcyhnZXRDb250ZW50VHlwZShyZXNwb25zZSkpKSB7XG4gICAgICAgIHRocm93IG5vdEpzb24ocmVzcG9uc2UsIC4uLnR5cGVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRDb250ZW50VHlwZShyZXNwb25zZSwgY29udGVudFR5cGUpIHtcbiAgICBpZiAoZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpICE9PSBjb250ZW50VHlwZSkge1xuICAgICAgICB0aHJvdyBub3RKc29uKHJlc3BvbnNlLCBjb250ZW50VHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoKSB7XG4gICAgcmV0dXJuIGI2NHUoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUNvZGVWZXJpZmllcigpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0YXRlKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tTm9uY2UoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKSB7XG4gICAgYXNzZXJ0U3RyaW5nKGNvZGVWZXJpZmllciwgJ2NvZGVWZXJpZmllcicpO1xuICAgIHJldHVybiBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGNvZGVWZXJpZmllcikpKTtcbn1cbmZ1bmN0aW9uIGdldEtleUFuZEtpZChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENyeXB0b0tleSkge1xuICAgICAgICByZXR1cm4geyBrZXk6IGlucHV0IH07XG4gICAgfVxuICAgIGlmICghKGlucHV0Py5rZXkgaW5zdGFuY2VvZiBDcnlwdG9LZXkpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmtpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhpbnB1dC5raWQsICdcImtpZFwiJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogaW5wdXQua2V5LFxuICAgICAgICBraWQ6IGlucHV0LmtpZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gcHNBbGcoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnUFMyNTYnO1xuICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnUFMzODQnO1xuICAgICAgICBjYXNlICdTSEEtNTEyJzpcbiAgICAgICAgICAgIHJldHVybiAnUFM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIFJzYUhhc2hlZEtleUFsZ29yaXRobSBoYXNoIG5hbWUnLCB7XG4gICAgICAgICAgICAgICAgY2F1c2U6IGtleSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJzQWxnKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnU0hBLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ1JTMjU2JztcbiAgICAgICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ1JTMzg0JztcbiAgICAgICAgY2FzZSAnU0hBLTUxMic6XG4gICAgICAgICAgICByZXR1cm4gJ1JTNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBSc2FIYXNoZWRLZXlBbGdvcml0aG0gaGFzaCBuYW1lJywge1xuICAgICAgICAgICAgICAgIGNhdXNlOiBrZXksXG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlc0FsZyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSkge1xuICAgICAgICBjYXNlICdQLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ0VTMjU2JztcbiAgICAgICAgY2FzZSAnUC0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdFUzM4NCc7XG4gICAgICAgIGNhc2UgJ1AtNTIxJzpcbiAgICAgICAgICAgIHJldHVybiAnRVM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEVjS2V5QWxnb3JpdGhtIG5hbWVkQ3VydmUnLCB7IGNhdXNlOiBrZXkgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5VG9Kd3Moa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnUlNBLVBTUyc6XG4gICAgICAgICAgICByZXR1cm4gcHNBbGcoa2V5KTtcbiAgICAgICAgY2FzZSAnUlNBU1NBLVBLQ1MxLXYxXzUnOlxuICAgICAgICAgICAgcmV0dXJuIHJzQWxnKGtleSk7XG4gICAgICAgIGNhc2UgJ0VDRFNBJzpcbiAgICAgICAgICAgIHJldHVybiBlc0FsZyhrZXkpO1xuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgY2FzZSAnTUwtRFNBLTQ0JzpcbiAgICAgICAgY2FzZSAnTUwtRFNBLTY1JzpcbiAgICAgICAgY2FzZSAnTUwtRFNBLTg3JzpcbiAgICAgICAgICAgIHJldHVybiBrZXkuYWxnb3JpdGhtLm5hbWU7XG4gICAgICAgIGNhc2UgJ0VkRFNBJzpcbiAgICAgICAgICAgIHJldHVybiAnRWQyNTUxOSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgQ3J5cHRvS2V5IGFsZ29yaXRobSBuYW1lJywgeyBjYXVzZToga2V5IH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENsb2NrU2tldyhjbGllbnQpIHtcbiAgICBjb25zdCBza2V3ID0gY2xpZW50Py5bY2xvY2tTa2V3XTtcbiAgICByZXR1cm4gdHlwZW9mIHNrZXcgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShza2V3KSA/IHNrZXcgOiAwO1xufVxuZnVuY3Rpb24gZ2V0Q2xvY2tUb2xlcmFuY2UoY2xpZW50KSB7XG4gICAgY29uc3QgdG9sZXJhbmNlID0gY2xpZW50Py5bY2xvY2tUb2xlcmFuY2VdO1xuICAgIHJldHVybiB0eXBlb2YgdG9sZXJhbmNlID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUodG9sZXJhbmNlKSAmJiBNYXRoLnNpZ24odG9sZXJhbmNlKSAhPT0gLTFcbiAgICAgICAgPyB0b2xlcmFuY2VcbiAgICAgICAgOiAzMDtcbn1cbmZ1bmN0aW9uIGVwb2NoVGltZSgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG59XG5mdW5jdGlvbiBhc3NlcnRBcyhhcykge1xuICAgIGlmICh0eXBlb2YgYXMgIT09ICdvYmplY3QnIHx8IGFzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImFzXCIgbXVzdCBiZSBhbiBvYmplY3QnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGFzc2VydFN0cmluZyhhcy5pc3N1ZXIsICdcImFzLmlzc3VlclwiJyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGllbnQoY2xpZW50KSB7XG4gICAgaWYgKHR5cGVvZiBjbGllbnQgIT09ICdvYmplY3QnIHx8IGNsaWVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJjbGllbnRcIiBtdXN0IGJlIGFuIG9iamVjdCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgYXNzZXJ0U3RyaW5nKGNsaWVudC5jbGllbnRfaWQsICdcImNsaWVudC5jbGllbnRfaWRcIicpO1xufVxuZnVuY3Rpb24gZm9ybVVybEVuY29kZSh0b2tlbikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodG9rZW4pLnJlcGxhY2UoLyg/OlstXy4hfionKCldfCUyMCkvZywgKHN1YnN0cmluZykgPT4ge1xuICAgICAgICBzd2l0Y2ggKHN1YnN0cmluZykge1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBjYXNlICdfJzpcbiAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAlJHtzdWJzdHJpbmcuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgICAgY2FzZSAnJTIwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJysnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlY3JldFBvc3QoY2xpZW50U2VjcmV0KSB7XG4gICAgYXNzZXJ0U3RyaW5nKGNsaWVudFNlY3JldCwgJ1wiY2xpZW50U2VjcmV0XCInKTtcbiAgICByZXR1cm4gKF9hcywgY2xpZW50LCBib2R5LCBfaGVhZGVycykgPT4ge1xuICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgIGJvZHkuc2V0KCdjbGllbnRfc2VjcmV0JywgY2xpZW50U2VjcmV0KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlY3JldEJhc2ljKGNsaWVudFNlY3JldCkge1xuICAgIGFzc2VydFN0cmluZyhjbGllbnRTZWNyZXQsICdcImNsaWVudFNlY3JldFwiJyk7XG4gICAgcmV0dXJuIChfYXMsIGNsaWVudCwgX2JvZHksIGhlYWRlcnMpID0+IHtcbiAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBmb3JtVXJsRW5jb2RlKGNsaWVudC5jbGllbnRfaWQpO1xuICAgICAgICBjb25zdCBwYXNzd29yZCA9IGZvcm1VcmxFbmNvZGUoY2xpZW50U2VjcmV0KTtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSBidG9hKGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWApO1xuICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2NyZWRlbnRpYWxzfWApO1xuICAgIH07XG59XG5mdW5jdGlvbiBjbGllbnRBc3NlcnRpb25QYXlsb2FkKGFzLCBjbGllbnQpIHtcbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgYXVkOiBhcy5pc3N1ZXIsXG4gICAgICAgIGV4cDogbm93ICsgNjAsXG4gICAgICAgIGlhdDogbm93LFxuICAgICAgICBuYmY6IG5vdyxcbiAgICAgICAgaXNzOiBjbGllbnQuY2xpZW50X2lkLFxuICAgICAgICBzdWI6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBQcml2YXRlS2V5Snd0KGNsaWVudFByaXZhdGVLZXksIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGtleSwga2lkIH0gPSBnZXRLZXlBbmRLaWQoY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgYXNzZXJ0UHJpdmF0ZUtleShrZXksICdcImNsaWVudFByaXZhdGVLZXkua2V5XCInKTtcbiAgICByZXR1cm4gYXN5bmMgKGFzLCBjbGllbnQsIGJvZHksIF9oZWFkZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHsgYWxnOiBrZXlUb0p3cyhrZXkpLCBraWQgfTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGNsaWVudEFzc2VydGlvblBheWxvYWQoYXMsIGNsaWVudCk7XG4gICAgICAgIG9wdGlvbnM/Llttb2RpZnlBc3NlcnRpb25dPy4oaGVhZGVyLCBwYXlsb2FkKTtcbiAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgICAgICBib2R5LnNldCgnY2xpZW50X2Fzc2VydGlvbl90eXBlJywgJ3VybjppZXRmOnBhcmFtczpvYXV0aDpjbGllbnQtYXNzZXJ0aW9uLXR5cGU6and0LWJlYXJlcicpO1xuICAgICAgICBib2R5LnNldCgnY2xpZW50X2Fzc2VydGlvbicsIGF3YWl0IHNpZ25Kd3QoaGVhZGVyLCBwYXlsb2FkLCBrZXkpKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlY3JldEp3dChjbGllbnRTZWNyZXQsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRTdHJpbmcoY2xpZW50U2VjcmV0LCAnXCJjbGllbnRTZWNyZXRcIicpO1xuICAgIGNvbnN0IG1vZGlmeSA9IG9wdGlvbnM/Llttb2RpZnlBc3NlcnRpb25dO1xuICAgIGxldCBrZXk7XG4gICAgcmV0dXJuIGFzeW5jIChhcywgY2xpZW50LCBib2R5LCBfaGVhZGVycykgPT4ge1xuICAgICAgICBrZXkgfHw9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBidWYoY2xpZW50U2VjcmV0KSwgeyBoYXNoOiAnU0hBLTI1NicsIG5hbWU6ICdITUFDJyB9LCBmYWxzZSwgWydzaWduJ10pO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSB7IGFsZzogJ0hTMjU2JyB9O1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gY2xpZW50QXNzZXJ0aW9uUGF5bG9hZChhcywgY2xpZW50KTtcbiAgICAgICAgbW9kaWZ5Py4oaGVhZGVyLCBwYXlsb2FkKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGAke2I2NHUoYnVmKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpKX0uJHtiNjR1KGJ1ZihKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpfWA7XG4gICAgICAgIGNvbnN0IGhtYWMgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oa2V5LmFsZ29yaXRobSwga2V5LCBidWYoZGF0YSkpO1xuICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgIGJvZHkuc2V0KCdjbGllbnRfYXNzZXJ0aW9uX3R5cGUnLCAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyJyk7XG4gICAgICAgIGJvZHkuc2V0KCdjbGllbnRfYXNzZXJ0aW9uJywgYCR7ZGF0YX0uJHtiNjR1KG5ldyBVaW50OEFycmF5KGhtYWMpKX1gKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIE5vbmUoKSB7XG4gICAgcmV0dXJuIChfYXMsIGNsaWVudCwgYm9keSwgX2hlYWRlcnMpID0+IHtcbiAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gVGxzQ2xpZW50QXV0aCgpIHtcbiAgICByZXR1cm4gTm9uZSgpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnbkp3dChoZWFkZXIsIHBheWxvYWQsIGtleSkge1xuICAgIGlmICgha2V5LnVzYWdlcy5pbmNsdWRlcygnc2lnbicpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdDcnlwdG9LZXkgaW5zdGFuY2VzIHVzZWQgZm9yIHNpZ25pbmcgYXNzZXJ0aW9ucyBtdXN0IGluY2x1ZGUgXCJzaWduXCIgaW4gdGhlaXIgXCJ1c2FnZXNcIicsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gYCR7YjY0dShidWYoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSkpfS4ke2I2NHUoYnVmKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSl9YDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihrZXlUb1N1YnRsZShrZXkpLCBrZXksIGJ1ZihpbnB1dCkpKTtcbiAgICByZXR1cm4gYCR7aW5wdXR9LiR7c2lnbmF0dXJlfWA7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNzdWVSZXF1ZXN0T2JqZWN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIHByaXZhdGVLZXksIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgY29uc3QgeyBrZXksIGtpZCB9ID0gZ2V0S2V5QW5kS2lkKHByaXZhdGVLZXkpO1xuICAgIGFzc2VydFByaXZhdGVLZXkoa2V5LCAnXCJwcml2YXRlS2V5LmtleVwiJyk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgY29uc3QgY2xhaW1zID0ge1xuICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMocGFyYW1ldGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBqdGk6IHJhbmRvbUJ5dGVzKCksXG4gICAgICAgIGF1ZDogYXMuaXNzdWVyLFxuICAgICAgICBleHA6IG5vdyArIDYwLFxuICAgICAgICBpYXQ6IG5vdyxcbiAgICAgICAgbmJmOiBub3csXG4gICAgICAgIGlzczogY2xpZW50LmNsaWVudF9pZCxcbiAgICB9O1xuICAgIGxldCByZXNvdXJjZTtcbiAgICBpZiAocGFyYW1ldGVycy5oYXMoJ3Jlc291cmNlJykgJiZcbiAgICAgICAgKHJlc291cmNlID0gcGFyYW1ldGVycy5nZXRBbGwoJ3Jlc291cmNlJykpICYmXG4gICAgICAgIHJlc291cmNlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2xhaW1zLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgfVxuICAgIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1ldGVycy5nZXQoJ21heF9hZ2UnKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGFpbXMubWF4X2FnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICBhc3NlcnROdW1iZXIoY2xhaW1zLm1heF9hZ2UsIHRydWUsICdcIm1heF9hZ2VcIiBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtZXRlcnMuZ2V0KCdjbGFpbXMnKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNsYWltcy5jbGFpbXMgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IE9QRSgnZmFpbGVkIHRvIHBhcnNlIHRoZSBcImNsYWltc1wiIHBhcmFtZXRlciBhcyBKU09OJywgUEFSU0VfRVJST1IsIGNhdXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcy5jbGFpbXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiY2xhaW1zXCIgcGFyYW1ldGVyIG11c3QgYmUgYSBKU09OIHdpdGggYSB0b3AgbGV2ZWwgb2JqZWN0JywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtZXRlcnMuZ2V0KCdhdXRob3JpemF0aW9uX2RldGFpbHMnKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNsYWltcy5hdXRob3JpemF0aW9uX2RldGFpbHMgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IE9QRSgnZmFpbGVkIHRvIHBhcnNlIHRoZSBcImF1dGhvcml6YXRpb25fZGV0YWlsc1wiIHBhcmFtZXRlciBhcyBKU09OJywgUEFSU0VfRVJST1IsIGNhdXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjbGFpbXMuYXV0aG9yaXphdGlvbl9kZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImF1dGhvcml6YXRpb25fZGV0YWlsc1wiIHBhcmFtZXRlciBtdXN0IGJlIGEgSlNPTiB3aXRoIGEgdG9wIGxldmVsIGFycmF5JywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAgIGFsZzoga2V5VG9Kd3Moa2V5KSxcbiAgICAgICAgdHlwOiAnb2F1dGgtYXV0aHotcmVxK2p3dCcsXG4gICAgICAgIGtpZCxcbiAgICB9O1xuICAgIG9wdGlvbnM/Llttb2RpZnlBc3NlcnRpb25dPy4oaGVhZGVyLCBjbGFpbXMpO1xuICAgIHJldHVybiBzaWduSnd0KGhlYWRlciwgY2xhaW1zLCBrZXkpO1xufVxubGV0IGp3a0NhY2hlO1xuYXN5bmMgZnVuY3Rpb24gZ2V0U2V0UHVibGljSndrQ2FjaGUoa2V5LCBhbGcpIHtcbiAgICBjb25zdCB7IGt0eSwgZSwgbiwgeCwgeSwgY3J2LCBwdWIgfSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBrZXkpO1xuICAgIGNvbnN0IGp3ayA9IHsga3R5LCBlLCBuLCB4LCB5LCBjcnYsIHB1YiB9O1xuICAgIGlmIChrdHkgPT09ICdBS1AnKVxuICAgICAgICBqd2suYWxnID0gYWxnO1xuICAgIGp3a0NhY2hlLnNldChrZXksIGp3ayk7XG4gICAgcmV0dXJuIGp3aztcbn1cbmFzeW5jIGZ1bmN0aW9uIHB1YmxpY0p3ayhrZXksIGFsZykge1xuICAgIGp3a0NhY2hlIHx8PSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiBqd2tDYWNoZS5nZXQoa2V5KSB8fCBnZXRTZXRQdWJsaWNKd2tDYWNoZShrZXksIGFsZyk7XG59XG5jb25zdCBVUkxQYXJzZSA9IFVSTC5wYXJzZVxuICAgID9cbiAgICAgICAgKHVybCwgYmFzZSkgPT4gVVJMLnBhcnNlKHVybCwgYmFzZSlcbiAgICA6ICh1cmwsIGJhc2UpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybCwgYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUHJvdG9jb2wodXJsLCBlbmZvcmNlSHR0cHMpIHtcbiAgICBpZiAoZW5mb3JjZUh0dHBzICYmIHVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdvbmx5IHJlcXVlc3RzIHRvIEhUVFBTIGFyZSBhbGxvd2VkJywgSFRUUF9SRVFVRVNUX0ZPUkJJRERFTiwgdXJsKTtcbiAgICB9XG4gICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicgJiYgdXJsLnByb3RvY29sICE9PSAnaHR0cDonKSB7XG4gICAgICAgIHRocm93IE9QRSgnb25seSBIVFRQIGFuZCBIVFRQUyByZXF1ZXN0cyBhcmUgYWxsb3dlZCcsIFJFUVVFU1RfUFJPVE9DT0xfRk9SQklEREVOLCB1cmwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRW5kcG9pbnQodmFsdWUsIGVuZHBvaW50LCB1c2VNdGxzQWxpYXMsIGVuZm9yY2VIdHRwcykge1xuICAgIGxldCB1cmw7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgISh1cmwgPSBVUkxQYXJzZSh2YWx1ZSkpKSB7XG4gICAgICAgIHRocm93IE9QRShgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgbWV0YWRhdGEgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkICR7dXNlTXRsc0FsaWFzID8gYFwiYXMubXRsc19lbmRwb2ludF9hbGlhc2VzLiR7ZW5kcG9pbnR9XCJgIDogYFwiYXMuJHtlbmRwb2ludH1cImB9YCwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IE1JU1NJTkdfU0VSVkVSX01FVEFEQVRBIDogSU5WQUxJRF9TRVJWRVJfTUVUQURBVEEsIHsgYXR0cmlidXRlOiB1c2VNdGxzQWxpYXMgPyBgbXRsc19lbmRwb2ludF9hbGlhc2VzLiR7ZW5kcG9pbnR9YCA6IGVuZHBvaW50IH0pO1xuICAgIH1cbiAgICBjaGVja1Byb3RvY29sKHVybCwgZW5mb3JjZUh0dHBzKTtcbiAgICByZXR1cm4gdXJsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVFbmRwb2ludChhcywgZW5kcG9pbnQsIHVzZU10bHNBbGlhcywgZW5mb3JjZUh0dHBzKSB7XG4gICAgaWYgKHVzZU10bHNBbGlhcyAmJiBhcy5tdGxzX2VuZHBvaW50X2FsaWFzZXMgJiYgZW5kcG9pbnQgaW4gYXMubXRsc19lbmRwb2ludF9hbGlhc2VzKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVuZHBvaW50KGFzLm10bHNfZW5kcG9pbnRfYWxpYXNlc1tlbmRwb2ludF0sIGVuZHBvaW50LCB1c2VNdGxzQWxpYXMsIGVuZm9yY2VIdHRwcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZUVuZHBvaW50KGFzW2VuZHBvaW50XSwgZW5kcG9pbnQsIHVzZU10bHNBbGlhcywgZW5mb3JjZUh0dHBzKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdwdXNoZWRfYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2VuZHBvaW50JywgY2xpZW50LnVzZV9tdGxzX2VuZHBvaW50X2FsaWFzZXMsIG9wdGlvbnM/LlthbGxvd0luc2VjdXJlUmVxdWVzdHNdICE9PSB0cnVlKTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0RFBvUChvcHRpb25zLkRQb1ApO1xuICAgICAgICBhd2FpdCBvcHRpb25zLkRQb1AuYWRkUHJvb2YodXJsLCBoZWFkZXJzLCAnUE9TVCcpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xuICAgIG9wdGlvbnM/LkRQb1A/LmNhY2hlTm9uY2UocmVzcG9uc2UsIHVybCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuY2xhc3MgRFBvUEhhbmRsZXIge1xuICAgICNoZWFkZXI7XG4gICAgI3ByaXZhdGVLZXk7XG4gICAgI3B1YmxpY0tleTtcbiAgICAjY2xvY2tTa2V3O1xuICAgICNtb2RpZnlBc3NlcnRpb247XG4gICAgI21hcDtcbiAgICAjamt0O1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwga2V5UGFpciwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnRQcml2YXRlS2V5KGtleVBhaXI/LnByaXZhdGVLZXksICdcIkRQb1AucHJpdmF0ZUtleVwiJyk7XG4gICAgICAgIGFzc2VydFB1YmxpY0tleShrZXlQYWlyPy5wdWJsaWNLZXksICdcIkRQb1AucHVibGljS2V5XCInKTtcbiAgICAgICAgaWYgKCFrZXlQYWlyLnB1YmxpY0tleS5leHRyYWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiRFBvUC5wdWJsaWNLZXkuZXh0cmFjdGFibGVcIiBtdXN0IGJlIHRydWUnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21vZGlmeUFzc2VydGlvbiA9IG9wdGlvbnM/Llttb2RpZnlBc3NlcnRpb25dO1xuICAgICAgICB0aGlzLiNjbG9ja1NrZXcgPSBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICAgICAgdGhpcy4jcHJpdmF0ZUtleSA9IGtleVBhaXIucHJpdmF0ZUtleTtcbiAgICAgICAgdGhpcy4jcHVibGljS2V5ID0ga2V5UGFpci5wdWJsaWNLZXk7XG4gICAgICAgIGJyYW5kZWQuYWRkKHRoaXMpO1xuICAgIH1cbiAgICAjZ2V0KGtleSkge1xuICAgICAgICB0aGlzLiNtYXAgfHw9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLiNtYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLiNtYXAuc2V0KGtleSwgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgICNzZXQoa2V5LCB2YWwpIHtcbiAgICAgICAgdGhpcy4jbWFwIHx8PSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgaWYgKHRoaXMuI21hcC5zaXplID09PSAxMDApIHtcbiAgICAgICAgICAgIHRoaXMuI21hcC5kZWxldGUodGhpcy4jbWFwLmtleXMoKS5uZXh0KCkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21hcC5zZXQoa2V5LCB2YWwpO1xuICAgIH1cbiAgICBhc3luYyBjYWxjdWxhdGVUaHVtYnByaW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuI2prdCkge1xuICAgICAgICAgICAgY29uc3QgandrID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ2p3aycsIHRoaXMuI3B1YmxpY0tleSk7XG4gICAgICAgICAgICB0aGlzLiNqa3QgfHw9IGF3YWl0IGNhbGN1bGF0ZUp3a1RodW1icHJpbnQoandrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jamt0O1xuICAgIH1cbiAgICBhc3luYyBhZGRQcm9vZih1cmwsIGhlYWRlcnMsIGh0bSwgYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgYWxnID0ga2V5VG9Kd3ModGhpcy4jcHJpdmF0ZUtleSk7XG4gICAgICAgIHRoaXMuI2hlYWRlciB8fD0ge1xuICAgICAgICAgICAgYWxnLFxuICAgICAgICAgICAgdHlwOiAnZHBvcCtqd3QnLFxuICAgICAgICAgICAgandrOiBhd2FpdCBwdWJsaWNKd2sodGhpcy4jcHVibGljS2V5LCBhbGcpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub25jZSA9IHRoaXMuI2dldCh1cmwub3JpZ2luKTtcbiAgICAgICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyB0aGlzLiNjbG9ja1NrZXc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpYXQ6IG5vdyxcbiAgICAgICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgICAgIGh0bSxcbiAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgaHR1OiBgJHt1cmwub3JpZ2lufSR7dXJsLnBhdGhuYW1lfWAsXG4gICAgICAgICAgICBhdGg6IGFjY2Vzc1Rva2VuXG4gICAgICAgICAgICAgICAgPyBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGFjY2Vzc1Rva2VuKSkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI21vZGlmeUFzc2VydGlvbj8uKHRoaXMuI2hlYWRlciwgcGF5bG9hZCk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdkcG9wJywgYXdhaXQgc2lnbkp3dCh0aGlzLiNoZWFkZXIsIHBheWxvYWQsIHRoaXMuI3ByaXZhdGVLZXkpKTtcbiAgICB9XG4gICAgY2FjaGVOb25jZShyZXNwb25zZSwgdXJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdkcG9wLW5vbmNlJyk7XG4gICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNzZXQodXJsLm9yaWdpbiwgbm9uY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RQb1BOb25jZUVycm9yKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBXV1dBdXRoZW50aWNhdGVDaGFsbGVuZ2VFcnJvcikge1xuICAgICAgICBjb25zdCB7IDA6IGNoYWxsZW5nZSwgbGVuZ3RoIH0gPSBlcnIuY2F1c2U7XG4gICAgICAgIHJldHVybiAobGVuZ3RoID09PSAxICYmIGNoYWxsZW5nZS5zY2hlbWUgPT09ICdkcG9wJyAmJiBjaGFsbGVuZ2UucGFyYW1ldGVycy5lcnJvciA9PT0gJ3VzZV9kcG9wX25vbmNlJyk7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBSZXNwb25zZUJvZHlFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyLmVycm9yID09PSAndXNlX2Rwb3Bfbm9uY2UnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gRFBvUChjbGllbnQsIGtleVBhaXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERQb1BIYW5kbGVyKGNsaWVudCwga2V5UGFpciwgb3B0aW9ucyk7XG59XG5leHBvcnQgY2xhc3MgUmVzcG9uc2VCb2R5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY2F1c2U7XG4gICAgY29kZTtcbiAgICBlcnJvcjtcbiAgICBzdGF0dXM7XG4gICAgZXJyb3JfZGVzY3JpcHRpb247XG4gICAgcmVzcG9uc2U7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmNvZGUgPSBSRVNQT05TRV9CT0RZX0VSUk9SO1xuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG9wdGlvbnMuY2F1c2UuZXJyb3I7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5yZXNwb25zZS5zdGF0dXM7XG4gICAgICAgIHRoaXMuZXJyb3JfZGVzY3JpcHRpb24gPSBvcHRpb25zLmNhdXNlLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jlc3BvbnNlJywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9wdGlvbnMucmVzcG9uc2UgfSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4odGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhvcml6YXRpb25SZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNhdXNlO1xuICAgIGNvZGU7XG4gICAgZXJyb3I7XG4gICAgZXJyb3JfZGVzY3JpcHRpb247XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmNvZGUgPSBBVVRIT1JJWkFUSU9OX1JFU1BPTlNFX0VSUk9SO1xuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG9wdGlvbnMuY2F1c2UuZ2V0KCdlcnJvcicpO1xuICAgICAgICB0aGlzLmVycm9yX2Rlc2NyaXB0aW9uID0gb3B0aW9ucy5jYXVzZS5nZXQoJ2Vycm9yX2Rlc2NyaXB0aW9uJykgPz8gdW5kZWZpbmVkO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXV1dBdXRoZW50aWNhdGVDaGFsbGVuZ2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjYXVzZTtcbiAgICBjb2RlO1xuICAgIHJlc3BvbnNlO1xuICAgIHN0YXR1cztcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IFdXV19BVVRIRU5USUNBVEVfQ0hBTExFTkdFO1xuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2UnLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmNvbnN0IHRva2VuTWF0Y2ggPSBcIlthLXpBLVowLTkhIyQlJlxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXC5cXFxcXl9gXFxcXHx+XStcIjtcbmNvbnN0IHRva2VuNjhNYXRjaCA9ICdbYS16QS1aMC05XFxcXC1cXFxcLl9cXFxcflxcXFwrXFxcXC9dKz17MCwyfSc7XG5jb25zdCBxdW90ZWRNYXRjaCA9ICdcIigoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcW1xcXFxzXFxcXFNdKSopXCInO1xuY29uc3QgcXVvdGVkUGFyYW1NYXRjaGVyID0gJygnICsgdG9rZW5NYXRjaCArICcpXFxcXHMqPVxcXFxzKicgKyBxdW90ZWRNYXRjaDtcbmNvbnN0IHBhcmFtTWF0Y2hlciA9ICcoJyArIHRva2VuTWF0Y2ggKyAnKVxcXFxzKj1cXFxccyooJyArIHRva2VuTWF0Y2ggKyAnKSc7XG5jb25zdCBzY2hlbWVSRSA9IG5ldyBSZWdFeHAoJ15bLFxcXFxzXSooJyArIHRva2VuTWF0Y2ggKyAnKScpO1xuY29uc3QgcXVvdGVkUGFyYW1SRSA9IG5ldyBSZWdFeHAoJ15bLFxcXFxzXSonICsgcXVvdGVkUGFyYW1NYXRjaGVyICsgJ1ssXFxcXHNdKiguKiknKTtcbmNvbnN0IHVucXVvdGVkUGFyYW1SRSA9IG5ldyBSZWdFeHAoJ15bLFxcXFxzXSonICsgcGFyYW1NYXRjaGVyICsgJ1ssXFxcXHNdKiguKiknKTtcbmNvbnN0IHRva2VuNjhQYXJhbVJFID0gbmV3IFJlZ0V4cCgnXignICsgdG9rZW42OE1hdGNoICsgJykoPzokfFssXFxcXHNdKSguKiknKTtcbmZ1bmN0aW9uIHBhcnNlV3d3QXV0aGVudGljYXRlQ2hhbGxlbmdlcyhyZXNwb25zZSkge1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnd3d3LWF1dGhlbnRpY2F0ZScpO1xuICAgIGlmIChoZWFkZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY2hhbGxlbmdlcyA9IFtdO1xuICAgIGxldCByZXN0ID0gaGVhZGVyO1xuICAgIHdoaWxlIChyZXN0KSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHJlc3QubWF0Y2goc2NoZW1lUkUpO1xuICAgICAgICBjb25zdCBzY2hlbWUgPSBtYXRjaD8uWycxJ10udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCFzY2hlbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWZ0ZXJTY2hlbWUgPSByZXN0LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICBpZiAoYWZ0ZXJTY2hlbWUgJiYgIWFmdGVyU2NoZW1lLm1hdGNoKC9eW1xccyxdLykpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BhY2VNYXRjaCA9IGFmdGVyU2NoZW1lLm1hdGNoKC9eXFxzKyguKikkLyk7XG4gICAgICAgIGNvbnN0IGhhc1BhcmFtZXRlcnMgPSAhIXNwYWNlTWF0Y2g7XG4gICAgICAgIHJlc3QgPSBzcGFjZU1hdGNoID8gc3BhY2VNYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHt9O1xuICAgICAgICBsZXQgdG9rZW42ODtcbiAgICAgICAgaWYgKGhhc1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHdoaWxlIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKChtYXRjaCA9IHJlc3QubWF0Y2gocXVvdGVkUGFyYW1SRSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgWywga2V5LCB2YWx1ZSwgcmVzdF0gPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXFxcJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKGBcIiR7dmFsdWV9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaCh1bnF1b3RlZFBhcmFtUkUpKSkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFssIGtleSwgdmFsdWUsIHJlc3RdID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaCh0b2tlbjY4UGFyYW1SRSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgWywgdG9rZW42OCwgcmVzdF0gPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN0ID0gYWZ0ZXJTY2hlbWUgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWxsZW5nZSA9IHsgc2NoZW1lLCBwYXJhbWV0ZXJzIH07XG4gICAgICAgIGlmICh0b2tlbjY4KSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2UudG9rZW42OCA9IHRva2VuNjg7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbGxlbmdlcy5wdXNoKGNoYWxsZW5nZSk7XG4gICAgfVxuICAgIGlmICghY2hhbGxlbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYWxsZW5nZXM7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1B1c2hlZEF1dGhvcml6YXRpb25SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgYXdhaXQgY2hlY2tPQXV0aEJvZHlFcnJvcihyZXNwb25zZSwgMjAxLCAnUHVzaGVkIEF1dGhvcml6YXRpb24gUmVxdWVzdCBFbmRwb2ludCcpO1xuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBnZXRSZXNwb25zZUpzb25Cb2R5KHJlc3BvbnNlKTtcbiAgICBhc3NlcnRTdHJpbmcoanNvbi5yZXF1ZXN0X3VyaSwgJ1wicmVzcG9uc2VcIiBib2R5IFwicmVxdWVzdF91cmlcIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keToganNvbixcbiAgICB9KTtcbiAgICBsZXQgZXhwaXJlc0luID0gdHlwZW9mIGpzb24uZXhwaXJlc19pbiAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KGpzb24uZXhwaXJlc19pbikgOiBqc29uLmV4cGlyZXNfaW47XG4gICAgYXNzZXJ0TnVtYmVyKGV4cGlyZXNJbiwgdHJ1ZSwgJ1wicmVzcG9uc2VcIiBib2R5IFwiZXhwaXJlc19pblwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICBib2R5OiBqc29uLFxuICAgIH0pO1xuICAgIGpzb24uZXhwaXJlc19pbiA9IGV4cGlyZXNJbjtcbiAgICByZXR1cm4ganNvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlT0F1dGhSZXNwb25zZUVycm9yQm9keShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPiAzOTkgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBhc3NlcnRBcHBsaWNhdGlvbkpzb24ocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmNsb25lKCkuanNvbigpO1xuICAgICAgICAgICAgaWYgKGlzSnNvbk9iamVjdChqc29uKSAmJiB0eXBlb2YganNvbi5lcnJvciA9PT0gJ3N0cmluZycgJiYganNvbi5lcnJvci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UsIGV4cGVjdGVkLCBsYWJlbCkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIGNoZWNrQXV0aGVudGljYXRpb25DaGFsbGVuZ2VzKHJlc3BvbnNlKTtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKChlcnIgPSBhd2FpdCBwYXJzZU9BdXRoUmVzcG9uc2VFcnJvckJvZHkocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgYXdhaXQgcmVzcG9uc2UuYm9keT8uY2FuY2VsKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVzcG9uc2VCb2R5RXJyb3IoJ3NlcnZlciByZXNwb25kZWQgd2l0aCBhbiBlcnJvciBpbiB0aGUgcmVzcG9uc2UgYm9keScsIHtcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgT1BFKGBcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSAke2xhYmVsfSByZXNwb25zZSAodW5leHBlY3RlZCBIVFRQIHN0YXR1cyBjb2RlKWAsIFJFU1BPTlNFX0lTX05PVF9DT05GT1JNLCByZXNwb25zZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0RFBvUChvcHRpb24pIHtcbiAgICBpZiAoIWJyYW5kZWQuaGFzKG9wdGlvbikpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wib3B0aW9ucy5EUG9QXCIgaXMgbm90IGEgdmFsaWQgRFBvUEhhbmRsZScsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVzb3VyY2VSZXF1ZXN0KGFjY2Vzc1Rva2VuLCBtZXRob2QsIHVybCwgaGVhZGVycywgYm9keSwgb3B0aW9ucykge1xuICAgIGFzc2VydFN0cmluZyhhY2Nlc3NUb2tlbiwgJ1wiYWNjZXNzVG9rZW5cIicpO1xuICAgIGlmICghKHVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1widXJsXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkwnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGNoZWNrUHJvdG9jb2wodXJsLCBvcHRpb25zPy5bYWxsb3dJbnNlY3VyZVJlcXVlc3RzXSAhPT0gdHJ1ZSk7XG4gICAgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QKSB7XG4gICAgICAgIGFzc2VydERQb1Aob3B0aW9ucy5EUG9QKTtcbiAgICAgICAgYXdhaXQgb3B0aW9ucy5EUG9QLmFkZFByb29mKHVybCwgaGVhZGVycywgbWV0aG9kLnRvVXBwZXJDYXNlKCksIGFjY2Vzc1Rva2VuKTtcbiAgICB9XG4gICAgaGVhZGVycy5zZXQoJ2F1dGhvcml6YXRpb24nLCBgJHtoZWFkZXJzLmhhcygnZHBvcCcpID8gJ0RQb1AnIDogJ0JlYXJlcid9ICR7YWNjZXNzVG9rZW59YCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAob3B0aW9ucz8uW2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHVybCwgb3B0aW9ucz8uc2lnbmFsKSxcbiAgICB9KTtcbiAgICBvcHRpb25zPy5EUG9QPy5jYWNoZU5vbmNlKHJlc3BvbnNlLCB1cmwpO1xuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QoYWNjZXNzVG9rZW4sIG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBib2R5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNvdXJjZVJlcXVlc3QoYWNjZXNzVG9rZW4sIG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBib2R5LCBvcHRpb25zKTtcbiAgICBjaGVja0F1dGhlbnRpY2F0aW9uQ2hhbGxlbmdlcyhyZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVzZXJJbmZvUmVxdWVzdChhcywgY2xpZW50LCBhY2Nlc3NUb2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICd1c2VyaW5mb19lbmRwb2ludCcsIGNsaWVudC51c2VfbXRsc19lbmRwb2ludF9hbGlhc2VzLCBvcHRpb25zPy5bYWxsb3dJbnNlY3VyZVJlcXVlc3RzXSAhPT0gdHJ1ZSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGlmIChjbGllbnQudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3dCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKCdhY2NlcHQnLCAnYXBwbGljYXRpb24vand0Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZVJlcXVlc3QoYWNjZXNzVG9rZW4sICdHRVQnLCB1cmwsIGhlYWRlcnMsIG51bGwsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgW2Nsb2NrU2tld106IGdldENsb2NrU2tldyhjbGllbnQpLFxuICAgIH0pO1xufVxubGV0IGp3a3NNYXA7XG5mdW5jdGlvbiBzZXRKd2tzQ2FjaGUoYXMsIGp3a3MsIHVhdCwgY2FjaGUpIHtcbiAgICBqd2tzTWFwIHx8PSBuZXcgV2Vha01hcCgpO1xuICAgIGp3a3NNYXAuc2V0KGFzLCB7XG4gICAgICAgIGp3a3MsXG4gICAgICAgIHVhdCxcbiAgICAgICAgZ2V0IGFnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBlcG9jaFRpbWUoKSAtIHRoaXMudWF0O1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGNhY2hlLCB7IGp3a3M6IHN0cnVjdHVyZWRDbG9uZShqd2tzKSwgdWF0IH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRnJlc2hKd2tzQ2FjaGUoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghKCd1YXQnIGluIGlucHV0KSB8fCB0eXBlb2YgaW5wdXQudWF0ICE9PSAnbnVtYmVyJyB8fCBlcG9jaFRpbWUoKSAtIGlucHV0LnVhdCA+PSAzMDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoISgnandrcycgaW4gaW5wdXQpIHx8XG4gICAgICAgICFpc0pzb25PYmplY3QoaW5wdXQuandrcykgfHxcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoaW5wdXQuandrcy5rZXlzKSB8fFxuICAgICAgICAhQXJyYXkucHJvdG90eXBlLmV2ZXJ5LmNhbGwoaW5wdXQuandrcy5rZXlzLCBpc0pzb25PYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjbGVhckp3a3NDYWNoZShhcywgY2FjaGUpIHtcbiAgICBqd2tzTWFwPy5kZWxldGUoYXMpO1xuICAgIGRlbGV0ZSBjYWNoZT8uandrcztcbiAgICBkZWxldGUgY2FjaGU/LnVhdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpIHtcbiAgICBjb25zdCB7IGFsZywga2lkIH0gPSBoZWFkZXI7XG4gICAgY2hlY2tTdXBwb3J0ZWRKd3NBbGcoaGVhZGVyKTtcbiAgICBpZiAoIWp3a3NNYXA/LmhhcyhhcykgJiYgaXNGcmVzaEp3a3NDYWNoZShvcHRpb25zPy5bandrc0NhY2hlXSkpIHtcbiAgICAgICAgc2V0Sndrc0NhY2hlKGFzLCBvcHRpb25zPy5bandrc0NhY2hlXS5qd2tzLCBvcHRpb25zPy5bandrc0NhY2hlXS51YXQpO1xuICAgIH1cbiAgICBsZXQgandrcztcbiAgICBsZXQgYWdlO1xuICAgIGlmIChqd2tzTWFwPy5oYXMoYXMpKSB7XG4gICAgICAgIDtcbiAgICAgICAgKHsgandrcywgYWdlIH0gPSBqd2tzTWFwLmdldChhcykpO1xuICAgICAgICBpZiAoYWdlID49IDMwMCkge1xuICAgICAgICAgICAgY2xlYXJKd2tzQ2FjaGUoYXMsIG9wdGlvbnM/Lltqd2tzQ2FjaGVdKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgandrcyA9IGF3YWl0IGp3a3NSZXF1ZXN0KGFzLCBvcHRpb25zKS50aGVuKHByb2Nlc3NKd2tzUmVzcG9uc2UpO1xuICAgICAgICBhZ2UgPSAwO1xuICAgICAgICBzZXRKd2tzQ2FjaGUoYXMsIGp3a3MsIGVwb2NoVGltZSgpLCBvcHRpb25zPy5bandrc0NhY2hlXSk7XG4gICAgfVxuICAgIGxldCBrdHk7XG4gICAgc3dpdGNoIChhbGcuc2xpY2UoMCwgMikpIHtcbiAgICAgICAgY2FzZSAnUlMnOlxuICAgICAgICBjYXNlICdQUyc6XG4gICAgICAgICAgICBrdHkgPSAnUlNBJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFUyc6XG4gICAgICAgICAgICBrdHkgPSAnRUMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VkJzpcbiAgICAgICAgICAgIGt0eSA9ICdPS1AnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01MJzpcbiAgICAgICAgICAgIGt0eSA9ICdBS1AnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgSldTIGFsZ29yaXRobScsIHsgY2F1c2U6IHsgYWxnIH0gfSk7XG4gICAgfVxuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBqd2tzLmtleXMuZmlsdGVyKChqd2spID0+IHtcbiAgICAgICAgaWYgKGp3ay5rdHkgIT09IGt0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChraWQgIT09IHVuZGVmaW5lZCAmJiBraWQgIT09IGp3ay5raWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLmFsZyAhPT0gdW5kZWZpbmVkICYmIGFsZyAhPT0gandrLmFsZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqd2sudXNlICE9PSB1bmRlZmluZWQgJiYgandrLnVzZSAhPT0gJ3NpZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLmtleV9vcHM/LmluY2x1ZGVzKCd2ZXJpZnknKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRVMyNTYnICYmIGp3ay5jcnYgIT09ICdQLTI1Nic6XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VTMzg0JyAmJiBqd2suY3J2ICE9PSAnUC0zODQnOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFUzUxMicgJiYgandrLmNydiAhPT0gJ1AtNTIxJzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRWQyNTUxOScgJiYgandrLmNydiAhPT0gJ0VkMjU1MTknOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFZERTQScgJiYgandrLmNydiAhPT0gJ0VkMjU1MTknOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb25zdCB7IDA6IGp3aywgbGVuZ3RoIH0gPSBjYW5kaWRhdGVzO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGlmIChhZ2UgPj0gNjApIHtcbiAgICAgICAgICAgIGNsZWFySndrc0NhY2hlKGFzLCBvcHRpb25zPy5bandrc0NhY2hlXSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgT1BFKCdlcnJvciB3aGVuIHNlbGVjdGluZyBhIEpXVCB2ZXJpZmljYXRpb24ga2V5LCBubyBhcHBsaWNhYmxlIGtleXMgZm91bmQnLCBLRVlfU0VMRUNUSU9OLCB7IGhlYWRlciwgY2FuZGlkYXRlcywgandrc191cmk6IG5ldyBVUkwoYXMuandrc191cmkpIH0pO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IE9QRSgnZXJyb3Igd2hlbiBzZWxlY3RpbmcgYSBKV1QgdmVyaWZpY2F0aW9uIGtleSwgbXVsdGlwbGUgYXBwbGljYWJsZSBrZXlzIGZvdW5kLCBhIFwia2lkXCIgSldUIEhlYWRlciBQYXJhbWV0ZXIgaXMgcmVxdWlyZWQnLCBLRVlfU0VMRUNUSU9OLCB7IGhlYWRlciwgY2FuZGlkYXRlcywgandrc191cmk6IG5ldyBVUkwoYXMuandrc191cmkpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0SndrKGFsZywgandrKTtcbn1cbmV4cG9ydCBjb25zdCBza2lwU3ViamVjdENoZWNrID0gU3ltYm9sKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGVudFR5cGUoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpPy5zcGxpdCgnOycpWzBdO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVc2VySW5mb1Jlc3BvbnNlKGFzLCBjbGllbnQsIGV4cGVjdGVkU3ViamVjdCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGNoZWNrQXV0aGVudGljYXRpb25DaGFsbGVuZ2VzKHJlc3BvbnNlKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBVc2VySW5mbyBFbmRwb2ludCByZXNwb25zZSAodW5leHBlY3RlZCBIVFRQIHN0YXR1cyBjb2RlKScsIFJFU1BPTlNFX0lTX05PVF9DT05GT1JNLCByZXNwb25zZSk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi9qd3QnKSB7XG4gICAgICAgIGNvbnN0IHsgY2xhaW1zLCBqd3QgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGF3YWl0IHJlc3BvbnNlLnRleHQoKSwgY2hlY2tTaWduaW5nQWxnb3JpdGhtLmJpbmQodW5kZWZpbmVkLCBjbGllbnQudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMudXNlcmluZm9fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCwgdW5kZWZpbmVkKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCksIG9wdGlvbnM/Lltqd2VEZWNyeXB0XSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlT3B0aW9uYWxBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZU9wdGlvbmFsSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcykpO1xuICAgICAgICBqd3RSZWZzLnNldChyZXNwb25zZSwgand0KTtcbiAgICAgICAganNvbiA9IGNsYWltcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChjbGllbnQudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCdKV1QgVXNlckluZm8gUmVzcG9uc2UgZXhwZWN0ZWQnLCBKV1RfVVNFUklORk9fRVhQRUNURUQsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBqc29uID0gYXdhaXQgZ2V0UmVzcG9uc2VKc29uQm9keShyZXNwb25zZSk7XG4gICAgfVxuICAgIGFzc2VydFN0cmluZyhqc29uLnN1YiwgJ1wicmVzcG9uc2VcIiBib2R5IFwic3ViXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7IGJvZHk6IGpzb24gfSk7XG4gICAgc3dpdGNoIChleHBlY3RlZFN1YmplY3QpIHtcbiAgICAgICAgY2FzZSBza2lwU3ViamVjdENoZWNrOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhc3NlcnRTdHJpbmcoZXhwZWN0ZWRTdWJqZWN0LCAnXCJleHBlY3RlZFN1YmplY3RcIicpO1xuICAgICAgICAgICAgaWYgKGpzb24uc3ViICE9PSBleHBlY3RlZFN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgXCJyZXNwb25zZVwiIGJvZHkgXCJzdWJcIiBwcm9wZXJ0eSB2YWx1ZScsIEpTT05fQVRUUklCVVRFX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkU3ViamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYm9keToganNvbixcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnc3ViJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgY2xpZW50QXV0aGVudGljYXRpb24oYXMsIGNsaWVudCwgYm9keSwgaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgIHJldHVybiAob3B0aW9ucz8uW2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodXJsLCBvcHRpb25zPy5zaWduYWwpLFxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIGdyYW50VHlwZSwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ3Rva2VuX2VuZHBvaW50JywgY2xpZW50LnVzZV9tdGxzX2VuZHBvaW50X2FsaWFzZXMsIG9wdGlvbnM/LlthbGxvd0luc2VjdXJlUmVxdWVzdHNdICE9PSB0cnVlKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnZ3JhbnRfdHlwZScsIGdyYW50VHlwZSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0RFBvUChvcHRpb25zLkRQb1ApO1xuICAgICAgICBhd2FpdCBvcHRpb25zLkRQb1AuYWRkUHJvb2YodXJsLCBoZWFkZXJzLCAnUE9TVCcpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCB1cmwsIHBhcmFtZXRlcnMsIGhlYWRlcnMsIG9wdGlvbnMpO1xuICAgIG9wdGlvbnM/LkRQb1A/LmNhY2hlTm9uY2UocmVzcG9uc2UsIHVybCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgcmVmcmVzaFRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGFzc2VydFN0cmluZyhyZWZyZXNoVG9rZW4sICdcInJlZnJlc2hUb2tlblwiJyk7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdyZWZyZXNoX3Rva2VuJywgcmVmcmVzaFRva2VuKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sICdyZWZyZXNoX3Rva2VuJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5jb25zdCBpZFRva2VuQ2xhaW1zID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGp3dFJlZnMgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMocmVmKSB7XG4gICAgaWYgKCFyZWYuaWRfdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY2xhaW1zID0gaWRUb2tlbkNsYWltcy5nZXQocmVmKTtcbiAgICBpZiAoIWNsYWltcykge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZWZcIiB3YXMgYWxyZWFkeSBnYXJiYWdlIGNvbGxlY3RlZCBvciBkaWQgbm90IHJlc29sdmUgZnJvbSB0aGUgcHJvcGVyIHNvdXJjZXMnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhaW1zO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQXBwbGljYXRpb25MZXZlbFNpZ25hdHVyZShhcywgcmVmLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGlmICghand0UmVmcy5oYXMocmVmKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZWZcIiBkb2VzIG5vdCBjb250YWluIGEgcHJvY2Vzc2VkIEpXVCBSZXNwb25zZSB0byB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBvZicsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxuICAgIGNvbnN0IHsgMDogcHJvdGVjdGVkSGVhZGVyLCAxOiBwYXlsb2FkLCAyOiBlbmNvZGVkU2lnbmF0dXJlIH0gPSBqd3RSZWZzLmdldChyZWYpLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgaGVhZGVyID0gSlNPTi5wYXJzZShidWYoYjY0dShwcm90ZWN0ZWRIZWFkZXIpKSk7XG4gICAgaWYgKGhlYWRlci5hbGcuc3RhcnRzV2l0aCgnSFMnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgSldTIGFsZ29yaXRobScsIHsgY2F1c2U6IHsgYWxnOiBoZWFkZXIuYWxnIH0gfSk7XG4gICAgfVxuICAgIGxldCBrZXk7XG4gICAga2V5ID0gYXdhaXQgZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcik7XG4gICAgYXdhaXQgdmFsaWRhdGVKd3NTaWduYXR1cmUocHJvdGVjdGVkSGVhZGVyLCBwYXlsb2FkLCBrZXksIGI2NHUoZW5jb2RlZFNpZ25hdHVyZSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBhZGRpdGlvbmFsUmVxdWlyZWRJZFRva2VuQ2xhaW1zLCBkZWNyeXB0Rm4sIHJlY29nbml6ZWRUb2tlblR5cGVzKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBhd2FpdCBjaGVja09BdXRoQm9keUVycm9yKHJlc3BvbnNlLCAyMDAsICdUb2tlbiBFbmRwb2ludCcpO1xuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBnZXRSZXNwb25zZUpzb25Cb2R5KHJlc3BvbnNlKTtcbiAgICBhc3NlcnRTdHJpbmcoanNvbi5hY2Nlc3NfdG9rZW4sICdcInJlc3BvbnNlXCIgYm9keSBcImFjY2Vzc190b2tlblwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICBib2R5OiBqc29uLFxuICAgIH0pO1xuICAgIGFzc2VydFN0cmluZyhqc29uLnRva2VuX3R5cGUsICdcInJlc3BvbnNlXCIgYm9keSBcInRva2VuX3R5cGVcIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keToganNvbixcbiAgICB9KTtcbiAgICBqc29uLnRva2VuX3R5cGUgPSBqc29uLnRva2VuX3R5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoanNvbi5leHBpcmVzX2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGV4cGlyZXNJbiA9IHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdChqc29uLmV4cGlyZXNfaW4pIDoganNvbi5leHBpcmVzX2luO1xuICAgICAgICBhc3NlcnROdW1iZXIoZXhwaXJlc0luLCB0cnVlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJleHBpcmVzX2luXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBib2R5OiBqc29uLFxuICAgICAgICB9KTtcbiAgICAgICAganNvbi5leHBpcmVzX2luID0gZXhwaXJlc0luO1xuICAgIH1cbiAgICBpZiAoanNvbi5yZWZyZXNoX3Rva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0U3RyaW5nKGpzb24ucmVmcmVzaF90b2tlbiwgJ1wicmVzcG9uc2VcIiBib2R5IFwicmVmcmVzaF90b2tlblwiIHByb3BlcnR5JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgYm9keToganNvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChqc29uLnNjb3BlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uc2NvcGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJzY29wZVwiIHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcnLCBJTlZBTElEX1JFU1BPTlNFLCB7IGJvZHk6IGpzb24gfSk7XG4gICAgfVxuICAgIGlmIChqc29uLmlkX3Rva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0U3RyaW5nKGpzb24uaWRfdG9rZW4sICdcInJlc3BvbnNlXCIgYm9keSBcImlkX3Rva2VuXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBib2R5OiBqc29uLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRDbGFpbXMgPSBbJ2F1ZCcsICdleHAnLCAnaWF0JywgJ2lzcycsICdzdWInXTtcbiAgICAgICAgaWYgKGNsaWVudC5yZXF1aXJlX2F1dGhfdGltZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVxdWlyZWRDbGFpbXMucHVzaCgnYXV0aF90aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudC5kZWZhdWx0X21heF9hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGNsaWVudC5kZWZhdWx0X21heF9hZ2UsIHRydWUsICdcImNsaWVudC5kZWZhdWx0X21heF9hZ2VcIicpO1xuICAgICAgICAgICAgcmVxdWlyZWRDbGFpbXMucHVzaCgnYXV0aF90aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGl0aW9uYWxSZXF1aXJlZElkVG9rZW5DbGFpbXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVxdWlyZWRDbGFpbXMucHVzaCguLi5hZGRpdGlvbmFsUmVxdWlyZWRJZFRva2VuQ2xhaW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNsYWltcywgand0IH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChqc29uLmlkX3Rva2VuLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy5pZF90b2tlbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkLCAnUlMyNTYnKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCksIGRlY3J5cHRGbilcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIHJlcXVpcmVkQ2xhaW1zKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcykpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNsYWltcy5hdWQpICYmIGNsYWltcy5hdWQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICBpZiAoY2xhaW1zLmF6cCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgT1BFKCdJRCBUb2tlbiBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gaW5jbHVkZXMgYWRkaXRpb25hbCB1bnRydXN0ZWQgYXVkaWVuY2VzJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHsgY2xhaW1zLCBjbGFpbTogJ2F1ZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xhaW1zLmF6cCAhPT0gY2xpZW50LmNsaWVudF9pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcImF6cFwiIChhdXRob3JpemVkIHBhcnR5KSBjbGFpbSB2YWx1ZScsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7IGV4cGVjdGVkOiBjbGllbnQuY2xpZW50X2lkLCBjbGFpbXMsIGNsYWltOiAnYXpwJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLmF1dGhfdGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnROdW1iZXIoY2xhaW1zLmF1dGhfdGltZSwgdHJ1ZSwgJ0lEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpJywgSU5WQUxJRF9SRVNQT05TRSwgeyBjbGFpbXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgand0UmVmcy5zZXQocmVzcG9uc2UsIGp3dCk7XG4gICAgICAgIGlkVG9rZW5DbGFpbXMuc2V0KGpzb24sIGNsYWltcyk7XG4gICAgfVxuICAgIGlmIChyZWNvZ25pemVkVG9rZW5UeXBlcz8uW2pzb24udG9rZW5fdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWNvZ25pemVkVG9rZW5UeXBlc1tqc29uLnRva2VuX3R5cGVdKHJlc3BvbnNlLCBqc29uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoanNvbi50b2tlbl90eXBlICE9PSAnZHBvcCcgJiYganNvbi50b2tlbl90eXBlICE9PSAnYmVhcmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgYHRva2VuX3R5cGVgIHZhbHVlJywgeyBjYXVzZTogeyBib2R5OiBqc29uIH0gfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZnVuY3Rpb24gY2hlY2tBdXRoZW50aWNhdGlvbkNoYWxsZW5nZXMocmVzcG9uc2UpIHtcbiAgICBsZXQgY2hhbGxlbmdlcztcbiAgICBpZiAoKGNoYWxsZW5nZXMgPSBwYXJzZVd3d0F1dGhlbnRpY2F0ZUNoYWxsZW5nZXMocmVzcG9uc2UpKSkge1xuICAgICAgICB0aHJvdyBuZXcgV1dXQXV0aGVudGljYXRlQ2hhbGxlbmdlRXJyb3IoJ3NlcnZlciByZXNwb25kZWQgd2l0aCBhIGNoYWxsZW5nZSBpbiB0aGUgV1dXLUF1dGhlbnRpY2F0ZSBIVFRQIEhlYWRlcicsIHsgY2F1c2U6IGNoYWxsZW5nZXMsIHJlc3BvbnNlIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUmVmcmVzaFRva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCB1bmRlZmluZWQsIG9wdGlvbnM/Lltqd2VEZWNyeXB0XSwgb3B0aW9ucz8ucmVjb2duaXplZFRva2VuVHlwZXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmNsYWltcy5hdWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVBdWRpZW5jZShleHBlY3RlZCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXVkaWVuY2UoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdC5jbGFpbXMuYXVkKSkge1xuICAgICAgICBpZiAoIXJlc3VsdC5jbGFpbXMuYXVkLmluY2x1ZGVzKGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gdmFsdWUnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIGNsYWltczogcmVzdWx0LmNsYWltcyxcbiAgICAgICAgICAgICAgICBjbGFpbTogJ2F1ZCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQuY2xhaW1zLmF1ZCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gdmFsdWUnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwge1xuICAgICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgICBjbGFpbXM6IHJlc3VsdC5jbGFpbXMsXG4gICAgICAgICAgICBjbGFpbTogJ2F1ZCcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbElzc3VlcihhcywgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5jbGFpbXMuaXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlSXNzdWVyKGFzLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJc3N1ZXIoYXMsIHJlc3VsdCkge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gYXNbX2V4cGVjdGVkSXNzdWVyXT8uKHJlc3VsdCkgPz8gYXMuaXNzdWVyO1xuICAgIGlmIChyZXN1bHQuY2xhaW1zLmlzcyAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlzc1wiIChpc3N1ZXIpIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgY2xhaW1zOiByZXN1bHQuY2xhaW1zLFxuICAgICAgICAgICAgY2xhaW06ICdpc3MnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGJyYW5kZWQgPSBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gYnJhbmQoc2VhcmNoUGFyYW1zKSB7XG4gICAgYnJhbmRlZC5hZGQoc2VhcmNoUGFyYW1zKTtcbiAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuZXhwb3J0IGNvbnN0IG5vcGtjZSA9IFN5bWJvbCgpO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCBjYWxsYmFja1BhcmFtZXRlcnMsIHJlZGlyZWN0VXJpLCBjb2RlVmVyaWZpZXIsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFicmFuZGVkLmhhcyhjYWxsYmFja1BhcmFtZXRlcnMpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImNhbGxiYWNrUGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zIG9idGFpbmVkIGZyb20gXCJ2YWxpZGF0ZUF1dGhSZXNwb25zZSgpXCIsIG9yIFwidmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UoKScsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxuICAgIGFzc2VydFN0cmluZyhyZWRpcmVjdFVyaSwgJ1wicmVkaXJlY3RVcmlcIicpO1xuICAgIGNvbnN0IGNvZGUgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIoY2FsbGJhY2tQYXJhbWV0ZXJzLCAnY29kZScpO1xuICAgIGlmICghY29kZSkge1xuICAgICAgICB0aHJvdyBPUEUoJ25vIGF1dGhvcml6YXRpb24gY29kZSBpbiBcImNhbGxiYWNrUGFyYW1ldGVyc1wiJywgSU5WQUxJRF9SRVNQT05TRSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgncmVkaXJlY3RfdXJpJywgcmVkaXJlY3RVcmkpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdjb2RlJywgY29kZSk7XG4gICAgaWYgKGNvZGVWZXJpZmllciAhPT0gbm9wa2NlKSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhjb2RlVmVyaWZpZXIsICdcImNvZGVWZXJpZmllclwiJyk7XG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KCdjb2RlX3ZlcmlmaWVyJywgY29kZVZlcmlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCAnYXV0aG9yaXphdGlvbl9jb2RlJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5jb25zdCBqd3RDbGFpbU5hbWVzID0ge1xuICAgIGF1ZDogJ2F1ZGllbmNlJyxcbiAgICBjX2hhc2g6ICdjb2RlIGhhc2gnLFxuICAgIGNsaWVudF9pZDogJ2NsaWVudCBpZCcsXG4gICAgZXhwOiAnZXhwaXJhdGlvbiB0aW1lJyxcbiAgICBpYXQ6ICdpc3N1ZWQgYXQnLFxuICAgIGlzczogJ2lzc3VlcicsXG4gICAganRpOiAnand0IGlkJyxcbiAgICBub25jZTogJ25vbmNlJyxcbiAgICBzX2hhc2g6ICdzdGF0ZSBoYXNoJyxcbiAgICBzdWI6ICdzdWJqZWN0JyxcbiAgICBhdGg6ICdhY2Nlc3MgdG9rZW4gaGFzaCcsXG4gICAgaHRtOiAnaHR0cCBtZXRob2QnLFxuICAgIGh0dTogJ2h0dHAgdXJpJyxcbiAgICBjbmY6ICdjb25maXJtYXRpb24nLFxuICAgIGF1dGhfdGltZTogJ2F1dGhlbnRpY2F0aW9uIHRpbWUnLFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJlc2VuY2UocmVxdWlyZWQsIHJlc3VsdCkge1xuICAgIGZvciAoY29uc3QgY2xhaW0gb2YgcmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5jbGFpbXNbY2xhaW1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IE9QRShgSldUIFwiJHtjbGFpbX1cIiAoJHtqd3RDbGFpbU5hbWVzW2NsYWltXX0pIGNsYWltIG1pc3NpbmdgLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICAgICAgY2xhaW1zOiByZXN1bHQuY2xhaW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCBleHBlY3ROb05vbmNlID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3Qgc2tpcEF1dGhUaW1lQ2hlY2sgPSBTeW1ib2woKTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucz8uZXhwZWN0ZWROb25jZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIG9wdGlvbnM/Lm1heEFnZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgb3B0aW9ucz8ucmVxdWlyZUlkVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9wZW5JRFJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBvcHRpb25zLmV4cGVjdGVkTm9uY2UsIG9wdGlvbnMubWF4QWdlLCBvcHRpb25zW2p3ZURlY3J5cHRdLCBvcHRpb25zLnJlY29nbml6ZWRUb2tlblR5cGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9BdXRoMlJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBvcHRpb25zPy5bandlRGVjcnlwdF0sIG9wdGlvbnM/LnJlY29nbml6ZWRUb2tlblR5cGVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9wZW5JRFJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBleHBlY3RlZE5vbmNlLCBtYXhBZ2UsIGRlY3J5cHRGbiwgcmVjb2duaXplZFRva2VuVHlwZXMpIHtcbiAgICBjb25zdCBhZGRpdGlvbmFsUmVxdWlyZWRDbGFpbXMgPSBbXTtcbiAgICBzd2l0Y2ggKGV4cGVjdGVkTm9uY2UpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBleHBlY3RlZE5vbmNlID0gZXhwZWN0Tm9Ob25jZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV4cGVjdE5vTm9uY2U6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFzc2VydFN0cmluZyhleHBlY3RlZE5vbmNlLCAnXCJleHBlY3RlZE5vbmNlXCIgYXJndW1lbnQnKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxSZXF1aXJlZENsYWltcy5wdXNoKCdub25jZScpO1xuICAgIH1cbiAgICBtYXhBZ2UgPz89IGNsaWVudC5kZWZhdWx0X21heF9hZ2U7XG4gICAgc3dpdGNoIChtYXhBZ2UpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBtYXhBZ2UgPSBza2lwQXV0aFRpbWVDaGVjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNraXBBdXRoVGltZUNoZWNrOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhc3NlcnROdW1iZXIobWF4QWdlLCB0cnVlLCAnXCJtYXhBZ2VcIiBhcmd1bWVudCcpO1xuICAgICAgICAgICAgYWRkaXRpb25hbFJlcXVpcmVkQ2xhaW1zLnB1c2goJ2F1dGhfdGltZScpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIGFkZGl0aW9uYWxSZXF1aXJlZENsYWltcywgZGVjcnlwdEZuLCByZWNvZ25pemVkVG9rZW5UeXBlcyk7XG4gICAgYXNzZXJ0U3RyaW5nKHJlc3VsdC5pZF90b2tlbiwgJ1wicmVzcG9uc2VcIiBib2R5IFwiaWRfdG9rZW5cIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keTogcmVzdWx0LFxuICAgIH0pO1xuICAgIGNvbnN0IGNsYWltcyA9IGdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMocmVzdWx0KTtcbiAgICBpZiAobWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykge1xuICAgICAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpO1xuICAgICAgICBpZiAoY2xhaW1zLmF1dGhfdGltZSArIG1heEFnZSA8IG5vdyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd0b28gbXVjaCB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IEVuZC1Vc2VyIGF1dGhlbnRpY2F0aW9uJywgSldUX1RJTUVTVEFNUF9DSEVDSywgeyBjbGFpbXMsIG5vdywgdG9sZXJhbmNlLCBjbGFpbTogJ2F1dGhfdGltZScgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cGVjdGVkTm9uY2UgPT09IGV4cGVjdE5vTm9uY2UpIHtcbiAgICAgICAgaWYgKGNsYWltcy5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNsYWltcyxcbiAgICAgICAgICAgICAgICBjbGFpbTogJ25vbmNlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNsYWltcy5ub25jZSAhPT0gZXhwZWN0ZWROb25jZSkge1xuICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZE5vbmNlLFxuICAgICAgICAgICAgY2xhaW1zLFxuICAgICAgICAgICAgY2xhaW06ICdub25jZScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT0F1dGgyUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIGRlY3J5cHRGbiwgcmVjb2duaXplZFRva2VuVHlwZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHVuZGVmaW5lZCwgZGVjcnlwdEZuLCByZWNvZ25pemVkVG9rZW5UeXBlcyk7XG4gICAgY29uc3QgY2xhaW1zID0gZ2V0VmFsaWRhdGVkSWRUb2tlbkNsYWltcyhyZXN1bHQpO1xuICAgIGlmIChjbGFpbXMpIHtcbiAgICAgICAgaWYgKGNsaWVudC5kZWZhdWx0X21heF9hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGNsaWVudC5kZWZhdWx0X21heF9hZ2UsIHRydWUsICdcImNsaWVudC5kZWZhdWx0X21heF9hZ2VcIicpO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCk7XG4gICAgICAgICAgICBpZiAoY2xhaW1zLmF1dGhfdGltZSArIGNsaWVudC5kZWZhdWx0X21heF9hZ2UgPCBub3cgLSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPUEUoJ3RvbyBtdWNoIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgRW5kLVVzZXIgYXV0aGVudGljYXRpb24nLCBKV1RfVElNRVNUQU1QX0NIRUNLLCB7IGNsYWltcywgbm93LCB0b2xlcmFuY2UsIGNsYWltOiAnYXV0aF90aW1lJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLm5vbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gdmFsdWUnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY2xhaW1zLFxuICAgICAgICAgICAgICAgIGNsYWltOiAnbm9uY2UnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCBXV1dfQVVUSEVOVElDQVRFX0NIQUxMRU5HRSA9ICdPQVVUSF9XV1dfQVVUSEVOVElDQVRFX0NIQUxMRU5HRSc7XG5leHBvcnQgY29uc3QgUkVTUE9OU0VfQk9EWV9FUlJPUiA9ICdPQVVUSF9SRVNQT05TRV9CT0RZX0VSUk9SJztcbmV4cG9ydCBjb25zdCBVTlNVUFBPUlRFRF9PUEVSQVRJT04gPSAnT0FVVEhfVU5TVVBQT1JURURfT1BFUkFUSU9OJztcbmV4cG9ydCBjb25zdCBBVVRIT1JJWkFUSU9OX1JFU1BPTlNFX0VSUk9SID0gJ09BVVRIX0FVVEhPUklaQVRJT05fUkVTUE9OU0VfRVJST1InO1xuZXhwb3J0IGNvbnN0IEpXVF9VU0VSSU5GT19FWFBFQ1RFRCA9ICdPQVVUSF9KV1RfVVNFUklORk9fRVhQRUNURUQnO1xuZXhwb3J0IGNvbnN0IFBBUlNFX0VSUk9SID0gJ09BVVRIX1BBUlNFX0VSUk9SJztcbmV4cG9ydCBjb25zdCBJTlZBTElEX1JFU1BPTlNFID0gJ09BVVRIX0lOVkFMSURfUkVTUE9OU0UnO1xuZXhwb3J0IGNvbnN0IElOVkFMSURfUkVRVUVTVCA9ICdPQVVUSF9JTlZBTElEX1JFUVVFU1QnO1xuZXhwb3J0IGNvbnN0IFJFU1BPTlNFX0lTX05PVF9KU09OID0gJ09BVVRIX1JFU1BPTlNFX0lTX05PVF9KU09OJztcbmV4cG9ydCBjb25zdCBSRVNQT05TRV9JU19OT1RfQ09ORk9STSA9ICdPQVVUSF9SRVNQT05TRV9JU19OT1RfQ09ORk9STSc7XG5leHBvcnQgY29uc3QgSFRUUF9SRVFVRVNUX0ZPUkJJRERFTiA9ICdPQVVUSF9IVFRQX1JFUVVFU1RfRk9SQklEREVOJztcbmV4cG9ydCBjb25zdCBSRVFVRVNUX1BST1RPQ09MX0ZPUkJJRERFTiA9ICdPQVVUSF9SRVFVRVNUX1BST1RPQ09MX0ZPUkJJRERFTic7XG5leHBvcnQgY29uc3QgSldUX1RJTUVTVEFNUF9DSEVDSyA9ICdPQVVUSF9KV1RfVElNRVNUQU1QX0NIRUNLX0ZBSUxFRCc7XG5leHBvcnQgY29uc3QgSldUX0NMQUlNX0NPTVBBUklTT04gPSAnT0FVVEhfSldUX0NMQUlNX0NPTVBBUklTT05fRkFJTEVEJztcbmV4cG9ydCBjb25zdCBKU09OX0FUVFJJQlVURV9DT01QQVJJU09OID0gJ09BVVRIX0pTT05fQVRUUklCVVRFX0NPTVBBUklTT05fRkFJTEVEJztcbmV4cG9ydCBjb25zdCBLRVlfU0VMRUNUSU9OID0gJ09BVVRIX0tFWV9TRUxFQ1RJT05fRkFJTEVEJztcbmV4cG9ydCBjb25zdCBNSVNTSU5HX1NFUlZFUl9NRVRBREFUQSA9ICdPQVVUSF9NSVNTSU5HX1NFUlZFUl9NRVRBREFUQSc7XG5leHBvcnQgY29uc3QgSU5WQUxJRF9TRVJWRVJfTUVUQURBVEEgPSAnT0FVVEhfSU5WQUxJRF9TRVJWRVJfTUVUQURBVEEnO1xuZnVuY3Rpb24gY2hlY2tKd3RUeXBlKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAodHlwZW9mIHJlc3VsdC5oZWFkZXIudHlwICE9PSAnc3RyaW5nJyB8fCBub3JtYWxpemVUeXAocmVzdWx0LmhlYWRlci50eXApICE9PSBleHBlY3RlZCkge1xuICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwidHlwXCIgaGVhZGVyIHBhcmFtZXRlciB2YWx1ZScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgIGhlYWRlcjogcmVzdWx0LmhlYWRlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xpZW50Q3JlZGVudGlhbHNHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCAnY2xpZW50X2NyZWRlbnRpYWxzJywgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKSwgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJpY1Rva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCBncmFudFR5cGUsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgYXNzZXJ0U3RyaW5nKGdyYW50VHlwZSwgJ1wiZ3JhbnRUeXBlXCInKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIGdyYW50VHlwZSwgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKSwgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0dlbmVyaWNUb2tlbkVuZHBvaW50UmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCB1bmRlZmluZWQsIG9wdGlvbnM/Lltqd2VEZWNyeXB0XSwgb3B0aW9ucz8ucmVjb2duaXplZFRva2VuVHlwZXMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDbGllbnRDcmVkZW50aWFsc1Jlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgdW5kZWZpbmVkLCBvcHRpb25zPy5bandlRGVjcnlwdF0sIG9wdGlvbnM/LnJlY29nbml6ZWRUb2tlblR5cGVzKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXZvY2F0aW9uUmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgdG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgYXNzZXJ0U3RyaW5nKHRva2VuLCAnXCJ0b2tlblwiJyk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAncmV2b2NhdGlvbl9lbmRwb2ludCcsIGNsaWVudC51c2VfbXRsc19lbmRwb2ludF9hbGlhc2VzLCBvcHRpb25zPy5bYWxsb3dJbnNlY3VyZVJlcXVlc3RzXSAhPT0gdHJ1ZSk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCd0b2tlbicsIHRva2VuKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5kZWxldGUoJ2FjY2VwdCcpO1xuICAgIHJldHVybiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGF3YWl0IGNoZWNrT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UsIDIwMCwgJ1Jldm9jYXRpb24gRW5kcG9pbnQnKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIGJvZHkgaGFzIGJlZW4gdXNlZCBhbHJlYWR5JywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW50cm9zcGVjdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGFzc2VydFN0cmluZyh0b2tlbiwgJ1widG9rZW5cIicpO1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVFbmRwb2ludChhcywgJ2ludHJvc3BlY3Rpb25fZW5kcG9pbnQnLCBjbGllbnQudXNlX210bHNfZW5kcG9pbnRfYWxpYXNlcywgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgndG9rZW4nLCB0b2tlbik7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGlmIChvcHRpb25zPy5yZXF1ZXN0Snd0UmVzcG9uc2UgPz8gY2xpZW50LmludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL3Rva2VuLWludHJvc3BlY3Rpb24rand0Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJbnRyb3NwZWN0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGF3YWl0IGNoZWNrT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UsIDIwMCwgJ0ludHJvc3BlY3Rpb24gRW5kcG9pbnQnKTtcbiAgICBsZXQganNvbjtcbiAgICBpZiAoZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpID09PSAnYXBwbGljYXRpb24vdG9rZW4taW50cm9zcGVjdGlvbitqd3QnKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBjb25zdCB7IGNsYWltcywgand0IH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChhd2FpdCByZXNwb25zZS50ZXh0KCksIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaW50cm9zcGVjdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkLCAnUlMyNTYnKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCksIG9wdGlvbnM/Lltqd2VEZWNyeXB0XSlcbiAgICAgICAgICAgIC50aGVuKGNoZWNrSnd0VHlwZS5iaW5kKHVuZGVmaW5lZCwgJ3Rva2VuLWludHJvc3BlY3Rpb24rand0JykpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBbJ2F1ZCcsICdpYXQnLCAnaXNzJ10pKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICAgICAgand0UmVmcy5zZXQocmVzcG9uc2UsIGp3dCk7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcy50b2tlbl9pbnRyb3NwZWN0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCdKV1QgXCJ0b2tlbl9pbnRyb3NwZWN0aW9uXCIgY2xhaW0gbXVzdCBiZSBhIEpTT04gb2JqZWN0JywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgICAgIGNsYWltcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGpzb24gPSBjbGFpbXMudG9rZW5faW50cm9zcGVjdGlvbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBqc29uID0gYXdhaXQgZ2V0UmVzcG9uc2VKc29uQm9keShyZXNwb25zZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbi5hY3RpdmUgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiYWN0aXZlXCIgcHJvcGVydHkgbXVzdCBiZSBhIGJvb2xlYW4nLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBib2R5OiBqc29uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBqd2tzUmVxdWVzdChhcywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdqd2tzX3VyaScsIGZhbHNlLCBvcHRpb25zPy5bYWxsb3dJbnNlY3VyZVJlcXVlc3RzXSAhPT0gdHJ1ZSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGhlYWRlcnMuYXBwZW5kKCdhY2NlcHQnLCAnYXBwbGljYXRpb24vandrLXNldCtqc29uJyk7XG4gICAgcmV0dXJuIChvcHRpb25zPy5bY3VzdG9tRmV0Y2hdIHx8IGZldGNoKSh1cmwuaHJlZiwge1xuICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSksXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodXJsLCBvcHRpb25zPy5zaWduYWwpLFxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0p3a3NSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmICghbG9vc2VJbnN0YW5jZU9mKHJlc3BvbnNlLCBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBKU09OIFdlYiBLZXkgU2V0IHJlc3BvbnNlICh1bmV4cGVjdGVkIEhUVFAgc3RhdHVzIGNvZGUpJywgUkVTUE9OU0VfSVNfTk9UX0NPTkZPUk0sIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGdldFJlc3BvbnNlSnNvbkJvZHkocmVzcG9uc2UsIChyZXNwb25zZSkgPT4gYXNzZXJ0Q29udGVudFR5cGVzKHJlc3BvbnNlLCAnYXBwbGljYXRpb24vanNvbicsICdhcHBsaWNhdGlvbi9qd2stc2V0K2pzb24nKSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ua2V5cykpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImtleXNcIiBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5JywgSU5WQUxJRF9SRVNQT05TRSwgeyBib2R5OiBqc29uIH0pO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LnByb3RvdHlwZS5ldmVyeS5jYWxsKGpzb24ua2V5cywgaXNKc29uT2JqZWN0KSkge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwia2V5c1wiIHByb3BlcnR5IG1lbWJlcnMgbXVzdCBiZSBKV0sgZm9ybWF0dGVkIG9iamVjdHMnLCBJTlZBTElEX1JFU1BPTlNFLCB7IGJvZHk6IGpzb24gfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZnVuY3Rpb24gc3VwcG9ydGVkKGFsZykge1xuICAgIHN3aXRjaCAoYWxnKSB7XG4gICAgICAgIGNhc2UgJ1BTMjU2JzpcbiAgICAgICAgY2FzZSAnRVMyNTYnOlxuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgIGNhc2UgJ1BTMzg0JzpcbiAgICAgICAgY2FzZSAnRVMzODQnOlxuICAgICAgICBjYXNlICdSUzM4NCc6XG4gICAgICAgIGNhc2UgJ1BTNTEyJzpcbiAgICAgICAgY2FzZSAnRVM1MTInOlxuICAgICAgICBjYXNlICdSUzUxMic6XG4gICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICBjYXNlICdFZERTQSc6XG4gICAgICAgIGNhc2UgJ01MLURTQS00NCc6XG4gICAgICAgIGNhc2UgJ01MLURTQS02NSc6XG4gICAgICAgIGNhc2UgJ01MLURTQS04Nyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1N1cHBvcnRlZEp3c0FsZyhoZWFkZXIpIHtcbiAgICBpZiAoIXN1cHBvcnRlZChoZWFkZXIuYWxnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgSldTIFwiYWxnXCIgaWRlbnRpZmllcicsIHtcbiAgICAgICAgICAgIGNhdXNlOiB7IGFsZzogaGVhZGVyLmFsZyB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1JzYUtleUFsZ29yaXRobShrZXkpIHtcbiAgICBjb25zdCB7IGFsZ29yaXRobSB9ID0ga2V5O1xuICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggIT09ICdudW1iZXInIHx8IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoIDwgMjA0OCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihgdW5zdXBwb3J0ZWQgJHthbGdvcml0aG0ubmFtZX0gbW9kdWx1c0xlbmd0aGAsIHtcbiAgICAgICAgICAgIGNhdXNlOiBrZXksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVjZHNhSGFzaE5hbWUoa2V5KSB7XG4gICAgY29uc3QgeyBhbGdvcml0aG0gfSA9IGtleTtcbiAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lZEN1cnZlKSB7XG4gICAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTI1Nic7XG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTM4NCc7XG4gICAgICAgIGNhc2UgJ1AtNTIxJzpcbiAgICAgICAgICAgIHJldHVybiAnU0hBLTUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgRUNEU0EgbmFtZWRDdXJ2ZScsIHsgY2F1c2U6IGtleSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXlUb1N1YnRsZShrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubmFtZSkge1xuICAgICAgICBjYXNlICdFQ0RTQSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGtleS5hbGdvcml0aG0ubmFtZSxcbiAgICAgICAgICAgICAgICBoYXNoOiBlY2RzYUhhc2hOYW1lKGtleSksXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdSU0EtUFNTJzoge1xuICAgICAgICAgICAgY2hlY2tSc2FLZXlBbGdvcml0aG0oa2V5KTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMjU2JzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMzg0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtNTEyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleS5hbGdvcml0aG0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbHRMZW5ndGg6IHBhcnNlSW50KGtleS5hbGdvcml0aG0uaGFzaC5uYW1lLnNsaWNlKC0zKSwgMTApID4+IDMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIFJTQS1QU1MgaGFzaCBuYW1lJywgeyBjYXVzZToga2V5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcbiAgICAgICAgICAgIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGtleSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5LmFsZ29yaXRobS5uYW1lO1xuICAgICAgICBjYXNlICdNTC1EU0EtNDQnOlxuICAgICAgICBjYXNlICdNTC1EU0EtNjUnOlxuICAgICAgICBjYXNlICdNTC1EU0EtODcnOlxuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgICAgIHJldHVybiBrZXkuYWxnb3JpdGhtLm5hbWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBDcnlwdG9LZXkgYWxnb3JpdGhtIG5hbWUnLCB7IGNhdXNlOiBrZXkgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUp3c1NpZ25hdHVyZShwcm90ZWN0ZWRIZWFkZXIsIHBheWxvYWQsIGtleSwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZihgJHtwcm90ZWN0ZWRIZWFkZXJ9LiR7cGF5bG9hZH1gKTtcbiAgICBjb25zdCBhbGdvcml0aG0gPSBrZXlUb1N1YnRsZShrZXkpO1xuICAgIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSk7XG4gICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICB0aHJvdyBPUEUoJ0pXVCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICBhbGdvcml0aG0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSnd0KGp3cywgY2hlY2tBbGcsIGNsb2NrU2tldywgY2xvY2tUb2xlcmFuY2UsIGRlY3J5cHRKd3QpIHtcbiAgICBsZXQgeyAwOiBwcm90ZWN0ZWRIZWFkZXIsIDE6IHBheWxvYWQsIGxlbmd0aCB9ID0gandzLnNwbGl0KCcuJyk7XG4gICAgaWYgKGxlbmd0aCA9PT0gNSkge1xuICAgICAgICBpZiAoZGVjcnlwdEp3dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBqd3MgPSBhd2FpdCBkZWNyeXB0Snd0KGp3cyk7XG4gICAgICAgICAgICAoeyAwOiBwcm90ZWN0ZWRIZWFkZXIsIDE6IHBheWxvYWQsIGxlbmd0aCB9ID0gandzLnNwbGl0KCcuJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ0pXRSBkZWNyeXB0aW9uIGlzIG5vdCBjb25maWd1cmVkJywgeyBjYXVzZTogandzIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdJbnZhbGlkIEpXVCcsIElOVkFMSURfUkVTUE9OU0UsIGp3cyk7XG4gICAgfVxuICAgIGxldCBoZWFkZXI7XG4gICAgdHJ5IHtcbiAgICAgICAgaGVhZGVyID0gSlNPTi5wYXJzZShidWYoYjY0dShwcm90ZWN0ZWRIZWFkZXIpKSk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBKV1QgSGVhZGVyIGJvZHkgYXMgYmFzZTY0dXJsIGVuY29kZWQgSlNPTicsIFBBUlNFX0VSUk9SLCBjYXVzZSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGhlYWRlcikpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdKV1QgSGVhZGVyIG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0JywgSU5WQUxJRF9SRVNQT05TRSwgandzKTtcbiAgICB9XG4gICAgY2hlY2tBbGcoaGVhZGVyKTtcbiAgICBpZiAoaGVhZGVyLmNyaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcignbm8gSldUIFwiY3JpdFwiIGhlYWRlciBwYXJhbWV0ZXIgZXh0ZW5zaW9ucyBhcmUgc3VwcG9ydGVkJywge1xuICAgICAgICAgICAgY2F1c2U6IHsgaGVhZGVyIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgY2xhaW1zO1xuICAgIHRyeSB7XG4gICAgICAgIGNsYWltcyA9IEpTT04ucGFyc2UoYnVmKGI2NHUocGF5bG9hZCkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IE9QRSgnZmFpbGVkIHRvIHBhcnNlIEpXVCBQYXlsb2FkIGJvZHkgYXMgYmFzZTY0dXJsIGVuY29kZWQgSlNPTicsIFBBUlNFX0VSUk9SLCBjYXVzZSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcykpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdKV1QgUGF5bG9hZCBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcsIElOVkFMSURfUkVTUE9OU0UsIGp3cyk7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGlmIChjbGFpbXMuZXhwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuZXhwICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImV4cFwiIChleHBpcmF0aW9uIHRpbWUpIGNsYWltIHR5cGUnLCBJTlZBTElEX1JFU1BPTlNFLCB7IGNsYWltcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLmV4cCA8PSBub3cgLSBjbG9ja1RvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImV4cFwiIChleHBpcmF0aW9uIHRpbWUpIGNsYWltIHZhbHVlLCBleHBpcmF0aW9uIGlzIHBhc3QgY3VycmVudCB0aW1lc3RhbXAnLCBKV1RfVElNRVNUQU1QX0NIRUNLLCB7IGNsYWltcywgbm93LCB0b2xlcmFuY2U6IGNsb2NrVG9sZXJhbmNlLCBjbGFpbTogJ2V4cCcgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5pYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5pYXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiaWF0XCIgKGlzc3VlZCBhdCkgY2xhaW0gdHlwZScsIElOVkFMSURfUkVTUE9OU0UsIHsgY2xhaW1zIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuaXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuaXNzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlzc1wiIChpc3N1ZXIpIGNsYWltIHR5cGUnLCBJTlZBTElEX1JFU1BPTlNFLCB7IGNsYWltcyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLm5iZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLm5iZiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJuYmZcIiAobm90IGJlZm9yZSkgY2xhaW0gdHlwZScsIElOVkFMSURfUkVTUE9OU0UsIHsgY2xhaW1zIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMubmJmID4gbm93ICsgY2xvY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJuYmZcIiAobm90IGJlZm9yZSkgY2xhaW0gdmFsdWUnLCBKV1RfVElNRVNUQU1QX0NIRUNLLCB7XG4gICAgICAgICAgICAgICAgY2xhaW1zLFxuICAgICAgICAgICAgICAgIG5vdyxcbiAgICAgICAgICAgICAgICB0b2xlcmFuY2U6IGNsb2NrVG9sZXJhbmNlLFxuICAgICAgICAgICAgICAgIGNsYWltOiAnbmJmJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuYXVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuYXVkICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gdHlwZScsIElOVkFMSURfUkVTUE9OU0UsIHsgY2xhaW1zIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGhlYWRlciwgY2xhaW1zLCBqd3Q6IGp3cyB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkU3RhdGUsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBpZiAoIShwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMsIG9yIFVSTCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3Jlc3BvbnNlJyk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicGFyYW1ldGVyc1wiIGRvZXMgbm90IGNvbnRhaW4gYSBKQVJNIHJlc3BvbnNlJywgSU5WQUxJRF9SRVNQT05TRSk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2xhaW1zLCBoZWFkZXIsIGp3dCB9ID0gYXdhaXQgdmFsaWRhdGVKd3QocmVzcG9uc2UsIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmF1dGhvcml6YXRpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuYXV0aG9yaXphdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkLCAnUlMyNTYnKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCksIG9wdGlvbnM/Lltqd2VEZWNyeXB0XSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnZXhwJywgJ2lzcyddKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVJc3N1ZXIuYmluZCh1bmRlZmluZWQsIGFzKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgIGNvbnN0IHsgMDogcHJvdGVjdGVkSGVhZGVyLCAxOiBwYXlsb2FkLCAyOiBlbmNvZGVkU2lnbmF0dXJlIH0gPSBqd3Quc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGVuY29kZWRTaWduYXR1cmUpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgIGF3YWl0IHZhbGlkYXRlSndzU2lnbmF0dXJlKHByb3RlY3RlZEhlYWRlciwgcGF5bG9hZCwga2V5LCBzaWduYXR1cmUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjbGFpbXMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGtleSAhPT0gJ2F1ZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlQXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3VsdCwgZXhwZWN0ZWRTdGF0ZSk7XG59XG5hc3luYyBmdW5jdGlvbiBpZFRva2VuSGFzaChkYXRhLCBoZWFkZXIsIGNsYWltTmFtZSkge1xuICAgIGxldCBhbGdvcml0aG07XG4gICAgc3dpdGNoIChoZWFkZXIuYWxnKSB7XG4gICAgICAgIGNhc2UgJ1JTMjU2JzpcbiAgICAgICAgY2FzZSAnUFMyNTYnOlxuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgICAgICBhbGdvcml0aG0gPSAnU0hBLTI1Nic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUlMzODQnOlxuICAgICAgICBjYXNlICdQUzM4NCc6XG4gICAgICAgIGNhc2UgJ0VTMzg0JzpcbiAgICAgICAgICAgIGFsZ29yaXRobSA9ICdTSEEtMzg0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSUzUxMic6XG4gICAgICAgIGNhc2UgJ1BTNTEyJzpcbiAgICAgICAgY2FzZSAnRVM1MTInOlxuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgY2FzZSAnRWREU0EnOlxuICAgICAgICAgICAgYWxnb3JpdGhtID0gJ1NIQS01MTInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01MLURTQS00NCc6XG4gICAgICAgIGNhc2UgJ01MLURTQS02NSc6XG4gICAgICAgIGNhc2UgJ01MLURTQS04Nyc6XG4gICAgICAgICAgICBhbGdvcml0aG0gPSB7IG5hbWU6ICdjU0hBS0UyNTYnLCBsZW5ndGg6IDUxMiB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihgdW5zdXBwb3J0ZWQgSldTIGFsZ29yaXRobSBmb3IgJHtjbGFpbU5hbWV9IGNhbGN1bGF0aW9uYCwgeyBjYXVzZTogeyBhbGc6IGhlYWRlci5hbGcgfSB9KTtcbiAgICB9XG4gICAgY29uc3QgZGlnZXN0ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoYWxnb3JpdGhtLCBidWYoZGF0YSkpO1xuICAgIHJldHVybiBiNjR1KGRpZ2VzdC5zbGljZSgwLCBkaWdlc3QuYnl0ZUxlbmd0aCAvIDIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlkVG9rZW5IYXNoTWF0Y2hlcyhkYXRhLCBhY3R1YWwsIGhlYWRlciwgY2xhaW1OYW1lKSB7XG4gICAgY29uc3QgZXhwZWN0ZWQgPSBhd2FpdCBpZFRva2VuSGFzaChkYXRhLCBoZWFkZXIsIGNsYWltTmFtZSk7XG4gICAgcmV0dXJuIGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVEZXRhY2hlZFNpZ25hdHVyZVJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB2YWxpZGF0ZUh5YnJpZFJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSwgb3B0aW9ucywgdHJ1ZSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVDb2RlSWRUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB2YWxpZGF0ZUh5YnJpZFJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSwgb3B0aW9ucywgZmFsc2UpO1xufVxuYXN5bmMgZnVuY3Rpb24gY29uc3VtZVN0cmVhbShyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ2Zvcm1fcG9zdCBSZXF1ZXN0IGluc3RhbmNlcyBtdXN0IGNvbnRhaW4gYSByZWFkYWJsZSBib2R5JywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCB7IGNhdXNlOiByZXF1ZXN0IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdC50ZXh0KCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZm9ybVBvc3RSZXNwb25zZShyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnUE9TVCcpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ2Zvcm1fcG9zdCByZXNwb25zZXMgYXJlIGV4cGVjdGVkIHRvIHVzZSB0aGUgUE9TVCBtZXRob2QnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIHsgY2F1c2U6IHJlcXVlc3QgfSk7XG4gICAgfVxuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXF1ZXN0KSAhPT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ2Zvcm1fcG9zdCByZXNwb25zZXMgYXJlIGV4cGVjdGVkIHRvIHVzZSB0aGUgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIGNvbnRlbnQtdHlwZScsIEVSUl9JTlZBTElEX0FSR19WQUxVRSwgeyBjYXVzZTogcmVxdWVzdCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN1bWVTdHJlYW0ocmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUh5YnJpZFJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSwgb3B0aW9ucywgZmFwaSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBpZiAoIXBhcmFtZXRlcnMuaGFzaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInBhcmFtZXRlcnNcIiBhcyBhbiBpbnN0YW5jZSBvZiBVUkwgbXVzdCBjb250YWluIGEgaGFzaCAoZnJhZ21lbnQpIHdpdGggdGhlIEF1dGhvcml6YXRpb24gUmVzcG9uc2UgcGFyYW1ldGVycycsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycy5oYXNoLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9vc2VJbnN0YW5jZU9mKHBhcmFtZXRlcnMsIFJlcXVlc3QpKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGF3YWl0IGZvcm1Qb3N0UmVzcG9uc2UocGFyYW1ldGVycykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zLCBVUkwsIG9yIFJlc3BvbnNlJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBjb25zdCBpZF90b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaWRfdG9rZW4nKTtcbiAgICBwYXJhbWV0ZXJzLmRlbGV0ZSgnaWRfdG9rZW4nKTtcbiAgICBzd2l0Y2ggKGV4cGVjdGVkU3RhdGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgZXhwZWN0Tm9TdGF0ZTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0U3RyaW5nKGV4cGVjdGVkU3RhdGUsICdcImV4cGVjdGVkU3RhdGVcIiBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZUF1dGhSZXNwb25zZSh7XG4gICAgICAgIC4uLmFzLFxuICAgICAgICBhdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkOiBmYWxzZSxcbiAgICB9LCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkU3RhdGUpO1xuICAgIGlmICghaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInBhcmFtZXRlcnNcIiBkb2VzIG5vdCBjb250YWluIGFuIElEIFRva2VuJywgSU5WQUxJRF9SRVNQT05TRSk7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2NvZGUnKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInBhcmFtZXRlcnNcIiBkb2VzIG5vdCBjb250YWluIGFuIEF1dGhvcml6YXRpb24gQ29kZScsIElOVkFMSURfUkVTUE9OU0UpO1xuICAgIH1cbiAgICBjb25zdCByZXF1aXJlZENsYWltcyA9IFtcbiAgICAgICAgJ2F1ZCcsXG4gICAgICAgICdleHAnLFxuICAgICAgICAnaWF0JyxcbiAgICAgICAgJ2lzcycsXG4gICAgICAgICdzdWInLFxuICAgICAgICAnbm9uY2UnLFxuICAgICAgICAnY19oYXNoJyxcbiAgICBdO1xuICAgIGNvbnN0IHN0YXRlID0gcGFyYW1ldGVycy5nZXQoJ3N0YXRlJyk7XG4gICAgaWYgKGZhcGkgJiYgKHR5cGVvZiBleHBlY3RlZFN0YXRlID09PSAnc3RyaW5nJyB8fCBzdGF0ZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgcmVxdWlyZWRDbGFpbXMucHVzaCgnc19oYXNoJyk7XG4gICAgfVxuICAgIGlmIChtYXhBZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnROdW1iZXIobWF4QWdlLCB0cnVlLCAnXCJtYXhBZ2VcIiBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbGllbnQuZGVmYXVsdF9tYXhfYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGNsaWVudC5kZWZhdWx0X21heF9hZ2UsIHRydWUsICdcImNsaWVudC5kZWZhdWx0X21heF9hZ2VcIicpO1xuICAgIH1cbiAgICBtYXhBZ2UgPz89IGNsaWVudC5kZWZhdWx0X21heF9hZ2UgPz8gc2tpcEF1dGhUaW1lQ2hlY2s7XG4gICAgaWYgKGNsaWVudC5yZXF1aXJlX2F1dGhfdGltZSB8fCBtYXhBZ2UgIT09IHNraXBBdXRoVGltZUNoZWNrKSB7XG4gICAgICAgIHJlcXVpcmVkQ2xhaW1zLnB1c2goJ2F1dGhfdGltZScpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYWltcywgaGVhZGVyLCBqd3QgfSA9IGF3YWl0IHZhbGlkYXRlSnd0KGlkX3Rva2VuLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy5pZF90b2tlbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkLCAnUlMyNTYnKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCksIG9wdGlvbnM/Lltqd2VEZWNyeXB0XSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgcmVxdWlyZWRDbGFpbXMpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgY29uc3QgY2xvY2tTa2V3ID0gZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBjbG9ja1NrZXc7XG4gICAgaWYgKGNsYWltcy5pYXQgPCBub3cgLSAzNjAwKSB7XG4gICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJpYXRcIiAoaXNzdWVkIGF0KSBjbGFpbSB2YWx1ZSwgaXQgaXMgdG9vIGZhciBpbiB0aGUgcGFzdCcsIEpXVF9USU1FU1RBTVBfQ0hFQ0ssIHsgbm93LCBjbGFpbXMsIGNsYWltOiAnaWF0JyB9KTtcbiAgICB9XG4gICAgYXNzZXJ0U3RyaW5nKGNsYWltcy5jX2hhc2gsICdJRCBUb2tlbiBcImNfaGFzaFwiIChjb2RlIGhhc2gpIGNsYWltIHZhbHVlJywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICBjbGFpbXMsXG4gICAgfSk7XG4gICAgaWYgKGNsYWltcy5hdXRoX3RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnROdW1iZXIoY2xhaW1zLmF1dGhfdGltZSwgdHJ1ZSwgJ0lEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpJywgSU5WQUxJRF9SRVNQT05TRSwgeyBjbGFpbXMgfSk7XG4gICAgfVxuICAgIGlmIChtYXhBZ2UgIT09IHNraXBBdXRoVGltZUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgZ2V0Q2xvY2tTa2V3KGNsaWVudCk7XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCk7XG4gICAgICAgIGlmIChjbGFpbXMuYXV0aF90aW1lICsgbWF4QWdlIDwgbm93IC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3RvbyBtdWNoIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgRW5kLVVzZXIgYXV0aGVudGljYXRpb24nLCBKV1RfVElNRVNUQU1QX0NIRUNLLCB7IGNsYWltcywgbm93LCB0b2xlcmFuY2UsIGNsYWltOiAnYXV0aF90aW1lJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRTdHJpbmcoZXhwZWN0ZWROb25jZSwgJ1wiZXhwZWN0ZWROb25jZVwiIGFyZ3VtZW50Jyk7XG4gICAgaWYgKGNsYWltcy5ub25jZSAhPT0gZXhwZWN0ZWROb25jZSkge1xuICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZE5vbmNlLFxuICAgICAgICAgICAgY2xhaW1zLFxuICAgICAgICAgICAgY2xhaW06ICdub25jZScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSAmJiBjbGFpbXMuYXVkLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBpZiAoY2xhaW1zLmF6cCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ0lEIFRva2VuIFwiYXVkXCIgKGF1ZGllbmNlKSBjbGFpbSBpbmNsdWRlcyBhZGRpdGlvbmFsIHVudHJ1c3RlZCBhdWRpZW5jZXMnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwgeyBjbGFpbXMsIGNsYWltOiAnYXVkJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLmF6cCAhPT0gY2xpZW50LmNsaWVudF9pZCkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwiYXpwXCIgKGF1dGhvcml6ZWQgcGFydHkpIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogY2xpZW50LmNsaWVudF9pZCxcbiAgICAgICAgICAgICAgICBjbGFpbXMsXG4gICAgICAgICAgICAgICAgY2xhaW06ICdhenAnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyAwOiBwcm90ZWN0ZWRIZWFkZXIsIDE6IHBheWxvYWQsIDI6IGVuY29kZWRTaWduYXR1cmUgfSA9IGp3dC5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGI2NHUoZW5jb2RlZFNpZ25hdHVyZSk7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcik7XG4gICAgYXdhaXQgdmFsaWRhdGVKd3NTaWduYXR1cmUocHJvdGVjdGVkSGVhZGVyLCBwYXlsb2FkLCBrZXksIHNpZ25hdHVyZSk7XG4gICAgaWYgKChhd2FpdCBpZFRva2VuSGFzaE1hdGNoZXMoY29kZSwgY2xhaW1zLmNfaGFzaCwgaGVhZGVyLCAnY19oYXNoJykpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IE9QRSgnaW52YWxpZCBJRCBUb2tlbiBcImNfaGFzaFwiIChjb2RlIGhhc2gpIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICBhbGc6IGhlYWRlci5hbGcsXG4gICAgICAgICAgICBjbGFpbTogJ2NfaGFzaCcsXG4gICAgICAgICAgICBjbGFpbXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKGZhcGkgJiYgc3RhdGUgIT09IG51bGwpIHx8IGNsYWltcy5zX2hhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnRTdHJpbmcoY2xhaW1zLnNfaGFzaCwgJ0lEIFRva2VuIFwic19oYXNoXCIgKHN0YXRlIGhhc2gpIGNsYWltIHZhbHVlJywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgY2xhaW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nKHN0YXRlLCAnXCJzdGF0ZVwiIHJlc3BvbnNlIHBhcmFtZXRlcicsIElOVkFMSURfUkVTUE9OU0UsIHsgcGFyYW1ldGVycyB9KTtcbiAgICAgICAgaWYgKChhd2FpdCBpZFRva2VuSGFzaE1hdGNoZXMoc3RhdGUsIGNsYWltcy5zX2hhc2gsIGhlYWRlciwgJ3NfaGFzaCcpKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCdpbnZhbGlkIElEIFRva2VuIFwic19oYXNoXCIgKHN0YXRlIGhhc2gpIGNsYWltIHZhbHVlJywgSldUX0NMQUlNX0NPTVBBUklTT04sIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICBhbGc6IGhlYWRlci5hbGcsXG4gICAgICAgICAgICAgICAgY2xhaW06ICdzX2hhc2gnLFxuICAgICAgICAgICAgICAgIGNsYWltcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGVja1NpZ25pbmdBbGdvcml0aG0oY2xpZW50LCBpc3N1ZXIsIGZhbGxiYWNrLCBoZWFkZXIpIHtcbiAgICBpZiAoY2xpZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGllbnQgPT09ICdzdHJpbmcnID8gaGVhZGVyLmFsZyAhPT0gY2xpZW50IDogIWNsaWVudC5pbmNsdWRlcyhoZWFkZXIuYWxnKSkge1xuICAgICAgICAgICAgdGhyb3cgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBjbGllbnQsXG4gICAgICAgICAgICAgICAgcmVhc29uOiAnY2xpZW50IGNvbmZpZ3VyYXRpb24nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpc3N1ZXIpKSB7XG4gICAgICAgIGlmICghaXNzdWVyLmluY2x1ZGVzKGhlYWRlci5hbGcpKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGlzc3VlcixcbiAgICAgICAgICAgICAgICByZWFzb246ICdhdXRob3JpemF0aW9uIHNlcnZlciBtZXRhZGF0YScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGhlYWRlci5hbGcgIT09IGZhbGxiYWNrXG4gICAgICAgICAgICA6IHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gIWZhbGxiYWNrKGhlYWRlci5hbGcpXG4gICAgICAgICAgICAgICAgOiAhZmFsbGJhY2suaW5jbHVkZXMoaGVhZGVyLmFsZykpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhbGdcIiBoZWFkZXIgcGFyYW1ldGVyJywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgcmVhc29uOiAnZGVmYXVsdCB2YWx1ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IE9QRSgnbWlzc2luZyBjbGllbnQgb3Igc2VydmVyIGNvbmZpZ3VyYXRpb24gdG8gdmVyaWZ5IHVzZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicsIHVuZGVmaW5lZCwgeyBjbGllbnQsIGlzc3VlciwgZmFsbGJhY2sgfSk7XG59XG5mdW5jdGlvbiBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgbmFtZSkge1xuICAgIGNvbnN0IHsgMDogdmFsdWUsIGxlbmd0aCB9ID0gcGFyYW1ldGVycy5nZXRBbGwobmFtZSk7XG4gICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgT1BFKGBcIiR7bmFtZX1cIiBwYXJhbWV0ZXIgbXVzdCBiZSBwcm92aWRlZCBvbmx5IG9uY2VgLCBJTlZBTElEX1JFU1BPTlNFKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGNvbnN0IHNraXBTdGF0ZUNoZWNrID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3QgZXhwZWN0Tm9TdGF0ZSA9IFN5bWJvbCgpO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXV0aFJlc3BvbnNlKGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIGV4cGVjdGVkU3RhdGUpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBpZiAoIShwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMsIG9yIFVSTCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgaWYgKGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAncmVzcG9uc2UnKSkge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicGFyYW1ldGVyc1wiIGNvbnRhaW5zIGEgSkFSTSByZXNwb25zZSwgdXNlIHZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKCkgaW5zdGVhZCBvZiB2YWxpZGF0ZUF1dGhSZXNwb25zZSgpJywgSU5WQUxJRF9SRVNQT05TRSwgeyBwYXJhbWV0ZXJzIH0pO1xuICAgIH1cbiAgICBjb25zdCBpc3MgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2lzcycpO1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdzdGF0ZScpO1xuICAgIGlmICghaXNzICYmIGFzLmF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdyZXNwb25zZSBwYXJhbWV0ZXIgXCJpc3NcIiAoaXNzdWVyKSBtaXNzaW5nJywgSU5WQUxJRF9SRVNQT05TRSwgeyBwYXJhbWV0ZXJzIH0pO1xuICAgIH1cbiAgICBpZiAoaXNzICYmIGlzcyAhPT0gYXMuaXNzdWVyKSB7XG4gICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBcImlzc1wiIChpc3N1ZXIpIHJlc3BvbnNlIHBhcmFtZXRlciB2YWx1ZScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBhcy5pc3N1ZXIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3dpdGNoIChleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlIGV4cGVjdE5vU3RhdGU6XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IE9QRSgndW5leHBlY3RlZCBcInN0YXRlXCIgcmVzcG9uc2UgcGFyYW1ldGVyIGVuY291bnRlcmVkJywgSU5WQUxJRF9SRVNQT05TRSwge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc2tpcFN0YXRlQ2hlY2s6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFzc2VydFN0cmluZyhleHBlY3RlZFN0YXRlLCAnXCJleHBlY3RlZFN0YXRlXCIgYXJndW1lbnQnKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gZXhwZWN0ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IE9QRShzdGF0ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gJ3Jlc3BvbnNlIHBhcmFtZXRlciBcInN0YXRlXCIgbWlzc2luZydcbiAgICAgICAgICAgICAgICAgICAgOiAndW5leHBlY3RlZCBcInN0YXRlXCIgcmVzcG9uc2UgcGFyYW1ldGVyIHZhbHVlJywgSU5WQUxJRF9SRVNQT05TRSwgeyBleHBlY3RlZDogZXhwZWN0ZWRTdGF0ZSwgcGFyYW1ldGVycyB9KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2Vycm9yJyk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRob3JpemF0aW9uUmVzcG9uc2VFcnJvcignYXV0aG9yaXphdGlvbiByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgaXMgYW4gZXJyb3InLCB7XG4gICAgICAgICAgICBjYXVzZTogcGFyYW1ldGVycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlkX3Rva2VuID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdpZF90b2tlbicpO1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICd0b2tlbicpO1xuICAgIGlmIChpZF90b2tlbiAhPT0gdW5kZWZpbmVkIHx8IHRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ2ltcGxpY2l0IGFuZCBoeWJyaWQgZmxvd3MgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJyYW5kKG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycykpO1xufVxuZnVuY3Rpb24gYWxnVG9TdWJ0bGUoYWxnKSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUFMyNTYnOlxuICAgICAgICBjYXNlICdQUzM4NCc6XG4gICAgICAgIGNhc2UgJ1BTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdSU0EtUFNTJywgaGFzaDogYFNIQS0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgIGNhc2UgJ1JTMzg0JzpcbiAgICAgICAgY2FzZSAnUlM1MTInOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JywgaGFzaDogYFNIQS0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgIGNhc2UgJ0VTMzg0JzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdFQ0RTQScsIG5hbWVkQ3VydmU6IGBQLSR7YWxnLnNsaWNlKC0zKX1gIH07XG4gICAgICAgIGNhc2UgJ0VTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdFQ0RTQScsIG5hbWVkQ3VydmU6ICdQLTUyMScgfTtcbiAgICAgICAgY2FzZSAnRWREU0EnOlxuICAgICAgICAgICAgcmV0dXJuICdFZDI1NTE5JztcbiAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgIGNhc2UgJ01MLURTQS00NCc6XG4gICAgICAgIGNhc2UgJ01MLURTQS02NSc6XG4gICAgICAgIGNhc2UgJ01MLURTQS04Nyc6XG4gICAgICAgICAgICByZXR1cm4gYWxnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIEpXUyBhbGdvcml0aG0nLCB7IGNhdXNlOiB7IGFsZyB9IH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGltcG9ydEp3ayhhbGcsIGp3aykge1xuICAgIGNvbnN0IHsgZXh0LCBrZXlfb3BzLCB1c2UsIC4uLmtleSB9ID0gandrO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgnandrJywga2V5LCBhbGdUb1N1YnRsZShhbGcpLCB0cnVlLCBbJ3ZlcmlmeSddKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXZpY2VBdXRob3JpemF0aW9uUmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdkZXZpY2VfYXV0aG9yaXphdGlvbl9lbmRwb2ludCcsIGNsaWVudC51c2VfbXRsc19lbmRwb2ludF9hbGlhc2VzLCBvcHRpb25zPy5bYWxsb3dJbnNlY3VyZVJlcXVlc3RzXSAhPT0gdHJ1ZSk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0RldmljZUF1dGhvcml6YXRpb25SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgYXdhaXQgY2hlY2tPQXV0aEJvZHlFcnJvcihyZXNwb25zZSwgMjAwLCAnRGV2aWNlIEF1dGhvcml6YXRpb24gRW5kcG9pbnQnKTtcbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZ2V0UmVzcG9uc2VKc29uQm9keShyZXNwb25zZSk7XG4gICAgYXNzZXJ0U3RyaW5nKGpzb24uZGV2aWNlX2NvZGUsICdcInJlc3BvbnNlXCIgYm9keSBcImRldmljZV9jb2RlXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAgYXNzZXJ0U3RyaW5nKGpzb24udXNlcl9jb2RlLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJ1c2VyX2NvZGVcIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keToganNvbixcbiAgICB9KTtcbiAgICBhc3NlcnRTdHJpbmcoanNvbi52ZXJpZmljYXRpb25fdXJpLCAnXCJyZXNwb25zZVwiIGJvZHkgXCJ2ZXJpZmljYXRpb25fdXJpXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7IGJvZHk6IGpzb24gfSk7XG4gICAgbGV0IGV4cGlyZXNJbiA9IHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdChqc29uLmV4cGlyZXNfaW4pIDoganNvbi5leHBpcmVzX2luO1xuICAgIGFzc2VydE51bWJlcihleHBpcmVzSW4sIHRydWUsICdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keToganNvbixcbiAgICB9KTtcbiAgICBqc29uLmV4cGlyZXNfaW4gPSBleHBpcmVzSW47XG4gICAgaWYgKGpzb24udmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhqc29uLnZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUsICdcInJlc3BvbnNlXCIgYm9keSBcInZlcmlmaWNhdGlvbl91cmlfY29tcGxldGVcIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHsgYm9keToganNvbiB9KTtcbiAgICB9XG4gICAgaWYgKGpzb24uaW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnROdW1iZXIoanNvbi5pbnRlcnZhbCwgZmFsc2UsICdcInJlc3BvbnNlXCIgYm9keSBcImludGVydmFsXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBib2R5OiBqc29uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV2aWNlQ29kZUdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgZGV2aWNlQ29kZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBhc3NlcnRTdHJpbmcoZGV2aWNlQ29kZSwgJ1wiZGV2aWNlQ29kZVwiJyk7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdkZXZpY2VfY29kZScsIGRldmljZUNvZGUpO1xuICAgIHJldHVybiB0b2tlbkVuZHBvaW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmRldmljZV9jb2RlJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0RldmljZUNvZGVSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHVuZGVmaW5lZCwgb3B0aW9ucz8uW2p3ZURlY3J5cHRdLCBvcHRpb25zPy5yZWNvZ25pemVkVG9rZW5UeXBlcyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVLZXlQYWlyKGFsZywgb3B0aW9ucykge1xuICAgIGFzc2VydFN0cmluZyhhbGcsICdcImFsZ1wiJyk7XG4gICAgY29uc3QgYWxnb3JpdGhtID0gYWxnVG9TdWJ0bGUoYWxnKTtcbiAgICBpZiAoYWxnLnN0YXJ0c1dpdGgoJ1BTJykgfHwgYWxnLnN0YXJ0c1dpdGgoJ1JTJykpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhbGdvcml0aG0sIHtcbiAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IG9wdGlvbnM/Lm1vZHVsdXNMZW5ndGggPz8gMjA0OCxcbiAgICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBuZXcgVWludDhBcnJheShbMHgwMSwgMHgwMCwgMHgwMV0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBvcHRpb25zPy5leHRyYWN0YWJsZSA/PyBmYWxzZSwgW1xuICAgICAgICAnc2lnbicsXG4gICAgICAgICd2ZXJpZnknLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSHR1KGh0dSkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHR1KTtcbiAgICB1cmwuc2VhcmNoID0gJyc7XG4gICAgdXJsLmhhc2ggPSAnJztcbiAgICByZXR1cm4gdXJsLmhyZWY7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZURQb1AocmVxdWVzdCwgYWNjZXNzVG9rZW4sIGFjY2Vzc1Rva2VuQ2xhaW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaGVhZGVyVmFsdWUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdkcG9wJyk7XG4gICAgaWYgKGhlYWRlclZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IE9QRSgnb3BlcmF0aW9uIGluZGljYXRlZCBEUG9QIHVzZSBidXQgdGhlIHJlcXVlc3QgaGFzIG5vIERQb1AgSFRUUCBIZWFkZXInLCBJTlZBTElEX1JFUVVFU1QsIHsgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzIH0pO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2Rwb3AgJykgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IE9QRShgb3BlcmF0aW9uIGluZGljYXRlZCBEUG9QIHVzZSBidXQgdGhlIHJlcXVlc3QncyBBdXRob3JpemF0aW9uIEhUVFAgSGVhZGVyIHNjaGVtZSBpcyBub3QgRFBvUGAsIElOVkFMSURfUkVRVUVTVCwgeyBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWNjZXNzVG9rZW5DbGFpbXMuY25mPy5qa3QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IE9QRSgnb3BlcmF0aW9uIGluZGljYXRlZCBEUG9QIHVzZSBidXQgdGhlIEpXVCBBY2Nlc3MgVG9rZW4gaGFzIG5vIGprdCBjb25maXJtYXRpb24gY2xhaW0nLCBJTlZBTElEX1JFUVVFU1QsIHsgY2xhaW1zOiBhY2Nlc3NUb2tlbkNsYWltcyB9KTtcbiAgICB9XG4gICAgY29uc3QgY2xvY2tTa2V3ID0gZ2V0Q2xvY2tTa2V3KG9wdGlvbnMpO1xuICAgIGNvbnN0IHByb29mID0gYXdhaXQgdmFsaWRhdGVKd3QoaGVhZGVyVmFsdWUsIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgb3B0aW9ucz8uc2lnbmluZ0FsZ29yaXRobXMsIHVuZGVmaW5lZCwgc3VwcG9ydGVkKSwgY2xvY2tTa2V3LCBnZXRDbG9ja1RvbGVyYW5jZShvcHRpb25zKSwgdW5kZWZpbmVkKVxuICAgICAgICAudGhlbihjaGVja0p3dFR5cGUuYmluZCh1bmRlZmluZWQsICdkcG9wK2p3dCcpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBbJ2lhdCcsICdqdGknLCAnYXRoJywgJ2h0bScsICdodHUnXSkpO1xuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhub3cgLSBwcm9vZi5jbGFpbXMuaWF0KTtcbiAgICBpZiAoZGlmZiA+IDMwMCkge1xuICAgICAgICB0aHJvdyBPUEUoJ0RQb1AgUHJvb2YgaWF0IGlzIG5vdCByZWNlbnQgZW5vdWdoJywgSldUX1RJTUVTVEFNUF9DSEVDSywge1xuICAgICAgICAgICAgbm93LFxuICAgICAgICAgICAgY2xhaW1zOiBwcm9vZi5jbGFpbXMsXG4gICAgICAgICAgICBjbGFpbTogJ2lhdCcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJvb2YuY2xhaW1zLmh0bSAhPT0gcmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdEUG9QIFByb29mIGh0bSBtaXNtYXRjaCcsIEpXVF9DTEFJTV9DT01QQVJJU09OLCB7XG4gICAgICAgICAgICBleHBlY3RlZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICBjbGFpbXM6IHByb29mLmNsYWltcyxcbiAgICAgICAgICAgIGNsYWltOiAnaHRtJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvb2YuY2xhaW1zLmh0dSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgbm9ybWFsaXplSHR1KHByb29mLmNsYWltcy5odHUpICE9PSBub3JtYWxpemVIdHUocmVxdWVzdC51cmwpKSB7XG4gICAgICAgIHRocm93IE9QRSgnRFBvUCBQcm9vZiBodHUgbWlzbWF0Y2gnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwge1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IG5vcm1hbGl6ZUh0dShyZXF1ZXN0LnVybCksXG4gICAgICAgICAgICBjbGFpbXM6IHByb29mLmNsYWltcyxcbiAgICAgICAgICAgIGNsYWltOiAnaHR1JyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGFjY2Vzc1Rva2VuKSkpO1xuICAgICAgICBpZiAocHJvb2YuY2xhaW1zLmF0aCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgnRFBvUCBQcm9vZiBhdGggbWlzbWF0Y2gnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIGNsYWltczogcHJvb2YuY2xhaW1zLFxuICAgICAgICAgICAgICAgIGNsYWltOiAnYXRoJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBhd2FpdCBjYWxjdWxhdGVKd2tUaHVtYnByaW50KHByb29mLmhlYWRlci5qd2spO1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW5DbGFpbXMuY25mLmprdCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IE9QRSgnSldUIEFjY2VzcyBUb2tlbiBjb25maXJtYXRpb24gbWlzbWF0Y2gnLCBKV1RfQ0xBSU1fQ09NUEFSSVNPTiwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIGNsYWltczogYWNjZXNzVG9rZW5DbGFpbXMsXG4gICAgICAgICAgICAgICAgY2xhaW06ICdjbmYuamt0JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgMDogcHJvdGVjdGVkSGVhZGVyLCAxOiBwYXlsb2FkLCAyOiBlbmNvZGVkU2lnbmF0dXJlIH0gPSBoZWFkZXJWYWx1ZS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGI2NHUoZW5jb2RlZFNpZ25hdHVyZSk7XG4gICAgY29uc3QgeyBqd2ssIGFsZyB9ID0gcHJvb2YuaGVhZGVyO1xuICAgIGlmICghandrKSB7XG4gICAgICAgIHRocm93IE9QRSgnRFBvUCBQcm9vZiBpcyBtaXNzaW5nIHRoZSBqd2sgaGVhZGVyIHBhcmFtZXRlcicsIElOVkFMSURfUkVRVUVTVCwge1xuICAgICAgICAgICAgaGVhZGVyOiBwcm9vZi5oZWFkZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhd2FpdCBpbXBvcnRKd2soYWxnLCBqd2spO1xuICAgIGlmIChrZXkudHlwZSAhPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdEUG9QIFByb29mIGp3ayBoZWFkZXIgcGFyYW1ldGVyIG11c3QgY29udGFpbiBhIHB1YmxpYyBrZXknLCBJTlZBTElEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgIGhlYWRlcjogcHJvb2YuaGVhZGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgdmFsaWRhdGVKd3NTaWduYXR1cmUocHJvdGVjdGVkSGVhZGVyLCBwYXlsb2FkLCBrZXksIHNpZ25hdHVyZSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVKd3RBY2Nlc3NUb2tlbihhcywgcmVxdWVzdCwgZXhwZWN0ZWRBdWRpZW5jZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXF1ZXN0LCBSZXF1ZXN0KSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXF1ZXN0XCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXF1ZXN0JywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBhc3NlcnRTdHJpbmcoZXhwZWN0ZWRBdWRpZW5jZSwgJ1wiZXhwZWN0ZWRBdWRpZW5jZVwiJyk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoYXV0aG9yaXphdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicmVxdWVzdFwiIGlzIG1pc3NpbmcgYW4gQXV0aG9yaXphdGlvbiBIVFRQIEhlYWRlcicsIElOVkFMSURfUkVRVUVTVCwge1xuICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHsgMDogc2NoZW1lLCAxOiBhY2Nlc3NUb2tlbiwgbGVuZ3RoIH0gPSBhdXRob3JpemF0aW9uLnNwbGl0KCcgJyk7XG4gICAgc2NoZW1lID0gc2NoZW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgY2FzZSAnZHBvcCc6XG4gICAgICAgIGNhc2UgJ2JlYXJlcic6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBBdXRob3JpemF0aW9uIEhUVFAgSGVhZGVyIHNjaGVtZScsIHtcbiAgICAgICAgICAgICAgICBjYXVzZTogeyBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IE9QRSgnaW52YWxpZCBBdXRob3JpemF0aW9uIEhUVFAgSGVhZGVyIGZvcm1hdCcsIElOVkFMSURfUkVRVUVTVCwge1xuICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZWRDbGFpbXMgPSBbXG4gICAgICAgICdpc3MnLFxuICAgICAgICAnZXhwJyxcbiAgICAgICAgJ2F1ZCcsXG4gICAgICAgICdzdWInLFxuICAgICAgICAnaWF0JyxcbiAgICAgICAgJ2p0aScsXG4gICAgICAgICdjbGllbnRfaWQnLFxuICAgIF07XG4gICAgaWYgKG9wdGlvbnM/LnJlcXVpcmVEUG9QIHx8IHNjaGVtZSA9PT0gJ2Rwb3AnIHx8IHJlcXVlc3QuaGVhZGVycy5oYXMoJ2Rwb3AnKSkge1xuICAgICAgICByZXF1aXJlZENsYWltcy5wdXNoKCdjbmYnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjbGFpbXMsIGhlYWRlciB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoYWNjZXNzVG9rZW4sIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgb3B0aW9ucz8uc2lnbmluZ0FsZ29yaXRobXMsIHVuZGVmaW5lZCwgc3VwcG9ydGVkKSwgZ2V0Q2xvY2tTa2V3KG9wdGlvbnMpLCBnZXRDbG9ja1RvbGVyYW5jZShvcHRpb25zKSwgdW5kZWZpbmVkKVxuICAgICAgICAudGhlbihjaGVja0p3dFR5cGUuYmluZCh1bmRlZmluZWQsICdhdCtqd3QnKSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgcmVxdWlyZWRDbGFpbXMpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUlzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBleHBlY3RlZEF1ZGllbmNlKSlcbiAgICAgICAgLmNhdGNoKHJlYXNzaWduUlNDb2RlKTtcbiAgICBmb3IgKGNvbnN0IGNsYWltIG9mIFsnY2xpZW50X2lkJywgJ2p0aScsICdzdWInXSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltc1tjbGFpbV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoYHVuZXhwZWN0ZWQgSldUIFwiJHtjbGFpbX1cIiBjbGFpbSB0eXBlYCwgSU5WQUxJRF9SRVFVRVNULCB7IGNsYWltcyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ2NuZicgaW4gY2xhaW1zKSB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcy5jbmYpKSB7XG4gICAgICAgICAgICB0aHJvdyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiY25mXCIgKGNvbmZpcm1hdGlvbikgY2xhaW0gdmFsdWUnLCBJTlZBTElEX1JFUVVFU1QsIHsgY2xhaW1zIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgMDogY25mLCBsZW5ndGggfSA9IE9iamVjdC5rZXlzKGNsYWltcy5jbmYpO1xuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ211bHRpcGxlIGNvbmZpcm1hdGlvbiBjbGFpbXMgYXJlIG5vdCBzdXBwb3J0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiB7IGNsYWltcyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNuZiAhPT0gJ2prdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgSldUIENvbmZpcm1hdGlvbiBtZXRob2QnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiB7IGNsYWltcyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgMDogcHJvdGVjdGVkSGVhZGVyLCAxOiBwYXlsb2FkLCAyOiBlbmNvZGVkU2lnbmF0dXJlIH0gPSBhY2Nlc3NUb2tlbi5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGI2NHUoZW5jb2RlZFNpZ25hdHVyZSk7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkoYXMsIG9wdGlvbnMsIGhlYWRlcik7XG4gICAgYXdhaXQgdmFsaWRhdGVKd3NTaWduYXR1cmUocHJvdGVjdGVkSGVhZGVyLCBwYXlsb2FkLCBrZXksIHNpZ25hdHVyZSk7XG4gICAgaWYgKG9wdGlvbnM/LnJlcXVpcmVEUG9QIHx8XG4gICAgICAgIHNjaGVtZSA9PT0gJ2Rwb3AnIHx8XG4gICAgICAgIGNsYWltcy5jbmY/LmprdCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5oYXMoJ2Rwb3AnKSkge1xuICAgICAgICBhd2FpdCB2YWxpZGF0ZURQb1AocmVxdWVzdCwgYWNjZXNzVG9rZW4sIGNsYWltcywgb3B0aW9ucykuY2F0Y2gocmVhc3NpZ25SU0NvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhaW1zO1xufVxuZnVuY3Rpb24gcmVhc3NpZ25SU0NvZGUoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIE9wZXJhdGlvblByb2Nlc3NpbmdFcnJvciAmJiBlcnI/LmNvZGUgPT09IElOVkFMSURfUkVRVUVTVCkge1xuICAgICAgICBlcnIuY29kZSA9IElOVkFMSURfUkVTUE9OU0U7XG4gICAgfVxuICAgIHRocm93IGVycjtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBiYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlRW5kcG9pbnQoYXMsICdiYWNrY2hhbm5lbF9hdXRoZW50aWNhdGlvbl9lbmRwb2ludCcsIGNsaWVudC51c2VfbXRsc19lbmRwb2ludF9hbGlhc2VzLCBvcHRpb25zPy5bYWxsb3dJbnNlY3VyZVJlcXVlc3RzXSAhPT0gdHJ1ZSk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aGVudGljYXRpb24sIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0JhY2tjaGFubmVsQXV0aGVudGljYXRpb25SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgYXdhaXQgY2hlY2tPQXV0aEJvZHlFcnJvcihyZXNwb25zZSwgMjAwLCAnQmFja2NoYW5uZWwgQXV0aGVudGljYXRpb24gRW5kcG9pbnQnKTtcbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgZ2V0UmVzcG9uc2VKc29uQm9keShyZXNwb25zZSk7XG4gICAgYXNzZXJ0U3RyaW5nKGpzb24uYXV0aF9yZXFfaWQsICdcInJlc3BvbnNlXCIgYm9keSBcImF1dGhfcmVxX2lkXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAgbGV0IGV4cGlyZXNJbiA9IHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdChqc29uLmV4cGlyZXNfaW4pIDoganNvbi5leHBpcmVzX2luO1xuICAgIGFzc2VydE51bWJlcihleHBpcmVzSW4sIHRydWUsICdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keToganNvbixcbiAgICB9KTtcbiAgICBqc29uLmV4cGlyZXNfaW4gPSBleHBpcmVzSW47XG4gICAgaWYgKGpzb24uaW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnROdW1iZXIoanNvbi5pbnRlcnZhbCwgZmFsc2UsICdcInJlc3BvbnNlXCIgYm9keSBcImludGVydmFsXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBib2R5OiBqc29uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmFja2NoYW5uZWxBdXRoZW50aWNhdGlvbkdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoZW50aWNhdGlvbiwgYXV0aFJlcUlkLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGFzc2VydFN0cmluZyhhdXRoUmVxSWQsICdcImF1dGhSZXFJZFwiJyk7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdhdXRoX3JlcV9pZCcsIGF1dGhSZXFJZCk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCAndXJuOm9wZW5pZDpwYXJhbXM6Z3JhbnQtdHlwZTpjaWJhJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0JhY2tjaGFubmVsQXV0aGVudGljYXRpb25HcmFudFJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgdW5kZWZpbmVkLCBvcHRpb25zPy5bandlRGVjcnlwdF0sIG9wdGlvbnM/LnJlY29nbml6ZWRUb2tlblR5cGVzKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkeW5hbWljQ2xpZW50UmVnaXN0cmF0aW9uUmVxdWVzdChhcywgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZUVuZHBvaW50KGFzLCAncmVnaXN0cmF0aW9uX2VuZHBvaW50JywgbWV0YWRhdGEudXNlX210bHNfZW5kcG9pbnRfYWxpYXNlcywgb3B0aW9ucz8uW2FsbG93SW5zZWN1cmVSZXF1ZXN0c10gIT09IHRydWUpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1ApIHtcbiAgICAgICAgYXNzZXJ0RFBvUChvcHRpb25zLkRQb1ApO1xuICAgICAgICBhd2FpdCBvcHRpb25zLkRQb1AuYWRkUHJvb2YodXJsLCBoZWFkZXJzLCBtZXRob2QsIG9wdGlvbnMuaW5pdGlhbEFjY2Vzc1Rva2VuKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmluaXRpYWxBY2Nlc3NUb2tlbikge1xuICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGAke2hlYWRlcnMuaGFzKCdkcG9wJykgPyAnRFBvUCcgOiAnQmVhcmVyJ30gJHtvcHRpb25zLmluaXRpYWxBY2Nlc3NUb2tlbn1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAob3B0aW9ucz8uW2N1c3RvbUZldGNoXSB8fCBmZXRjaCkodXJsLmhyZWYsIHtcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodXJsLCBvcHRpb25zPy5zaWduYWwpLFxuICAgIH0pO1xuICAgIG9wdGlvbnM/LkRQb1A/LmNhY2hlTm9uY2UocmVzcG9uc2UsIHVybCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEeW5hbWljQ2xpZW50UmVnaXN0cmF0aW9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAoIWxvb3NlSW5zdGFuY2VPZihyZXNwb25zZSwgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgYXdhaXQgY2hlY2tPQXV0aEJvZHlFcnJvcihyZXNwb25zZSwgMjAxLCAnRHluYW1pYyBDbGllbnQgUmVnaXN0cmF0aW9uIEVuZHBvaW50Jyk7XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IGdldFJlc3BvbnNlSnNvbkJvZHkocmVzcG9uc2UpO1xuICAgIGFzc2VydFN0cmluZyhqc29uLmNsaWVudF9pZCwgJ1wicmVzcG9uc2VcIiBib2R5IFwiY2xpZW50X2lkXCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgIGJvZHk6IGpzb24sXG4gICAgfSk7XG4gICAgaWYgKGpzb24uY2xpZW50X3NlY3JldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhqc29uLmNsaWVudF9zZWNyZXQsICdcInJlc3BvbnNlXCIgYm9keSBcImNsaWVudF9zZWNyZXRcIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgICAgIGJvZHk6IGpzb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoanNvbi5jbGllbnRfc2VjcmV0KSB7XG4gICAgICAgIGFzc2VydE51bWJlcihqc29uLmNsaWVudF9zZWNyZXRfZXhwaXJlc19hdCwgdHJ1ZSwgJ1wicmVzcG9uc2VcIiBib2R5IFwiY2xpZW50X3NlY3JldF9leHBpcmVzX2F0XCIgcHJvcGVydHknLCBJTlZBTElEX1JFU1BPTlNFLCB7XG4gICAgICAgICAgICBib2R5OiBqc29uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb3VyY2VEaXNjb3ZlcnlSZXF1ZXN0KHJlc291cmNlSWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgIHJldHVybiBwZXJmb3JtRGlzY292ZXJ5KHJlc291cmNlSWRlbnRpZmllciwgJ3Jlc291cmNlSWRlbnRpZmllcicsICh1cmwpID0+IHtcbiAgICAgICAgcHJlcGVuZFdlbGxLbm93bih1cmwsICcud2VsbC1rbm93bi9vYXV0aC1wcm90ZWN0ZWQtcmVzb3VyY2UnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUmVzb3VyY2VEaXNjb3ZlcnlSZXNwb25zZShleHBlY3RlZFJlc291cmNlSWRlbnRpZmllciwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IGV4cGVjdGVkUmVzb3VyY2VJZGVudGlmaWVyO1xuICAgIGlmICghKGV4cGVjdGVkIGluc3RhbmNlb2YgVVJMKSAmJiBleHBlY3RlZCAhPT0gX25vZGlzY292ZXJ5Y2hlY2spIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiZXhwZWN0ZWRSZXNvdXJjZUlkZW50aWZpZXJcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgaWYgKCFsb29zZUluc3RhbmNlT2YocmVzcG9uc2UsIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIFJlc291cmNlIFNlcnZlciBNZXRhZGF0YSByZXNwb25zZSAodW5leHBlY3RlZCBIVFRQIHN0YXR1cyBjb2RlKScsIFJFU1BPTlNFX0lTX05PVF9DT05GT1JNLCByZXNwb25zZSk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBnZXRSZXNwb25zZUpzb25Cb2R5KHJlc3BvbnNlKTtcbiAgICBhc3NlcnRTdHJpbmcoanNvbi5yZXNvdXJjZSwgJ1wicmVzcG9uc2VcIiBib2R5IFwicmVzb3VyY2VcIiBwcm9wZXJ0eScsIElOVkFMSURfUkVTUE9OU0UsIHtcbiAgICAgICAgYm9keToganNvbixcbiAgICB9KTtcbiAgICBpZiAoZXhwZWN0ZWQgIT09IF9ub2Rpc2NvdmVyeWNoZWNrICYmIG5ldyBVUkwoanNvbi5yZXNvdXJjZSkuaHJlZiAhPT0gZXhwZWN0ZWQuaHJlZikge1xuICAgICAgICB0aHJvdyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwicmVzb3VyY2VcIiBwcm9wZXJ0eSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgdmFsdWUnLCBKU09OX0FUVFJJQlVURV9DT01QQVJJU09OLCB7IGV4cGVjdGVkOiBleHBlY3RlZC5ocmVmLCBib2R5OiBqc29uLCBhdHRyaWJ1dGU6ICdyZXNvdXJjZScgfSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVzcG9uc2VKc29uQm9keShyZXNwb25zZSwgY2hlY2sgPSBhc3NlcnRBcHBsaWNhdGlvbkpzb24pIHtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgY2hlY2socmVzcG9uc2UpO1xuICAgICAgICB0aHJvdyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgUEFSU0VfRVJST1IsIGNhdXNlKTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcsIElOVkFMSURfUkVTUE9OU0UsIHsgYm9keToganNvbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgY29uc3QgX25vcGtjZSA9IG5vcGtjZTtcbmV4cG9ydCBjb25zdCBfbm9kaXNjb3ZlcnljaGVjayA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IF9leHBlY3RlZElzc3VlciA9IFN5bWJvbCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIlVTRVJfQUdFTlQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzdGFydHNXaXRoIiwiTkFNRSIsIlZFUlNJT04iLCJsb29zZUluc3RhbmNlT2YiLCJpbnB1dCIsImV4cGVjdGVkIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInByb3RvdHlwZSIsIkVSUl9JTlZBTElEX0FSR19WQUxVRSIsIkVSUl9JTlZBTElEX0FSR19UWVBFIiwiQ29kZWRUeXBlRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsImNhdXNlIiwiZXJyIiwiVHlwZUVycm9yIiwiYXNzaWduIiwiYWxsb3dJbnNlY3VyZVJlcXVlc3RzIiwiY2xvY2tTa2V3IiwiY2xvY2tUb2xlcmFuY2UiLCJjdXN0b21GZXRjaCIsIm1vZGlmeUFzc2VydGlvbiIsImp3ZURlY3J5cHQiLCJqd2tzQ2FjaGUiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWYiLCJlbmNvZGUiLCJkZWNvZGUiLCJlbmNvZGVCYXNlNjRVcmwiLCJVaW50OEFycmF5IiwidG9CYXNlNjQiLCJBcnJheUJ1ZmZlciIsImFscGhhYmV0Iiwib21pdFBhZGRpbmciLCJDSFVOS19TSVpFIiwiYXJyIiwiaSIsImJ5dGVMZW5ndGgiLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJzdWJhcnJheSIsImJ0b2EiLCJqb2luIiwicmVwbGFjZSIsImRlY29kZUJhc2U2NFVybCIsImZyb21CYXNlNjQiLCJiaW5hcnkiLCJhdG9iIiwiYnl0ZXMiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiYjY0dSIsIlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIm5hbWUiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJjYXB0dXJlU3RhY2tUcmFjZSIsIk9wZXJhdGlvblByb2Nlc3NpbmdFcnJvciIsIk9QRSIsImNhbGN1bGF0ZUp3a1RodW1icHJpbnQiLCJqd2siLCJjb21wb25lbnRzIiwia3R5IiwiY3J2IiwieCIsInkiLCJhbGciLCJwdWIiLCJlIiwibiIsImNyeXB0byIsInN1YnRsZSIsImRpZ2VzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJhc3NlcnRDcnlwdG9LZXkiLCJrZXkiLCJpdCIsIkNyeXB0b0tleSIsImFzc2VydFByaXZhdGVLZXkiLCJ0eXBlIiwiYXNzZXJ0UHVibGljS2V5Iiwibm9ybWFsaXplVHlwIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImlzSnNvbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInByZXBhcmVIZWFkZXJzIiwiSGVhZGVycyIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsImhlYWRlcnMiLCJoYXMiLCJzZXQiLCJzaWduYWwiLCJ1cmwiLCJ1bmRlZmluZWQiLCJocmVmIiwiQWJvcnRTaWduYWwiLCJyZXBsYWNlRG91YmxlU2xhc2giLCJwYXRobmFtZSIsImluY2x1ZGVzIiwicHJlcGVuZFdlbGxLbm93biIsIndlbGxLbm93biIsImFsbG93VGVybWluYXRpbmdTbGFzaCIsImFwcGVuZFdlbGxLbm93biIsInBlcmZvcm1EaXNjb3ZlcnkiLCJ1cmxOYW1lIiwidHJhbnNmb3JtIiwiVVJMIiwiY2hlY2tQcm90b2NvbCIsImZldGNoIiwiYm9keSIsIm1ldGhvZCIsInJlZGlyZWN0IiwiZGlzY292ZXJ5UmVxdWVzdCIsImlzc3VlcklkZW50aWZpZXIiLCJhbGdvcml0aG0iLCJhc3NlcnROdW1iZXIiLCJhbGxvdzAiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImFzc2VydFN0cmluZyIsInByb2Nlc3NEaXNjb3ZlcnlSZXNwb25zZSIsImV4cGVjdGVkSXNzdWVySWRlbnRpZmllciIsInJlc3BvbnNlIiwiX25vZGlzY292ZXJ5Y2hlY2siLCJSZXNwb25zZSIsInN0YXR1cyIsIlJFU1BPTlNFX0lTX05PVF9DT05GT1JNIiwiYXNzZXJ0UmVhZGFibGVSZXNwb25zZSIsImpzb24iLCJnZXRSZXNwb25zZUpzb25Cb2R5IiwiaXNzdWVyIiwiSU5WQUxJRF9SRVNQT05TRSIsIkpTT05fQVRUUklCVVRFX0NPTVBBUklTT04iLCJhdHRyaWJ1dGUiLCJhc3NlcnRBcHBsaWNhdGlvbkpzb24iLCJhc3NlcnRDb250ZW50VHlwZSIsIm5vdEpzb24iLCJ0eXBlcyIsIm1zZyIsImxhc3QiLCJwb3AiLCJSRVNQT05TRV9JU19OT1RfSlNPTiIsImFzc2VydENvbnRlbnRUeXBlcyIsImdldENvbnRlbnRUeXBlIiwiY29udGVudFR5cGUiLCJyYW5kb21CeXRlcyIsImdldFJhbmRvbVZhbHVlcyIsImdlbmVyYXRlUmFuZG9tQ29kZVZlcmlmaWVyIiwiZ2VuZXJhdGVSYW5kb21TdGF0ZSIsImdlbmVyYXRlUmFuZG9tTm9uY2UiLCJjYWxjdWxhdGVQS0NFQ29kZUNoYWxsZW5nZSIsImNvZGVWZXJpZmllciIsImdldEtleUFuZEtpZCIsImtpZCIsInBzQWxnIiwiaGFzaCIsInJzQWxnIiwiZXNBbGciLCJuYW1lZEN1cnZlIiwia2V5VG9Kd3MiLCJnZXRDbG9ja1NrZXciLCJjbGllbnQiLCJza2V3IiwiZ2V0Q2xvY2tUb2xlcmFuY2UiLCJ0b2xlcmFuY2UiLCJNYXRoIiwic2lnbiIsImVwb2NoVGltZSIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImFzc2VydEFzIiwiYXMiLCJhc3NlcnRDbGllbnQiLCJjbGllbnRfaWQiLCJmb3JtVXJsRW5jb2RlIiwidG9rZW4iLCJlbmNvZGVVUklDb21wb25lbnQiLCJzdWJzdHJpbmciLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwiQ2xpZW50U2VjcmV0UG9zdCIsImNsaWVudFNlY3JldCIsIl9hcyIsIl9oZWFkZXJzIiwiQ2xpZW50U2VjcmV0QmFzaWMiLCJfYm9keSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJjcmVkZW50aWFscyIsImNsaWVudEFzc2VydGlvblBheWxvYWQiLCJqdGkiLCJhdWQiLCJleHAiLCJpYXQiLCJuYmYiLCJpc3MiLCJzdWIiLCJQcml2YXRlS2V5Snd0IiwiY2xpZW50UHJpdmF0ZUtleSIsImhlYWRlciIsInBheWxvYWQiLCJzaWduSnd0IiwiQ2xpZW50U2VjcmV0Snd0IiwibW9kaWZ5IiwiaW1wb3J0S2V5IiwiZGF0YSIsImhtYWMiLCJOb25lIiwiVGxzQ2xpZW50QXV0aCIsInVzYWdlcyIsInNpZ25hdHVyZSIsImtleVRvU3VidGxlIiwiaXNzdWVSZXF1ZXN0T2JqZWN0IiwicGFyYW1ldGVycyIsInByaXZhdGVLZXkiLCJVUkxTZWFyY2hQYXJhbXMiLCJjbGFpbXMiLCJyZXNvdXJjZSIsImdldEFsbCIsImdldCIsIm1heF9hZ2UiLCJwYXJzZUludCIsInBhcnNlIiwiUEFSU0VfRVJST1IiLCJhdXRob3JpemF0aW9uX2RldGFpbHMiLCJ0eXAiLCJqd2tDYWNoZSIsImdldFNldFB1YmxpY0p3a0NhY2hlIiwiZXhwb3J0S2V5IiwicHVibGljSndrIiwiV2Vha01hcCIsIlVSTFBhcnNlIiwiYmFzZSIsImVuZm9yY2VIdHRwcyIsInByb3RvY29sIiwiSFRUUF9SRVFVRVNUX0ZPUkJJRERFTiIsIlJFUVVFU1RfUFJPVE9DT0xfRk9SQklEREVOIiwidmFsaWRhdGVFbmRwb2ludCIsImVuZHBvaW50IiwidXNlTXRsc0FsaWFzIiwiTUlTU0lOR19TRVJWRVJfTUVUQURBVEEiLCJJTlZBTElEX1NFUlZFUl9NRVRBREFUQSIsInJlc29sdmVFbmRwb2ludCIsIm10bHNfZW5kcG9pbnRfYWxpYXNlcyIsInB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0IiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJ1c2VfbXRsc19lbmRwb2ludF9hbGlhc2VzIiwiRFBvUCIsImFzc2VydERQb1AiLCJhZGRQcm9vZiIsImF1dGhlbnRpY2F0ZWRSZXF1ZXN0IiwiY2FjaGVOb25jZSIsIkRQb1BIYW5kbGVyIiwicHVibGljS2V5IiwibWFwIiwiamt0Iiwia2V5UGFpciIsImV4dHJhY3RhYmxlIiwiYnJhbmRlZCIsImFkZCIsIk1hcCIsIml0ZW0iLCJkZWxldGUiLCJ2YWwiLCJzaXplIiwia2V5cyIsIm5leHQiLCJjYWxjdWxhdGVUaHVtYnByaW50IiwiaHRtIiwiYWNjZXNzVG9rZW4iLCJub25jZSIsIm9yaWdpbiIsImh0dSIsImF0aCIsImlzRFBvUE5vbmNlRXJyb3IiLCJXV1dBdXRoZW50aWNhdGVDaGFsbGVuZ2VFcnJvciIsImNoYWxsZW5nZSIsInNjaGVtZSIsImVycm9yIiwiUmVzcG9uc2VCb2R5RXJyb3IiLCJSRVNQT05TRV9CT0RZX0VSUk9SIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJBdXRob3JpemF0aW9uUmVzcG9uc2VFcnJvciIsIkFVVEhPUklaQVRJT05fUkVTUE9OU0VfRVJST1IiLCJXV1dfQVVUSEVOVElDQVRFX0NIQUxMRU5HRSIsInRva2VuTWF0Y2giLCJ0b2tlbjY4TWF0Y2giLCJxdW90ZWRNYXRjaCIsInF1b3RlZFBhcmFtTWF0Y2hlciIsInBhcmFtTWF0Y2hlciIsInNjaGVtZVJFIiwiUmVnRXhwIiwicXVvdGVkUGFyYW1SRSIsInVucXVvdGVkUGFyYW1SRSIsInRva2VuNjhQYXJhbVJFIiwicGFyc2VXd3dBdXRoZW50aWNhdGVDaGFsbGVuZ2VzIiwiY2hhbGxlbmdlcyIsInJlc3QiLCJtYXRjaCIsImFmdGVyU2NoZW1lIiwic3BhY2VNYXRjaCIsImhhc1BhcmFtZXRlcnMiLCJ0b2tlbjY4IiwicHJvY2Vzc1B1c2hlZEF1dGhvcml6YXRpb25SZXNwb25zZSIsImNoZWNrT0F1dGhCb2R5RXJyb3IiLCJyZXF1ZXN0X3VyaSIsImV4cGlyZXNJbiIsImV4cGlyZXNfaW4iLCJwYXJzZUZsb2F0IiwicGFyc2VPQXV0aFJlc3BvbnNlRXJyb3JCb2R5IiwiY2xvbmUiLCJsYWJlbCIsImNoZWNrQXV0aGVudGljYXRpb25DaGFsbGVuZ2VzIiwiY2FuY2VsIiwib3B0aW9uIiwicmVzb3VyY2VSZXF1ZXN0IiwicHJvdGVjdGVkUmVzb3VyY2VSZXF1ZXN0IiwidXNlckluZm9SZXF1ZXN0IiwidXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImFwcGVuZCIsImp3a3NNYXAiLCJzZXRKd2tzQ2FjaGUiLCJqd2tzIiwidWF0IiwiY2FjaGUiLCJhZ2UiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJpc0ZyZXNoSndrc0NhY2hlIiwiZXZlcnkiLCJjYWxsIiwiY2xlYXJKd2tzQ2FjaGUiLCJnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaSIsImNoZWNrU3VwcG9ydGVkSndzQWxnIiwiandrc1JlcXVlc3QiLCJ0aGVuIiwicHJvY2Vzc0p3a3NSZXNwb25zZSIsInNsaWNlIiwiY2FuZGlkYXRlcyIsImZpbHRlciIsInVzZSIsImtleV9vcHMiLCJLRVlfU0VMRUNUSU9OIiwiandrc191cmkiLCJpbXBvcnRKd2siLCJza2lwU3ViamVjdENoZWNrIiwic3BsaXQiLCJwcm9jZXNzVXNlckluZm9SZXNwb25zZSIsImV4cGVjdGVkU3ViamVjdCIsImp3dCIsInZhbGlkYXRlSnd0IiwidGV4dCIsImNoZWNrU2lnbmluZ0FsZ29yaXRobSIsImJpbmQiLCJ1c2VyaW5mb19zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwidmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlIiwidmFsaWRhdGVPcHRpb25hbElzc3VlciIsImp3dFJlZnMiLCJKV1RfVVNFUklORk9fRVhQRUNURUQiLCJ0b2tlbkVuZHBvaW50UmVxdWVzdCIsImdyYW50VHlwZSIsInJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdCIsInJlZnJlc2hUb2tlbiIsImFkZGl0aW9uYWxQYXJhbWV0ZXJzIiwiaWRUb2tlbkNsYWltcyIsImdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMiLCJyZWYiLCJpZF90b2tlbiIsInZhbGlkYXRlQXBwbGljYXRpb25MZXZlbFNpZ25hdHVyZSIsInByb3RlY3RlZEhlYWRlciIsImVuY29kZWRTaWduYXR1cmUiLCJ2YWxpZGF0ZUp3c1NpZ25hdHVyZSIsInByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZSIsImFkZGl0aW9uYWxSZXF1aXJlZElkVG9rZW5DbGFpbXMiLCJkZWNyeXB0Rm4iLCJyZWNvZ25pemVkVG9rZW5UeXBlcyIsImFjY2Vzc190b2tlbiIsInRva2VuX3R5cGUiLCJyZWZyZXNoX3Rva2VuIiwic2NvcGUiLCJyZXF1aXJlZENsYWltcyIsInJlcXVpcmVfYXV0aF90aW1lIiwiZGVmYXVsdF9tYXhfYWdlIiwiaWRfdG9rZW5fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsImlkX3Rva2VuX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZVByZXNlbmNlIiwidmFsaWRhdGVJc3N1ZXIiLCJ2YWxpZGF0ZUF1ZGllbmNlIiwiYXpwIiwiSldUX0NMQUlNX0NPTVBBUklTT04iLCJjbGFpbSIsImF1dGhfdGltZSIsInByb2Nlc3NSZWZyZXNoVG9rZW5SZXNwb25zZSIsInJlc3VsdCIsIl9leHBlY3RlZElzc3VlciIsIldlYWtTZXQiLCJicmFuZCIsInNlYXJjaFBhcmFtcyIsIm5vcGtjZSIsImF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0IiwiY2FsbGJhY2tQYXJhbWV0ZXJzIiwicmVkaXJlY3RVcmkiLCJnZXRVUkxTZWFyY2hQYXJhbWV0ZXIiLCJqd3RDbGFpbU5hbWVzIiwiY19oYXNoIiwic19oYXNoIiwiY25mIiwicmVxdWlyZWQiLCJleHBlY3ROb05vbmNlIiwic2tpcEF1dGhUaW1lQ2hlY2siLCJwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZSIsImV4cGVjdGVkTm9uY2UiLCJtYXhBZ2UiLCJyZXF1aXJlSWRUb2tlbiIsInByb2Nlc3NBdXRob3JpemF0aW9uQ29kZU9wZW5JRFJlc3BvbnNlIiwicHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT0F1dGgyUmVzcG9uc2UiLCJhZGRpdGlvbmFsUmVxdWlyZWRDbGFpbXMiLCJKV1RfVElNRVNUQU1QX0NIRUNLIiwiSU5WQUxJRF9SRVFVRVNUIiwiY2hlY2tKd3RUeXBlIiwiY2xpZW50Q3JlZGVudGlhbHNHcmFudFJlcXVlc3QiLCJnZW5lcmljVG9rZW5FbmRwb2ludFJlcXVlc3QiLCJwcm9jZXNzR2VuZXJpY1Rva2VuRW5kcG9pbnRSZXNwb25zZSIsInByb2Nlc3NDbGllbnRDcmVkZW50aWFsc1Jlc3BvbnNlIiwicmV2b2NhdGlvblJlcXVlc3QiLCJwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlIiwiYm9keVVzZWQiLCJpbnRyb3NwZWN0aW9uUmVxdWVzdCIsInJlcXVlc3RKd3RSZXNwb25zZSIsImludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZyIsInByb2Nlc3NJbnRyb3NwZWN0aW9uUmVzcG9uc2UiLCJpbnRyb3NwZWN0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ0b2tlbl9pbnRyb3NwZWN0aW9uIiwiYWN0aXZlIiwic3VwcG9ydGVkIiwiY2hlY2tSc2FLZXlBbGdvcml0aG0iLCJtb2R1bHVzTGVuZ3RoIiwiZWNkc2FIYXNoTmFtZSIsInNhbHRMZW5ndGgiLCJ2ZXJpZmllZCIsInZlcmlmeSIsImp3cyIsImNoZWNrQWxnIiwiZGVjcnlwdEp3dCIsImNyaXQiLCJ2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSIsImV4cGVjdGVkU3RhdGUiLCJhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGciLCJhdXRob3JpemF0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZUF1dGhSZXNwb25zZSIsImlkVG9rZW5IYXNoIiwiY2xhaW1OYW1lIiwiaWRUb2tlbkhhc2hNYXRjaGVzIiwiYWN0dWFsIiwidmFsaWRhdGVEZXRhY2hlZFNpZ25hdHVyZVJlc3BvbnNlIiwidmFsaWRhdGVIeWJyaWRSZXNwb25zZSIsInZhbGlkYXRlQ29kZUlkVG9rZW5SZXNwb25zZSIsImNvbnN1bWVTdHJlYW0iLCJyZXF1ZXN0IiwiZm9ybVBvc3RSZXNwb25zZSIsImZhcGkiLCJSZXF1ZXN0IiwiZXhwZWN0Tm9TdGF0ZSIsImF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJzdGF0ZSIsImZhbGxiYWNrIiwicmVhc29uIiwic2tpcFN0YXRlQ2hlY2siLCJhbGdUb1N1YnRsZSIsImV4dCIsImRldmljZUF1dGhvcml6YXRpb25SZXF1ZXN0IiwicHJvY2Vzc0RldmljZUF1dGhvcml6YXRpb25SZXNwb25zZSIsImRldmljZV9jb2RlIiwidXNlcl9jb2RlIiwidmVyaWZpY2F0aW9uX3VyaSIsInZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUiLCJpbnRlcnZhbCIsImRldmljZUNvZGVHcmFudFJlcXVlc3QiLCJkZXZpY2VDb2RlIiwicHJvY2Vzc0RldmljZUNvZGVSZXNwb25zZSIsImdlbmVyYXRlS2V5UGFpciIsInB1YmxpY0V4cG9uZW50IiwiZ2VuZXJhdGVLZXkiLCJub3JtYWxpemVIdHUiLCJzZWFyY2giLCJ2YWxpZGF0ZURQb1AiLCJhY2Nlc3NUb2tlbkNsYWltcyIsImhlYWRlclZhbHVlIiwicHJvb2YiLCJzaWduaW5nQWxnb3JpdGhtcyIsImRpZmYiLCJhYnMiLCJ2YWxpZGF0ZUp3dEFjY2Vzc1Rva2VuIiwiZXhwZWN0ZWRBdWRpZW5jZSIsImF1dGhvcml6YXRpb24iLCJyZXF1aXJlRFBvUCIsImNhdGNoIiwicmVhc3NpZ25SU0NvZGUiLCJiYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVxdWVzdCIsInByb2Nlc3NCYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UiLCJhdXRoX3JlcV9pZCIsImJhY2tjaGFubmVsQXV0aGVudGljYXRpb25HcmFudFJlcXVlc3QiLCJhdXRoUmVxSWQiLCJwcm9jZXNzQmFja2NoYW5uZWxBdXRoZW50aWNhdGlvbkdyYW50UmVzcG9uc2UiLCJkeW5hbWljQ2xpZW50UmVnaXN0cmF0aW9uUmVxdWVzdCIsIm1ldGFkYXRhIiwiaW5pdGlhbEFjY2Vzc1Rva2VuIiwicHJvY2Vzc0R5bmFtaWNDbGllbnRSZWdpc3RyYXRpb25SZXNwb25zZSIsImNsaWVudF9zZWNyZXQiLCJjbGllbnRfc2VjcmV0X2V4cGlyZXNfYXQiLCJyZXNvdXJjZURpc2NvdmVyeVJlcXVlc3QiLCJyZXNvdXJjZUlkZW50aWZpZXIiLCJwcm9jZXNzUmVzb3VyY2VEaXNjb3ZlcnlSZXNwb25zZSIsImV4cGVjdGVkUmVzb3VyY2VJZGVudGlmaWVyIiwiY2hlY2siLCJfbm9wa2NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/oauth4webapi/build/index.js\n");

/***/ })

};
;