"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-auth";
exports.ids = ["vendor-chunks/next-auth"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-auth/lib/client.js":
/*!**********************************************!*\
  !*** ./node_modules/next-auth/lib/client.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSessionError: () => (/* binding */ ClientSessionError),\n/* harmony export */   apiBaseUrl: () => (/* binding */ apiBaseUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   now: () => (/* binding */ now),\n/* harmony export */   parseUrl: () => (/* binding */ parseUrl),\n/* harmony export */   useOnline: () => (/* binding */ useOnline)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @auth/core/errors */ \"(ssr)/./node_modules/@auth/core/errors.js\");\n/* __next_internal_client_entry_do_not_use__ ClientSessionError,fetchData,apiBaseUrl,useOnline,now,parseUrl auto */ \n\n/** @todo */ class ClientFetchError extends _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__.AuthError {\n}\n/** @todo */ class ClientSessionError extends _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__.AuthError {\n}\n// ------------------------ Internal ------------------------\n/**\n * If passed 'appContext' via getInitialProps() in _app.js\n * then get the req object from ctx and use that for the\n * req value to allow `fetchData` to\n * work seemlessly in getInitialProps() on server side\n * pages *and* in _app.js.\n * @internal\n */ async function fetchData(path, __NEXTAUTH, logger, req = {}) {\n    const url = `${apiBaseUrl(__NEXTAUTH)}/${path}`;\n    try {\n        const options = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...req?.headers?.cookie ? {\n                    cookie: req.headers.cookie\n                } : {}\n            }\n        };\n        if (req?.body) {\n            options.body = JSON.stringify(req.body);\n            options.method = \"POST\";\n        }\n        const res = await fetch(url, options);\n        const data = await res.json();\n        if (!res.ok) throw data;\n        return data;\n    } catch (error) {\n        logger.error(new ClientFetchError(error.message, error));\n        return null;\n    }\n}\n/** @internal */ function apiBaseUrl(__NEXTAUTH) {\n    if (true) {\n        // Return absolute path when called server side\n        return `${__NEXTAUTH.baseUrlServer}${__NEXTAUTH.basePathServer}`;\n    }\n    // Return relative path when called client side\n    return __NEXTAUTH.basePath;\n}\n/** @internal  */ function useOnline() {\n    const [isOnline, setIsOnline] = react__WEBPACK_IMPORTED_MODULE_0__.useState(typeof navigator !== \"undefined\" ? navigator.onLine : false);\n    const setOnline = ()=>setIsOnline(true);\n    const setOffline = ()=>setIsOnline(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        window.addEventListener(\"online\", setOnline);\n        window.addEventListener(\"offline\", setOffline);\n        return ()=>{\n            window.removeEventListener(\"online\", setOnline);\n            window.removeEventListener(\"offline\", setOffline);\n        };\n    }, []);\n    return isOnline;\n}\n/**\n * Returns the number of seconds elapsed since January 1, 1970 00:00:00 UTC.\n * @internal\n */ function now() {\n    return Math.floor(Date.now() / 1000);\n}\n/**\n * Returns an `URL` like object to make requests/redirects from server-side\n * @internal\n */ function parseUrl(url) {\n    const defaultUrl = new URL(\"http://localhost:3000/api/auth\");\n    if (url && !url.startsWith(\"http\")) {\n        url = `https://${url}`;\n    }\n    const _url = new URL(url || defaultUrl);\n    const path = (_url.pathname === \"/\" ? defaultUrl.pathname : _url.pathname)// Remove trailing slash\n    .replace(/\\/$/, \"\");\n    const base = `${_url.origin}${path}`;\n    return {\n        origin: _url.origin,\n        host: _url.host,\n        path,\n        base,\n        toString: ()=>base\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2xpYi9jbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7b0hBQytCO0FBQ2U7QUFDOUMsVUFBVSxHQUNWLE1BQU1FLHlCQUF5QkQsd0RBQVNBO0FBQ3hDO0FBQ0EsVUFBVSxHQUNILE1BQU1FLDJCQUEyQkYsd0RBQVNBO0FBQ2pEO0FBQ0EsNkRBQTZEO0FBQzdEOzs7Ozs7O0NBT0MsR0FDTSxlQUFlRyxVQUFVQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLENBQUMsQ0FBQztJQUM5RCxNQUFNQyxNQUFNLENBQUMsRUFBRUMsV0FBV0osWUFBWSxDQUFDLEVBQUVELEtBQUssQ0FBQztJQUMvQyxJQUFJO1FBQ0EsTUFBTU0sVUFBVTtZQUNaQyxTQUFTO2dCQUNMLGdCQUFnQjtnQkFDaEIsR0FBSUosS0FBS0ksU0FBU0MsU0FBUztvQkFBRUEsUUFBUUwsSUFBSUksT0FBTyxDQUFDQyxNQUFNO2dCQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2xFO1FBQ0o7UUFDQSxJQUFJTCxLQUFLTSxNQUFNO1lBQ1hILFFBQVFHLElBQUksR0FBR0MsS0FBS0MsU0FBUyxDQUFDUixJQUFJTSxJQUFJO1lBQ3RDSCxRQUFRTSxNQUFNLEdBQUc7UUFDckI7UUFDQSxNQUFNQyxNQUFNLE1BQU1DLE1BQU1WLEtBQUtFO1FBQzdCLE1BQU1TLE9BQU8sTUFBTUYsSUFBSUcsSUFBSTtRQUMzQixJQUFJLENBQUNILElBQUlJLEVBQUUsRUFDUCxNQUFNRjtRQUNWLE9BQU9BO0lBQ1gsRUFDQSxPQUFPRyxPQUFPO1FBQ1ZoQixPQUFPZ0IsS0FBSyxDQUFDLElBQUlyQixpQkFBaUJxQixNQUFNQyxPQUFPLEVBQUVEO1FBQ2pELE9BQU87SUFDWDtBQUNKO0FBQ0EsY0FBYyxHQUNQLFNBQVNiLFdBQVdKLFVBQVU7SUFDakMsSUFBSSxJQUE2QixFQUFFO1FBQy9CLCtDQUErQztRQUMvQyxPQUFPLENBQUMsRUFBRUEsV0FBV21CLGFBQWEsQ0FBQyxFQUFFbkIsV0FBV29CLGNBQWMsQ0FBQyxDQUFDO0lBQ3BFO0lBQ0EsK0NBQStDO0lBQy9DLE9BQU9wQixXQUFXcUIsUUFBUTtBQUM5QjtBQUNBLGVBQWUsR0FDUixTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHOUIsMkNBQWMsQ0FBQyxPQUFPZ0MsY0FBYyxjQUFjQSxVQUFVQyxNQUFNLEdBQUc7SUFDckcsTUFBTUMsWUFBWSxJQUFNSixZQUFZO0lBQ3BDLE1BQU1LLGFBQWEsSUFBTUwsWUFBWTtJQUNyQzlCLDRDQUFlLENBQUM7UUFDWnFDLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVKO1FBQ2xDRyxPQUFPQyxnQkFBZ0IsQ0FBQyxXQUFXSDtRQUNuQyxPQUFPO1lBQ0hFLE9BQU9FLG1CQUFtQixDQUFDLFVBQVVMO1lBQ3JDRyxPQUFPRSxtQkFBbUIsQ0FBQyxXQUFXSjtRQUMxQztJQUNKLEdBQUcsRUFBRTtJQUNMLE9BQU9OO0FBQ1g7QUFDQTs7O0NBR0MsR0FDTSxTQUFTVztJQUNaLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0gsR0FBRyxLQUFLO0FBQ25DO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0ksU0FBU25DLEdBQUc7SUFDeEIsTUFBTW9DLGFBQWEsSUFBSUMsSUFBSTtJQUMzQixJQUFJckMsT0FBTyxDQUFDQSxJQUFJc0MsVUFBVSxDQUFDLFNBQVM7UUFDaEN0QyxNQUFNLENBQUMsUUFBUSxFQUFFQSxJQUFJLENBQUM7SUFDMUI7SUFDQSxNQUFNdUMsT0FBTyxJQUFJRixJQUFJckMsT0FBT29DO0lBQzVCLE1BQU14QyxPQUFPLENBQUMyQyxLQUFLQyxRQUFRLEtBQUssTUFBTUosV0FBV0ksUUFBUSxHQUFHRCxLQUFLQyxRQUFRLENBQ3JFLHdCQUF3QjtLQUN2QkMsT0FBTyxDQUFDLE9BQU87SUFDcEIsTUFBTUMsT0FBTyxDQUFDLEVBQUVILEtBQUtJLE1BQU0sQ0FBQyxFQUFFL0MsS0FBSyxDQUFDO0lBQ3BDLE9BQU87UUFDSCtDLFFBQVFKLEtBQUtJLE1BQU07UUFDbkJDLE1BQU1MLEtBQUtLLElBQUk7UUFDZmhEO1FBQ0E4QztRQUNBRyxVQUFVLElBQU1IO0lBQ3BCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waWdtZW50b3N0a3RzLXdlYi8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvbGliL2NsaWVudC5qcz80NDY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tIFwiQGF1dGgvY29yZS9lcnJvcnNcIjtcbi8qKiBAdG9kbyAqL1xuY2xhc3MgQ2xpZW50RmV0Y2hFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG59XG4vKiogQHRvZG8gKi9cbmV4cG9ydCBjbGFzcyBDbGllbnRTZXNzaW9uRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEludGVybmFsIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBJZiBwYXNzZWQgJ2FwcENvbnRleHQnIHZpYSBnZXRJbml0aWFsUHJvcHMoKSBpbiBfYXBwLmpzXG4gKiB0aGVuIGdldCB0aGUgcmVxIG9iamVjdCBmcm9tIGN0eCBhbmQgdXNlIHRoYXQgZm9yIHRoZVxuICogcmVxIHZhbHVlIHRvIGFsbG93IGBmZXRjaERhdGFgIHRvXG4gKiB3b3JrIHNlZW1sZXNzbHkgaW4gZ2V0SW5pdGlhbFByb3BzKCkgb24gc2VydmVyIHNpZGVcbiAqIHBhZ2VzICphbmQqIGluIF9hcHAuanMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YShwYXRoLCBfX05FWFRBVVRILCBsb2dnZXIsIHJlcSA9IHt9KSB7XG4gICAgY29uc3QgdXJsID0gYCR7YXBpQmFzZVVybChfX05FWFRBVVRIKX0vJHtwYXRofWA7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi4ocmVxPy5oZWFkZXJzPy5jb29raWUgPyB7IGNvb2tpZTogcmVxLmhlYWRlcnMuY29va2llIH0gOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxPy5ib2R5KSB7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXEuYm9keSk7XG4gICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICBpZiAoIXJlcy5vaylcbiAgICAgICAgICAgIHRocm93IGRhdGE7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKG5ldyBDbGllbnRGZXRjaEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhcGlCYXNlVXJsKF9fTkVYVEFVVEgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBSZXR1cm4gYWJzb2x1dGUgcGF0aCB3aGVuIGNhbGxlZCBzZXJ2ZXIgc2lkZVxuICAgICAgICByZXR1cm4gYCR7X19ORVhUQVVUSC5iYXNlVXJsU2VydmVyfSR7X19ORVhUQVVUSC5iYXNlUGF0aFNlcnZlcn1gO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gcmVsYXRpdmUgcGF0aCB3aGVuIGNhbGxlZCBjbGllbnQgc2lkZVxuICAgIHJldHVybiBfX05FWFRBVVRILmJhc2VQYXRoO1xufVxuLyoqIEBpbnRlcm5hbCAgKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPbmxpbmUoKSB7XG4gICAgY29uc3QgW2lzT25saW5lLCBzZXRJc09ubGluZV0gPSBSZWFjdC51c2VTdGF0ZSh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yLm9uTGluZSA6IGZhbHNlKTtcbiAgICBjb25zdCBzZXRPbmxpbmUgPSAoKSA9PiBzZXRJc09ubGluZSh0cnVlKTtcbiAgICBjb25zdCBzZXRPZmZsaW5lID0gKCkgPT4gc2V0SXNPbmxpbmUoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIHNldE9ubGluZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBzZXRPZmZsaW5lKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIHNldE9ubGluZSk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgc2V0T2ZmbGluZSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBpc09ubGluZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgZWxhcHNlZCBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgMDA6MDA6MDAgVVRDLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGBVUkxgIGxpa2Ugb2JqZWN0IHRvIG1ha2UgcmVxdWVzdHMvcmVkaXJlY3RzIGZyb20gc2VydmVyLXNpZGVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gICAgY29uc3QgZGVmYXVsdFVybCA9IG5ldyBVUkwoXCJodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGhcIik7XG4gICAgaWYgKHVybCAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgIHVybCA9IGBodHRwczovLyR7dXJsfWA7XG4gICAgfVxuICAgIGNvbnN0IF91cmwgPSBuZXcgVVJMKHVybCB8fCBkZWZhdWx0VXJsKTtcbiAgICBjb25zdCBwYXRoID0gKF91cmwucGF0aG5hbWUgPT09IFwiL1wiID8gZGVmYXVsdFVybC5wYXRobmFtZSA6IF91cmwucGF0aG5hbWUpXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICAucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgIGNvbnN0IGJhc2UgPSBgJHtfdXJsLm9yaWdpbn0ke3BhdGh9YDtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW46IF91cmwub3JpZ2luLFxuICAgICAgICBob3N0OiBfdXJsLmhvc3QsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHRvU3RyaW5nOiAoKSA9PiBiYXNlLFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJBdXRoRXJyb3IiLCJDbGllbnRGZXRjaEVycm9yIiwiQ2xpZW50U2Vzc2lvbkVycm9yIiwiZmV0Y2hEYXRhIiwicGF0aCIsIl9fTkVYVEFVVEgiLCJsb2dnZXIiLCJyZXEiLCJ1cmwiLCJhcGlCYXNlVXJsIiwib3B0aW9ucyIsImhlYWRlcnMiLCJjb29raWUiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ldGhvZCIsInJlcyIsImZldGNoIiwiZGF0YSIsImpzb24iLCJvayIsImVycm9yIiwibWVzc2FnZSIsImJhc2VVcmxTZXJ2ZXIiLCJiYXNlUGF0aFNlcnZlciIsImJhc2VQYXRoIiwidXNlT25saW5lIiwiaXNPbmxpbmUiLCJzZXRJc09ubGluZSIsInVzZVN0YXRlIiwibmF2aWdhdG9yIiwib25MaW5lIiwic2V0T25saW5lIiwic2V0T2ZmbGluZSIsInVzZUVmZmVjdCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibm93IiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsInBhcnNlVXJsIiwiZGVmYXVsdFVybCIsIlVSTCIsInN0YXJ0c1dpdGgiLCJfdXJsIiwicGF0aG5hbWUiLCJyZXBsYWNlIiwiYmFzZSIsIm9yaWdpbiIsImhvc3QiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-auth/lib/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next-auth/react.js":
/*!*****************************************!*\
  !*** ./node_modules/next-auth/react.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SessionContext: () => (/* binding */ SessionContext),\n/* harmony export */   SessionProvider: () => (/* binding */ SessionProvider),\n/* harmony export */   __NEXTAUTH: () => (/* binding */ __NEXTAUTH),\n/* harmony export */   getCsrfToken: () => (/* binding */ getCsrfToken),\n/* harmony export */   getProviders: () => (/* binding */ getProviders),\n/* harmony export */   getSession: () => (/* binding */ getSession),\n/* harmony export */   signIn: () => (/* binding */ signIn),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   useSession: () => (/* binding */ useSession)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _lib_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/client.js */ \"(ssr)/./node_modules/next-auth/lib/client.js\");\n/**\n *\n * NextAuth.js is the official integration of Auth.js for Next.js applications. It supports both\n * [Client Components](https://nextjs.org/docs/app/building-your-application/rendering/client-components) and the\n * [Pages Router](https://nextjs.org/docs/pages). It includes methods for signing in, signing out, hooks, and a React\n * Context provider to wrap your application and make session data available anywhere.\n *\n * For use in [Server Actions](https://nextjs.org/docs/app/api-reference/functions/server-actions), check out [these methods](https://authjs.dev/guides/upgrade-to-v5#methods)\n *\n * @module react\n */ /* __next_internal_client_entry_do_not_use__ __NEXTAUTH,SessionContext,useSession,getSession,getCsrfToken,getProviders,signIn,signOut,SessionProvider auto */ \n\n\n// This behaviour mirrors the default behaviour for getting the site name that\n// happens server side in server/index.js\n// 1. An empty value is legitimate when the code is being invoked client side as\n//    relative URLs are valid in that context and so defaults to empty.\n// 2. When invoked server side the value is picked up from an environment\n//    variable and defaults to 'http://localhost:3000'.\nconst __NEXTAUTH = {\n    baseUrl: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL ?? process.env.VERCEL_URL).origin,\n    basePath: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL).path,\n    baseUrlServer: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL_INTERNAL ?? process.env.NEXTAUTH_URL ?? process.env.VERCEL_URL).origin,\n    basePathServer: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL_INTERNAL ?? process.env.NEXTAUTH_URL).path,\n    _lastSync: 0,\n    _session: undefined,\n    _getSession: ()=>{}\n};\n// https://github.com/nextauthjs/next-auth/pull/10762\nlet broadcastChannel = null;\nfunction getNewBroadcastChannel() {\n    if (typeof BroadcastChannel === \"undefined\") {\n        return {\n            postMessage: ()=>{},\n            addEventListener: ()=>{},\n            removeEventListener: ()=>{},\n            name: \"next-auth\",\n            onmessage: null,\n            onmessageerror: null,\n            close: ()=>{},\n            dispatchEvent: ()=>false\n        };\n    }\n    return new BroadcastChannel(\"next-auth\");\n}\nfunction broadcast() {\n    if (broadcastChannel === null) {\n        broadcastChannel = getNewBroadcastChannel();\n    }\n    return broadcastChannel;\n}\n// TODO:\nconst logger = {\n    debug: console.debug,\n    error: console.error,\n    warn: console.warn\n};\nconst SessionContext = react__WEBPACK_IMPORTED_MODULE_1__.createContext?.(undefined);\n/**\n * React Hook that gives you access to the logged in user's session data and lets you modify it.\n *\n * :::info\n * `useSession` is for client-side use only and when using [Next.js App Router (`app/`)](https://nextjs.org/blog/next-13-4#nextjs-app-router) you should prefer the `auth()` export.\n * :::\n */ function useSession(options) {\n    if (!SessionContext) {\n        throw new Error(\"React Context is unavailable in Server Components\");\n    }\n    // @ts-expect-error Satisfy TS if branch on line below\n    const value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(SessionContext);\n    if (!value && \"development\" !== \"production\") {\n        throw new Error(\"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\");\n    }\n    const { required, onUnauthenticated } = options ?? {};\n    const requiredAndNotLoading = required && value.status === \"unauthenticated\";\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (requiredAndNotLoading) {\n            const url = `${__NEXTAUTH.basePath}/signin?${new URLSearchParams({\n                error: \"SessionRequired\",\n                callbackUrl: window.location.href\n            })}`;\n            if (onUnauthenticated) onUnauthenticated();\n            else window.location.href = url;\n        }\n    }, [\n        requiredAndNotLoading,\n        onUnauthenticated\n    ]);\n    if (requiredAndNotLoading) {\n        return {\n            data: value.data,\n            update: value.update,\n            status: \"loading\"\n        };\n    }\n    return value;\n}\nasync function getSession(params) {\n    const session = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"session\", __NEXTAUTH, logger, params);\n    if (params?.broadcast ?? true) {\n        // https://github.com/nextauthjs/next-auth/pull/11470\n        getNewBroadcastChannel().postMessage({\n            event: \"session\",\n            data: {\n                trigger: \"getSession\"\n            }\n        });\n    }\n    return session;\n}\n/**\n * Returns the current Cross-Site Request Forgery Token (CSRF Token)\n * required to make requests that changes state. (e.g. signing in or out, or updating the session).\n *\n * [CSRF Prevention: Double Submit Cookie](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie)\n */ async function getCsrfToken() {\n    const response = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"csrf\", __NEXTAUTH, logger);\n    return response?.csrfToken ?? \"\";\n}\nasync function getProviders() {\n    return (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"providers\", __NEXTAUTH, logger);\n}\nasync function signIn(provider, options, authorizationParams) {\n    const { callbackUrl, ...rest } = options ?? {};\n    const { redirect = true, redirectTo = callbackUrl ?? window.location.href, ...signInParams } = rest;\n    const baseUrl = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.apiBaseUrl)(__NEXTAUTH);\n    const providers = await getProviders();\n    if (!providers) {\n        const url = `${baseUrl}/error`;\n        window.location.href = url;\n        return; // TODO: Return error if `redirect: false`\n    }\n    if (!provider || !providers[provider]) {\n        const url = `${baseUrl}/signin?${new URLSearchParams({\n            callbackUrl: redirectTo\n        })}`;\n        window.location.href = url;\n        return; // TODO: Return error if `redirect: false`\n    }\n    const providerType = providers[provider].type;\n    if (providerType === \"webauthn\") {\n        // TODO: Add docs link with explanation\n        throw new TypeError([\n            `Provider id \"${provider}\" refers to a WebAuthn provider.`,\n            'Please use `import { signIn } from \"next-auth/webauthn\"` instead.'\n        ].join(\"\\n\"));\n    }\n    const signInUrl = `${baseUrl}/${providerType === \"credentials\" ? \"callback\" : \"signin\"}/${provider}`;\n    const csrfToken = await getCsrfToken();\n    const res = await fetch(`${signInUrl}?${new URLSearchParams(authorizationParams)}`, {\n        method: \"post\",\n        headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Auth-Return-Redirect\": \"1\"\n        },\n        body: new URLSearchParams({\n            ...signInParams,\n            csrfToken,\n            callbackUrl: redirectTo\n        })\n    });\n    const data = await res.json();\n    if (redirect) {\n        const url = data.url ?? redirectTo;\n        window.location.href = url;\n        // If url contains a hash, the browser does not reload the page. We reload manually\n        if (url.includes(\"#\")) window.location.reload();\n        return;\n    }\n    const error = new URL(data.url).searchParams.get(\"error\") ?? undefined;\n    const code = new URL(data.url).searchParams.get(\"code\") ?? undefined;\n    if (res.ok) {\n        await __NEXTAUTH._getSession({\n            event: \"storage\"\n        });\n    }\n    return {\n        error,\n        code,\n        status: res.status,\n        ok: res.ok,\n        url: error ? null : data.url\n    };\n}\nasync function signOut(options) {\n    const { redirect = true, redirectTo = options?.callbackUrl ?? window.location.href } = options ?? {};\n    const baseUrl = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.apiBaseUrl)(__NEXTAUTH);\n    const csrfToken = await getCsrfToken();\n    const res = await fetch(`${baseUrl}/signout`, {\n        method: \"post\",\n        headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Auth-Return-Redirect\": \"1\"\n        },\n        body: new URLSearchParams({\n            csrfToken,\n            callbackUrl: redirectTo\n        })\n    });\n    const data = await res.json();\n    broadcast().postMessage({\n        event: \"session\",\n        data: {\n            trigger: \"signout\"\n        }\n    });\n    if (redirect) {\n        const url = data.url ?? redirectTo;\n        window.location.href = url;\n        // If url contains a hash, the browser does not reload the page. We reload manually\n        if (url.includes(\"#\")) window.location.reload();\n        return;\n    }\n    await __NEXTAUTH._getSession({\n        event: \"storage\"\n    });\n    return data;\n}\n/**\n * [React Context](https://react.dev/learn/passing-data-deeply-with-context) provider to wrap the app (`pages/`) to make session data available anywhere.\n *\n * When used, the session state is automatically synchronized across all open tabs/windows and they are all updated whenever they gain or lose focus\n * or the state changes (e.g. a user signs in or out) when {@link SessionProviderProps.refetchOnWindowFocus} is `true`.\n *\n * :::info\n * `SessionProvider` is for client-side use only and when using [Next.js App Router (`app/`)](https://nextjs.org/blog/next-13-4#nextjs-app-router) you should prefer the `auth()` export.\n * :::\n */ function SessionProvider(props) {\n    if (!SessionContext) {\n        throw new Error(\"React Context is unavailable in Server Components\");\n    }\n    const { children, basePath, refetchInterval, refetchWhenOffline } = props;\n    if (basePath) __NEXTAUTH.basePath = basePath;\n    /**\n     * If session was `null`, there was an attempt to fetch it,\n     * but it failed, but we still treat it as a valid initial value.\n     */ const hasInitialSession = props.session !== undefined;\n    /** If session was passed, initialize as already synced */ __NEXTAUTH._lastSync = hasInitialSession ? (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)() : 0;\n    const [session, setSession] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>{\n        if (hasInitialSession) __NEXTAUTH._session = props.session;\n        return props.session;\n    });\n    /** If session was passed, initialize as not loading */ const [loading, setLoading] = react__WEBPACK_IMPORTED_MODULE_1__.useState(!hasInitialSession);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        __NEXTAUTH._getSession = async ({ event } = {})=>{\n            try {\n                const storageEvent = event === \"storage\";\n                // We should always update if we don't have a client session yet\n                // or if there are events from other tabs/windows\n                if (storageEvent || __NEXTAUTH._session === undefined) {\n                    __NEXTAUTH._lastSync = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)();\n                    __NEXTAUTH._session = await getSession({\n                        broadcast: !storageEvent\n                    });\n                    setSession(__NEXTAUTH._session);\n                    return;\n                }\n                if (// If there is no time defined for when a session should be considered\n                // stale, then it's okay to use the value we have until an event is\n                // triggered which updates it\n                !event || // If the client doesn't have a session then we don't need to call\n                // the server to check if it does (if they have signed in via another\n                // tab or window that will come through as a \"stroage\" event\n                // event anyway)\n                __NEXTAUTH._session === null || // Bail out early if the client session is not stale yet\n                (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)() < __NEXTAUTH._lastSync) {\n                    return;\n                }\n                // An event or session staleness occurred, update the client session.\n                __NEXTAUTH._lastSync = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)();\n                __NEXTAUTH._session = await getSession();\n                setSession(__NEXTAUTH._session);\n            } catch (error) {\n                logger.error(new _lib_client_js__WEBPACK_IMPORTED_MODULE_2__.ClientSessionError(error.message, error));\n            } finally{\n                setLoading(false);\n            }\n        };\n        __NEXTAUTH._getSession();\n        return ()=>{\n            __NEXTAUTH._lastSync = 0;\n            __NEXTAUTH._session = undefined;\n            __NEXTAUTH._getSession = ()=>{};\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const handle = ()=>__NEXTAUTH._getSession({\n                event: \"storage\"\n            });\n        // Listen for storage events and update session if event fired from\n        // another window (but suppress firing another event to avoid a loop)\n        // Fetch new session data but tell it to not to fire another event to\n        // avoid an infinite loop.\n        // Note: We could pass session data through and do something like\n        // `setData(message.data)` but that can cause problems depending\n        // on how the session object is being used in the client; it is\n        // more robust to have each window/tab fetch it's own copy of the\n        // session object rather than share it across instances.\n        broadcast().addEventListener(\"message\", handle);\n        return ()=>broadcast().removeEventListener(\"message\", handle);\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const { refetchOnWindowFocus = true } = props;\n        // Listen for when the page is visible, if the user switches tabs\n        // and makes our tab visible again, re-fetch the session, but only if\n        // this feature is not disabled.\n        const visibilityHandler = ()=>{\n            if (refetchOnWindowFocus && document.visibilityState === \"visible\") __NEXTAUTH._getSession({\n                event: \"visibilitychange\"\n            });\n        };\n        document.addEventListener(\"visibilitychange\", visibilityHandler, false);\n        return ()=>document.removeEventListener(\"visibilitychange\", visibilityHandler, false);\n    }, [\n        props.refetchOnWindowFocus\n    ]);\n    const isOnline = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.useOnline)();\n    // TODO: Flip this behavior in next major version\n    const shouldRefetch = refetchWhenOffline !== false || isOnline;\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (refetchInterval && shouldRefetch) {\n            const refetchIntervalTimer = setInterval(()=>{\n                if (__NEXTAUTH._session) {\n                    __NEXTAUTH._getSession({\n                        event: \"poll\"\n                    });\n                }\n            }, refetchInterval * 1000);\n            return ()=>clearInterval(refetchIntervalTimer);\n        }\n    }, [\n        refetchInterval,\n        shouldRefetch\n    ]);\n    const value = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            data: session,\n            status: loading ? \"loading\" : session ? \"authenticated\" : \"unauthenticated\",\n            async update (data) {\n                if (loading) return;\n                setLoading(true);\n                const newSession = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"session\", __NEXTAUTH, logger, typeof data === \"undefined\" ? undefined : {\n                    body: {\n                        csrfToken: await getCsrfToken(),\n                        data\n                    }\n                });\n                setLoading(false);\n                if (newSession) {\n                    setSession(newSession);\n                    broadcast().postMessage({\n                        event: \"session\",\n                        data: {\n                            trigger: \"getSession\"\n                        }\n                    });\n                }\n                return newSession;\n            }\n        }), [\n        session,\n        loading\n    ]);\n    return(// @ts-expect-error\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SessionContext.Provider, {\n        value: value,\n        children: children\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3JlYWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsaUtBRStDO0FBQ2pCO0FBQ3dFO0FBQ3ZHLDhFQUE4RTtBQUM5RSx5Q0FBeUM7QUFDekMsZ0ZBQWdGO0FBQ2hGLHVFQUF1RTtBQUN2RSx5RUFBeUU7QUFDekUsdURBQXVEO0FBQ2hELE1BQU1TLGFBQWE7SUFDdEJDLFNBQVNILHdEQUFRQSxDQUFDSSxRQUFRQyxHQUFHLENBQUNDLFlBQVksSUFBSUYsUUFBUUMsR0FBRyxDQUFDRSxVQUFVLEVBQUVDLE1BQU07SUFDNUVDLFVBQVVULHdEQUFRQSxDQUFDSSxRQUFRQyxHQUFHLENBQUNDLFlBQVksRUFBRUksSUFBSTtJQUNqREMsZUFBZVgsd0RBQVFBLENBQUNJLFFBQVFDLEdBQUcsQ0FBQ08scUJBQXFCLElBQ3JEUixRQUFRQyxHQUFHLENBQUNDLFlBQVksSUFDeEJGLFFBQVFDLEdBQUcsQ0FBQ0UsVUFBVSxFQUFFQyxNQUFNO0lBQ2xDSyxnQkFBZ0JiLHdEQUFRQSxDQUFDSSxRQUFRQyxHQUFHLENBQUNPLHFCQUFxQixJQUFJUixRQUFRQyxHQUFHLENBQUNDLFlBQVksRUFBRUksSUFBSTtJQUM1RkksV0FBVztJQUNYQyxVQUFVQztJQUNWQyxhQUFhLEtBQVE7QUFDekIsRUFBRTtBQUNGLHFEQUFxRDtBQUNyRCxJQUFJQyxtQkFBbUI7QUFDdkIsU0FBU0M7SUFDTCxJQUFJLE9BQU9DLHFCQUFxQixhQUFhO1FBQ3pDLE9BQU87WUFDSEMsYUFBYSxLQUFRO1lBQ3JCQyxrQkFBa0IsS0FBUTtZQUMxQkMscUJBQXFCLEtBQVE7WUFDN0JDLE1BQU07WUFDTkMsV0FBVztZQUNYQyxnQkFBZ0I7WUFDaEJDLE9BQU8sS0FBUTtZQUNmQyxlQUFlLElBQU07UUFDekI7SUFDSjtJQUNBLE9BQU8sSUFBSVIsaUJBQWlCO0FBQ2hDO0FBQ0EsU0FBU1M7SUFDTCxJQUFJWCxxQkFBcUIsTUFBTTtRQUMzQkEsbUJBQW1CQztJQUN2QjtJQUNBLE9BQU9EO0FBQ1g7QUFDQSxRQUFRO0FBQ1IsTUFBTVksU0FBUztJQUNYQyxPQUFPQyxRQUFRRCxLQUFLO0lBQ3BCRSxPQUFPRCxRQUFRQyxLQUFLO0lBQ3BCQyxNQUFNRixRQUFRRSxJQUFJO0FBQ3RCO0FBQ08sTUFBTUMsaUJBQWlCeEMsZ0RBQW1CLEdBQUdxQixXQUFXO0FBQy9EOzs7Ozs7Q0FNQyxHQUNNLFNBQVNxQixXQUFXQyxPQUFPO0lBQzlCLElBQUksQ0FBQ0gsZ0JBQWdCO1FBQ2pCLE1BQU0sSUFBSUksTUFBTTtJQUNwQjtJQUNBLHNEQUFzRDtJQUN0RCxNQUFNQyxRQUFRN0MsNkNBQWdCLENBQUN3QztJQUMvQixJQUFJLENBQUNLLFNBQVNwQyxrQkFBeUIsY0FBYztRQUNqRCxNQUFNLElBQUltQyxNQUFNO0lBQ3BCO0lBQ0EsTUFBTSxFQUFFRyxRQUFRLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdMLFdBQVcsQ0FBQztJQUNwRCxNQUFNTSx3QkFBd0JGLFlBQVlGLE1BQU1LLE1BQU0sS0FBSztJQUMzRGxELDRDQUFlLENBQUM7UUFDWixJQUFJaUQsdUJBQXVCO1lBQ3ZCLE1BQU1HLE1BQU0sQ0FBQyxFQUFFN0MsV0FBV08sUUFBUSxDQUFDLFFBQVEsRUFBRSxJQUFJdUMsZ0JBQWdCO2dCQUM3RGYsT0FBTztnQkFDUGdCLGFBQWFDLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSTtZQUNyQyxHQUFHLENBQUM7WUFDSixJQUFJVCxtQkFDQUE7aUJBRUFPLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSSxHQUFHTDtRQUMvQjtJQUNKLEdBQUc7UUFBQ0g7UUFBdUJEO0tBQWtCO0lBQzdDLElBQUlDLHVCQUF1QjtRQUN2QixPQUFPO1lBQ0hTLE1BQU1iLE1BQU1hLElBQUk7WUFDaEJDLFFBQVFkLE1BQU1jLE1BQU07WUFDcEJULFFBQVE7UUFDWjtJQUNKO0lBQ0EsT0FBT0w7QUFDWDtBQUNPLGVBQWVlLFdBQVdDLE1BQU07SUFDbkMsTUFBTUMsVUFBVSxNQUFNM0QseURBQVNBLENBQUMsV0FBV0ksWUFBWTRCLFFBQVEwQjtJQUMvRCxJQUFJQSxRQUFRM0IsYUFBYSxNQUFNO1FBQzNCLHFEQUFxRDtRQUNyRFYseUJBQXlCRSxXQUFXLENBQUM7WUFDakNxQyxPQUFPO1lBQ1BMLE1BQU07Z0JBQUVNLFNBQVM7WUFBYTtRQUNsQztJQUNKO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7OztDQUtDLEdBQ00sZUFBZUc7SUFDbEIsTUFBTUMsV0FBVyxNQUFNL0QseURBQVNBLENBQUMsUUFBUUksWUFBWTRCO0lBQ3JELE9BQU8rQixVQUFVQyxhQUFhO0FBQ2xDO0FBQ08sZUFBZUM7SUFDbEIsT0FBT2pFLHlEQUFTQSxDQUFDLGFBQWFJLFlBQVk0QjtBQUM5QztBQUNPLGVBQWVrQyxPQUFPQyxRQUFRLEVBQUUzQixPQUFPLEVBQUU0QixtQkFBbUI7SUFDL0QsTUFBTSxFQUFFakIsV0FBVyxFQUFFLEdBQUdrQixNQUFNLEdBQUc3QixXQUFXLENBQUM7SUFDN0MsTUFBTSxFQUFFOEIsV0FBVyxJQUFJLEVBQUVDLGFBQWFwQixlQUFlQyxPQUFPQyxRQUFRLENBQUNDLElBQUksRUFBRSxHQUFHa0IsY0FBYyxHQUFHSDtJQUMvRixNQUFNaEUsVUFBVVAsMERBQVVBLENBQUNNO0lBQzNCLE1BQU1xRSxZQUFZLE1BQU1SO0lBQ3hCLElBQUksQ0FBQ1EsV0FBVztRQUNaLE1BQU14QixNQUFNLENBQUMsRUFBRTVDLFFBQVEsTUFBTSxDQUFDO1FBQzlCK0MsT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEdBQUdMO1FBQ3ZCLFFBQVEsMENBQTBDO0lBQ3REO0lBQ0EsSUFBSSxDQUFDa0IsWUFBWSxDQUFDTSxTQUFTLENBQUNOLFNBQVMsRUFBRTtRQUNuQyxNQUFNbEIsTUFBTSxDQUFDLEVBQUU1QyxRQUFRLFFBQVEsRUFBRSxJQUFJNkMsZ0JBQWdCO1lBQ2pEQyxhQUFhb0I7UUFDakIsR0FBRyxDQUFDO1FBQ0puQixPQUFPQyxRQUFRLENBQUNDLElBQUksR0FBR0w7UUFDdkIsUUFBUSwwQ0FBMEM7SUFDdEQ7SUFDQSxNQUFNeUIsZUFBZUQsU0FBUyxDQUFDTixTQUFTLENBQUNRLElBQUk7SUFDN0MsSUFBSUQsaUJBQWlCLFlBQVk7UUFDN0IsdUNBQXVDO1FBQ3ZDLE1BQU0sSUFBSUUsVUFBVTtZQUNoQixDQUFDLGFBQWEsRUFBRVQsU0FBUyxnQ0FBZ0MsQ0FBQztZQUMxRDtTQUNILENBQUNVLElBQUksQ0FBQztJQUNYO0lBQ0EsTUFBTUMsWUFBWSxDQUFDLEVBQUV6RSxRQUFRLENBQUMsRUFBRXFFLGlCQUFpQixnQkFBZ0IsYUFBYSxTQUFTLENBQUMsRUFBRVAsU0FBUyxDQUFDO0lBQ3BHLE1BQU1ILFlBQVksTUFBTUY7SUFDeEIsTUFBTWlCLE1BQU0sTUFBTUMsTUFBTSxDQUFDLEVBQUVGLFVBQVUsQ0FBQyxFQUFFLElBQUk1QixnQkFBZ0JrQixxQkFBcUIsQ0FBQyxFQUFFO1FBQ2hGYSxRQUFRO1FBQ1JDLFNBQVM7WUFDTCxnQkFBZ0I7WUFDaEIsMEJBQTBCO1FBQzlCO1FBQ0FDLE1BQU0sSUFBSWpDLGdCQUFnQjtZQUN0QixHQUFHc0IsWUFBWTtZQUNmUjtZQUNBYixhQUFhb0I7UUFDakI7SUFDSjtJQUNBLE1BQU1oQixPQUFPLE1BQU13QixJQUFJSyxJQUFJO0lBQzNCLElBQUlkLFVBQVU7UUFDVixNQUFNckIsTUFBTU0sS0FBS04sR0FBRyxJQUFJc0I7UUFDeEJuQixPQUFPQyxRQUFRLENBQUNDLElBQUksR0FBR0w7UUFDdkIsbUZBQW1GO1FBQ25GLElBQUlBLElBQUlvQyxRQUFRLENBQUMsTUFDYmpDLE9BQU9DLFFBQVEsQ0FBQ2lDLE1BQU07UUFDMUI7SUFDSjtJQUNBLE1BQU1uRCxRQUFRLElBQUlvRCxJQUFJaEMsS0FBS04sR0FBRyxFQUFFdUMsWUFBWSxDQUFDQyxHQUFHLENBQUMsWUFBWXZFO0lBQzdELE1BQU13RSxPQUFPLElBQUlILElBQUloQyxLQUFLTixHQUFHLEVBQUV1QyxZQUFZLENBQUNDLEdBQUcsQ0FBQyxXQUFXdkU7SUFDM0QsSUFBSTZELElBQUlZLEVBQUUsRUFBRTtRQUNSLE1BQU12RixXQUFXZSxXQUFXLENBQUM7WUFBRXlDLE9BQU87UUFBVTtJQUNwRDtJQUNBLE9BQU87UUFDSHpCO1FBQ0F1RDtRQUNBM0MsUUFBUWdDLElBQUloQyxNQUFNO1FBQ2xCNEMsSUFBSVosSUFBSVksRUFBRTtRQUNWMUMsS0FBS2QsUUFBUSxPQUFPb0IsS0FBS04sR0FBRztJQUNoQztBQUNKO0FBQ08sZUFBZTJDLFFBQVFwRCxPQUFPO0lBQ2pDLE1BQU0sRUFBRThCLFdBQVcsSUFBSSxFQUFFQyxhQUFhL0IsU0FBU1csZUFBZUMsT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEVBQUcsR0FBR2QsV0FBVyxDQUFDO0lBQ3BHLE1BQU1uQyxVQUFVUCwwREFBVUEsQ0FBQ007SUFDM0IsTUFBTTRELFlBQVksTUFBTUY7SUFDeEIsTUFBTWlCLE1BQU0sTUFBTUMsTUFBTSxDQUFDLEVBQUUzRSxRQUFRLFFBQVEsQ0FBQyxFQUFFO1FBQzFDNEUsUUFBUTtRQUNSQyxTQUFTO1lBQ0wsZ0JBQWdCO1lBQ2hCLDBCQUEwQjtRQUM5QjtRQUNBQyxNQUFNLElBQUlqQyxnQkFBZ0I7WUFBRWM7WUFBV2IsYUFBYW9CO1FBQVc7SUFDbkU7SUFDQSxNQUFNaEIsT0FBTyxNQUFNd0IsSUFBSUssSUFBSTtJQUMzQnJELFlBQVlSLFdBQVcsQ0FBQztRQUFFcUMsT0FBTztRQUFXTCxNQUFNO1lBQUVNLFNBQVM7UUFBVTtJQUFFO0lBQ3pFLElBQUlTLFVBQVU7UUFDVixNQUFNckIsTUFBTU0sS0FBS04sR0FBRyxJQUFJc0I7UUFDeEJuQixPQUFPQyxRQUFRLENBQUNDLElBQUksR0FBR0w7UUFDdkIsbUZBQW1GO1FBQ25GLElBQUlBLElBQUlvQyxRQUFRLENBQUMsTUFDYmpDLE9BQU9DLFFBQVEsQ0FBQ2lDLE1BQU07UUFDMUI7SUFDSjtJQUNBLE1BQU1sRixXQUFXZSxXQUFXLENBQUM7UUFBRXlDLE9BQU87SUFBVTtJQUNoRCxPQUFPTDtBQUNYO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU3NDLGdCQUFnQkMsS0FBSztJQUNqQyxJQUFJLENBQUN6RCxnQkFBZ0I7UUFDakIsTUFBTSxJQUFJSSxNQUFNO0lBQ3BCO0lBQ0EsTUFBTSxFQUFFc0QsUUFBUSxFQUFFcEYsUUFBUSxFQUFFcUYsZUFBZSxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHSDtJQUNwRSxJQUFJbkYsVUFDQVAsV0FBV08sUUFBUSxHQUFHQTtJQUMxQjs7O0tBR0MsR0FDRCxNQUFNdUYsb0JBQW9CSixNQUFNbkMsT0FBTyxLQUFLekM7SUFDNUMsd0RBQXdELEdBQ3hEZCxXQUFXWSxTQUFTLEdBQUdrRixvQkFBb0JqRyxtREFBR0EsS0FBSztJQUNuRCxNQUFNLENBQUMwRCxTQUFTd0MsV0FBVyxHQUFHdEcsMkNBQWMsQ0FBQztRQUN6QyxJQUFJcUcsbUJBQ0E5RixXQUFXYSxRQUFRLEdBQUc2RSxNQUFNbkMsT0FBTztRQUN2QyxPQUFPbUMsTUFBTW5DLE9BQU87SUFDeEI7SUFDQSxxREFBcUQsR0FDckQsTUFBTSxDQUFDMEMsU0FBU0MsV0FBVyxHQUFHekcsMkNBQWMsQ0FBQyxDQUFDcUc7SUFDOUNyRyw0Q0FBZSxDQUFDO1FBQ1pPLFdBQVdlLFdBQVcsR0FBRyxPQUFPLEVBQUV5QyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDMUMsSUFBSTtnQkFDQSxNQUFNMkMsZUFBZTNDLFVBQVU7Z0JBQy9CLGdFQUFnRTtnQkFDaEUsaURBQWlEO2dCQUNqRCxJQUFJMkMsZ0JBQWdCbkcsV0FBV2EsUUFBUSxLQUFLQyxXQUFXO29CQUNuRGQsV0FBV1ksU0FBUyxHQUFHZixtREFBR0E7b0JBQzFCRyxXQUFXYSxRQUFRLEdBQUcsTUFBTXdDLFdBQVc7d0JBQ25DMUIsV0FBVyxDQUFDd0U7b0JBQ2hCO29CQUNBSixXQUFXL0YsV0FBV2EsUUFBUTtvQkFDOUI7Z0JBQ0o7Z0JBQ0EsSUFDQSxzRUFBc0U7Z0JBQ3RFLG1FQUFtRTtnQkFDbkUsNkJBQTZCO2dCQUM3QixDQUFDMkMsU0FDRyxrRUFBa0U7Z0JBQ2xFLHFFQUFxRTtnQkFDckUsNERBQTREO2dCQUM1RCxnQkFBZ0I7Z0JBQ2hCeEQsV0FBV2EsUUFBUSxLQUFLLFFBQ3hCLHdEQUF3RDtnQkFDeERoQixtREFBR0EsS0FBS0csV0FBV1ksU0FBUyxFQUFFO29CQUM5QjtnQkFDSjtnQkFDQSxxRUFBcUU7Z0JBQ3JFWixXQUFXWSxTQUFTLEdBQUdmLG1EQUFHQTtnQkFDMUJHLFdBQVdhLFFBQVEsR0FBRyxNQUFNd0M7Z0JBQzVCMEMsV0FBVy9GLFdBQVdhLFFBQVE7WUFDbEMsRUFDQSxPQUFPa0IsT0FBTztnQkFDVkgsT0FBT0csS0FBSyxDQUFDLElBQUlwQyw4REFBa0JBLENBQUNvQyxNQUFNcUUsT0FBTyxFQUFFckU7WUFDdkQsU0FDUTtnQkFDSm1FLFdBQVc7WUFDZjtRQUNKO1FBQ0FsRyxXQUFXZSxXQUFXO1FBQ3RCLE9BQU87WUFDSGYsV0FBV1ksU0FBUyxHQUFHO1lBQ3ZCWixXQUFXYSxRQUFRLEdBQUdDO1lBQ3RCZCxXQUFXZSxXQUFXLEdBQUcsS0FBUTtRQUNyQztJQUNKLEdBQUcsRUFBRTtJQUNMdEIsNENBQWUsQ0FBQztRQUNaLE1BQU00RyxTQUFTLElBQU1yRyxXQUFXZSxXQUFXLENBQUM7Z0JBQUV5QyxPQUFPO1lBQVU7UUFDL0QsbUVBQW1FO1FBQ25FLHFFQUFxRTtRQUNyRSxxRUFBcUU7UUFDckUsMEJBQTBCO1FBQzFCLGlFQUFpRTtRQUNqRSxnRUFBZ0U7UUFDaEUsK0RBQStEO1FBQy9ELGlFQUFpRTtRQUNqRSx3REFBd0Q7UUFDeEQ3QixZQUFZUCxnQkFBZ0IsQ0FBQyxXQUFXaUY7UUFDeEMsT0FBTyxJQUFNMUUsWUFBWU4sbUJBQW1CLENBQUMsV0FBV2dGO0lBQzVELEdBQUcsRUFBRTtJQUNMNUcsNENBQWUsQ0FBQztRQUNaLE1BQU0sRUFBRTZHLHVCQUF1QixJQUFJLEVBQUUsR0FBR1o7UUFDeEMsaUVBQWlFO1FBQ2pFLHFFQUFxRTtRQUNyRSxnQ0FBZ0M7UUFDaEMsTUFBTWEsb0JBQW9CO1lBQ3RCLElBQUlELHdCQUF3QkUsU0FBU0MsZUFBZSxLQUFLLFdBQ3JEekcsV0FBV2UsV0FBVyxDQUFDO2dCQUFFeUMsT0FBTztZQUFtQjtRQUMzRDtRQUNBZ0QsU0FBU3BGLGdCQUFnQixDQUFDLG9CQUFvQm1GLG1CQUFtQjtRQUNqRSxPQUFPLElBQU1DLFNBQVNuRixtQkFBbUIsQ0FBQyxvQkFBb0JrRixtQkFBbUI7SUFDckYsR0FBRztRQUFDYixNQUFNWSxvQkFBb0I7S0FBQztJQUMvQixNQUFNSSxXQUFXM0cseURBQVNBO0lBQzFCLGlEQUFpRDtJQUNqRCxNQUFNNEcsZ0JBQWdCZCx1QkFBdUIsU0FBU2E7SUFDdERqSCw0Q0FBZSxDQUFDO1FBQ1osSUFBSW1HLG1CQUFtQmUsZUFBZTtZQUNsQyxNQUFNQyx1QkFBdUJDLFlBQVk7Z0JBQ3JDLElBQUk3RyxXQUFXYSxRQUFRLEVBQUU7b0JBQ3JCYixXQUFXZSxXQUFXLENBQUM7d0JBQUV5QyxPQUFPO29CQUFPO2dCQUMzQztZQUNKLEdBQUdvQyxrQkFBa0I7WUFDckIsT0FBTyxJQUFNa0IsY0FBY0Y7UUFDL0I7SUFDSixHQUFHO1FBQUNoQjtRQUFpQmU7S0FBYztJQUNuQyxNQUFNckUsUUFBUTdDLDBDQUFhLENBQUMsSUFBTztZQUMvQjBELE1BQU1JO1lBQ05aLFFBQVFzRCxVQUNGLFlBQ0ExQyxVQUNJLGtCQUNBO1lBQ1YsTUFBTUgsUUFBT0QsSUFBSTtnQkFDYixJQUFJOEMsU0FDQTtnQkFDSkMsV0FBVztnQkFDWCxNQUFNYyxhQUFhLE1BQU1wSCx5REFBU0EsQ0FBQyxXQUFXSSxZQUFZNEIsUUFBUSxPQUFPdUIsU0FBUyxjQUM1RXJDLFlBQ0E7b0JBQUVpRSxNQUFNO3dCQUFFbkIsV0FBVyxNQUFNRjt3QkFBZ0JQO29CQUFLO2dCQUFFO2dCQUN4RCtDLFdBQVc7Z0JBQ1gsSUFBSWMsWUFBWTtvQkFDWmpCLFdBQVdpQjtvQkFDWHJGLFlBQVlSLFdBQVcsQ0FBQzt3QkFDcEJxQyxPQUFPO3dCQUNQTCxNQUFNOzRCQUFFTSxTQUFTO3dCQUFhO29CQUNsQztnQkFDSjtnQkFDQSxPQUFPdUQ7WUFDWDtRQUNKLElBQUk7UUFBQ3pEO1FBQVMwQztLQUFRO0lBQ3RCLE9BQ0EsbUJBQW1CO0lBQ25Cekcsc0RBQUlBLENBQUN5QyxlQUFlZ0YsUUFBUSxFQUFFO1FBQUUzRSxPQUFPQTtRQUFPcUQsVUFBVUE7SUFBUztBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BpZ21lbnRvc3RrdHMtd2ViLy4vbm9kZV9tb2R1bGVzL25leHQtYXV0aC9yZWFjdC5qcz8yODVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIE5leHRBdXRoLmpzIGlzIHRoZSBvZmZpY2lhbCBpbnRlZ3JhdGlvbiBvZiBBdXRoLmpzIGZvciBOZXh0LmpzIGFwcGxpY2F0aW9ucy4gSXQgc3VwcG9ydHMgYm90aFxuICogW0NsaWVudCBDb21wb25lbnRzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvY2xpZW50LWNvbXBvbmVudHMpIGFuZCB0aGVcbiAqIFtQYWdlcyBSb3V0ZXJdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL3BhZ2VzKS4gSXQgaW5jbHVkZXMgbWV0aG9kcyBmb3Igc2lnbmluZyBpbiwgc2lnbmluZyBvdXQsIGhvb2tzLCBhbmQgYSBSZWFjdFxuICogQ29udGV4dCBwcm92aWRlciB0byB3cmFwIHlvdXIgYXBwbGljYXRpb24gYW5kIG1ha2Ugc2Vzc2lvbiBkYXRhIGF2YWlsYWJsZSBhbnl3aGVyZS5cbiAqXG4gKiBGb3IgdXNlIGluIFtTZXJ2ZXIgQWN0aW9uc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL3NlcnZlci1hY3Rpb25zKSwgY2hlY2sgb3V0IFt0aGVzZSBtZXRob2RzXShodHRwczovL2F1dGhqcy5kZXYvZ3VpZGVzL3VwZ3JhZGUtdG8tdjUjbWV0aG9kcylcbiAqXG4gKiBAbW9kdWxlIHJlYWN0XG4gKi9cblwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgYXBpQmFzZVVybCwgQ2xpZW50U2Vzc2lvbkVycm9yLCBmZXRjaERhdGEsIG5vdywgcGFyc2VVcmwsIHVzZU9ubGluZSwgfSBmcm9tIFwiLi9saWIvY2xpZW50LmpzXCI7XG4vLyBUaGlzIGJlaGF2aW91ciBtaXJyb3JzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgZ2V0dGluZyB0aGUgc2l0ZSBuYW1lIHRoYXRcbi8vIGhhcHBlbnMgc2VydmVyIHNpZGUgaW4gc2VydmVyL2luZGV4LmpzXG4vLyAxLiBBbiBlbXB0eSB2YWx1ZSBpcyBsZWdpdGltYXRlIHdoZW4gdGhlIGNvZGUgaXMgYmVpbmcgaW52b2tlZCBjbGllbnQgc2lkZSBhc1xuLy8gICAgcmVsYXRpdmUgVVJMcyBhcmUgdmFsaWQgaW4gdGhhdCBjb250ZXh0IGFuZCBzbyBkZWZhdWx0cyB0byBlbXB0eS5cbi8vIDIuIFdoZW4gaW52b2tlZCBzZXJ2ZXIgc2lkZSB0aGUgdmFsdWUgaXMgcGlja2VkIHVwIGZyb20gYW4gZW52aXJvbm1lbnRcbi8vICAgIHZhcmlhYmxlIGFuZCBkZWZhdWx0cyB0byAnaHR0cDovL2xvY2FsaG9zdDozMDAwJy5cbmV4cG9ydCBjb25zdCBfX05FWFRBVVRIID0ge1xuICAgIGJhc2VVcmw6IHBhcnNlVXJsKHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTCA/PyBwcm9jZXNzLmVudi5WRVJDRUxfVVJMKS5vcmlnaW4sXG4gICAgYmFzZVBhdGg6IHBhcnNlVXJsKHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTCkucGF0aCxcbiAgICBiYXNlVXJsU2VydmVyOiBwYXJzZVVybChwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkxfSU5URVJOQUwgPz9cbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMID8/XG4gICAgICAgIHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpLm9yaWdpbixcbiAgICBiYXNlUGF0aFNlcnZlcjogcGFyc2VVcmwocHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMX0lOVEVSTkFMID8/IHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTCkucGF0aCxcbiAgICBfbGFzdFN5bmM6IDAsXG4gICAgX3Nlc3Npb246IHVuZGVmaW5lZCxcbiAgICBfZ2V0U2Vzc2lvbjogKCkgPT4geyB9LFxufTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uZXh0YXV0aGpzL25leHQtYXV0aC9wdWxsLzEwNzYyXG5sZXQgYnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XG5mdW5jdGlvbiBnZXROZXdCcm9hZGNhc3RDaGFubmVsKCkge1xuICAgIGlmICh0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2U6ICgpID0+IHsgfSxcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6ICgpID0+IHsgfSxcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6ICgpID0+IHsgfSxcbiAgICAgICAgICAgIG5hbWU6IFwibmV4dC1hdXRoXCIsXG4gICAgICAgICAgICBvbm1lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgICBvbm1lc3NhZ2VlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiAoKSA9PiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RDaGFubmVsKFwibmV4dC1hdXRoXCIpO1xufVxuZnVuY3Rpb24gYnJvYWRjYXN0KCkge1xuICAgIGlmIChicm9hZGNhc3RDaGFubmVsID09PSBudWxsKSB7XG4gICAgICAgIGJyb2FkY2FzdENoYW5uZWwgPSBnZXROZXdCcm9hZGNhc3RDaGFubmVsKCk7XG4gICAgfVxuICAgIHJldHVybiBicm9hZGNhc3RDaGFubmVsO1xufVxuLy8gVE9ETzpcbmNvbnN0IGxvZ2dlciA9IHtcbiAgICBkZWJ1ZzogY29uc29sZS5kZWJ1ZyxcbiAgICBlcnJvcjogY29uc29sZS5lcnJvcixcbiAgICB3YXJuOiBjb25zb2xlLndhcm4sXG59O1xuZXhwb3J0IGNvbnN0IFNlc3Npb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dD8uKHVuZGVmaW5lZCk7XG4vKipcbiAqIFJlYWN0IEhvb2sgdGhhdCBnaXZlcyB5b3UgYWNjZXNzIHRvIHRoZSBsb2dnZWQgaW4gdXNlcidzIHNlc3Npb24gZGF0YSBhbmQgbGV0cyB5b3UgbW9kaWZ5IGl0LlxuICpcbiAqIDo6OmluZm9cbiAqIGB1c2VTZXNzaW9uYCBpcyBmb3IgY2xpZW50LXNpZGUgdXNlIG9ubHkgYW5kIHdoZW4gdXNpbmcgW05leHQuanMgQXBwIFJvdXRlciAoYGFwcC9gKV0oaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC0xMy00I25leHRqcy1hcHAtcm91dGVyKSB5b3Ugc2hvdWxkIHByZWZlciB0aGUgYGF1dGgoKWAgZXhwb3J0LlxuICogOjo6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZXNzaW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIVNlc3Npb25Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0IENvbnRleHQgaXMgdW5hdmFpbGFibGUgaW4gU2VydmVyIENvbXBvbmVudHNcIik7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgU2F0aXNmeSBUUyBpZiBicmFuY2ggb24gbGluZSBiZWxvd1xuICAgIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChTZXNzaW9uQ29udGV4dCk7XG4gICAgaWYgKCF2YWx1ZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW25leHQtYXV0aF06IGB1c2VTZXNzaW9uYCBtdXN0IGJlIHdyYXBwZWQgaW4gYSA8U2Vzc2lvblByb3ZpZGVyIC8+XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IHJlcXVpcmVkLCBvblVuYXV0aGVudGljYXRlZCB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICBjb25zdCByZXF1aXJlZEFuZE5vdExvYWRpbmcgPSByZXF1aXJlZCAmJiB2YWx1ZS5zdGF0dXMgPT09IFwidW5hdXRoZW50aWNhdGVkXCI7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHJlcXVpcmVkQW5kTm90TG9hZGluZykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7X19ORVhUQVVUSC5iYXNlUGF0aH0vc2lnbmluPyR7bmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IFwiU2Vzc2lvblJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgfSl9YDtcbiAgICAgICAgICAgIGlmIChvblVuYXV0aGVudGljYXRlZClcbiAgICAgICAgICAgICAgICBvblVuYXV0aGVudGljYXRlZCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICB9XG4gICAgfSwgW3JlcXVpcmVkQW5kTm90TG9hZGluZywgb25VbmF1dGhlbnRpY2F0ZWRdKTtcbiAgICBpZiAocmVxdWlyZWRBbmROb3RMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB2YWx1ZS5kYXRhLFxuICAgICAgICAgICAgdXBkYXRlOiB2YWx1ZS51cGRhdGUsXG4gICAgICAgICAgICBzdGF0dXM6IFwibG9hZGluZ1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2Vzc2lvbihwYXJhbXMpIHtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZmV0Y2hEYXRhKFwic2Vzc2lvblwiLCBfX05FWFRBVVRILCBsb2dnZXIsIHBhcmFtcyk7XG4gICAgaWYgKHBhcmFtcz8uYnJvYWRjYXN0ID8/IHRydWUpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25leHRhdXRoanMvbmV4dC1hdXRoL3B1bGwvMTE0NzBcbiAgICAgICAgZ2V0TmV3QnJvYWRjYXN0Q2hhbm5lbCgpLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGV2ZW50OiBcInNlc3Npb25cIixcbiAgICAgICAgICAgIGRhdGE6IHsgdHJpZ2dlcjogXCJnZXRTZXNzaW9uXCIgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZXNzaW9uO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IENyb3NzLVNpdGUgUmVxdWVzdCBGb3JnZXJ5IFRva2VuIChDU1JGIFRva2VuKVxuICogcmVxdWlyZWQgdG8gbWFrZSByZXF1ZXN0cyB0aGF0IGNoYW5nZXMgc3RhdGUuIChlLmcuIHNpZ25pbmcgaW4gb3Igb3V0LCBvciB1cGRhdGluZyB0aGUgc2Vzc2lvbikuXG4gKlxuICogW0NTUkYgUHJldmVudGlvbjogRG91YmxlIFN1Ym1pdCBDb29raWVdKGh0dHBzOi8vY2hlYXRzaGVldHNlcmllcy5vd2FzcC5vcmcvY2hlYXRzaGVldHMvQ3Jvc3MtU2l0ZV9SZXF1ZXN0X0ZvcmdlcnlfUHJldmVudGlvbl9DaGVhdF9TaGVldC5odG1sI2RvdWJsZS1zdWJtaXQtY29va2llKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hEYXRhKFwiY3NyZlwiLCBfX05FWFRBVVRILCBsb2dnZXIpO1xuICAgIHJldHVybiByZXNwb25zZT8uY3NyZlRva2VuID8/IFwiXCI7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvdmlkZXJzKCkge1xuICAgIHJldHVybiBmZXRjaERhdGEoXCJwcm92aWRlcnNcIiwgX19ORVhUQVVUSCwgbG9nZ2VyKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW4ocHJvdmlkZXIsIG9wdGlvbnMsIGF1dGhvcml6YXRpb25QYXJhbXMpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrVXJsLCAuLi5yZXN0IH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGNvbnN0IHsgcmVkaXJlY3QgPSB0cnVlLCByZWRpcmVjdFRvID0gY2FsbGJhY2tVcmwgPz8gd2luZG93LmxvY2F0aW9uLmhyZWYsIC4uLnNpZ25JblBhcmFtcyB9ID0gcmVzdDtcbiAgICBjb25zdCBiYXNlVXJsID0gYXBpQmFzZVVybChfX05FWFRBVVRIKTtcbiAgICBjb25zdCBwcm92aWRlcnMgPSBhd2FpdCBnZXRQcm92aWRlcnMoKTtcbiAgICBpZiAoIXByb3ZpZGVycykge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS9lcnJvcmA7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICByZXR1cm47IC8vIFRPRE86IFJldHVybiBlcnJvciBpZiBgcmVkaXJlY3Q6IGZhbHNlYFxuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVyIHx8ICFwcm92aWRlcnNbcHJvdmlkZXJdKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9L3NpZ25pbj8ke25ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgY2FsbGJhY2tVcmw6IHJlZGlyZWN0VG8sXG4gICAgICAgIH0pfWA7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICByZXR1cm47IC8vIFRPRE86IFJldHVybiBlcnJvciBpZiBgcmVkaXJlY3Q6IGZhbHNlYFxuICAgIH1cbiAgICBjb25zdCBwcm92aWRlclR5cGUgPSBwcm92aWRlcnNbcHJvdmlkZXJdLnR5cGU7XG4gICAgaWYgKHByb3ZpZGVyVHlwZSA9PT0gXCJ3ZWJhdXRoblwiKSB7XG4gICAgICAgIC8vIFRPRE86IEFkZCBkb2NzIGxpbmsgd2l0aCBleHBsYW5hdGlvblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFtcbiAgICAgICAgICAgIGBQcm92aWRlciBpZCBcIiR7cHJvdmlkZXJ9XCIgcmVmZXJzIHRvIGEgV2ViQXV0aG4gcHJvdmlkZXIuYCxcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIGBpbXBvcnQgeyBzaWduSW4gfSBmcm9tIFwibmV4dC1hdXRoL3dlYmF1dGhuXCJgIGluc3RlYWQuJyxcbiAgICAgICAgXS5qb2luKFwiXFxuXCIpKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbkluVXJsID0gYCR7YmFzZVVybH0vJHtwcm92aWRlclR5cGUgPT09IFwiY3JlZGVudGlhbHNcIiA/IFwiY2FsbGJhY2tcIiA6IFwic2lnbmluXCJ9LyR7cHJvdmlkZXJ9YDtcbiAgICBjb25zdCBjc3JmVG9rZW4gPSBhd2FpdCBnZXRDc3JmVG9rZW4oKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtzaWduSW5Vcmx9PyR7bmV3IFVSTFNlYXJjaFBhcmFtcyhhdXRob3JpemF0aW9uUGFyYW1zKX1gLCB7XG4gICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgICAgICAgICBcIlgtQXV0aC1SZXR1cm4tUmVkaXJlY3RcIjogXCIxXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgLi4uc2lnbkluUGFyYW1zLFxuICAgICAgICAgICAgY3NyZlRva2VuLFxuICAgICAgICAgICAgY2FsbGJhY2tVcmw6IHJlZGlyZWN0VG8sXG4gICAgICAgIH0pLFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgICBjb25zdCB1cmwgPSBkYXRhLnVybCA/PyByZWRpcmVjdFRvO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgLy8gSWYgdXJsIGNvbnRhaW5zIGEgaGFzaCwgdGhlIGJyb3dzZXIgZG9lcyBub3QgcmVsb2FkIHRoZSBwYWdlLiBXZSByZWxvYWQgbWFudWFsbHlcbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcIiNcIikpXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgVVJMKGRhdGEudXJsKS5zZWFyY2hQYXJhbXMuZ2V0KFwiZXJyb3JcIikgPz8gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNvZGUgPSBuZXcgVVJMKGRhdGEudXJsKS5zZWFyY2hQYXJhbXMuZ2V0KFwiY29kZVwiKSA/PyB1bmRlZmluZWQ7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgICBhd2FpdCBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHsgZXZlbnQ6IFwic3RvcmFnZVwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcixcbiAgICAgICAgY29kZSxcbiAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICBvazogcmVzLm9rLFxuICAgICAgICB1cmw6IGVycm9yID8gbnVsbCA6IGRhdGEudXJsLFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbk91dChvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZWRpcmVjdCA9IHRydWUsIHJlZGlyZWN0VG8gPSBvcHRpb25zPy5jYWxsYmFja1VybCA/PyB3aW5kb3cubG9jYXRpb24uaHJlZiwgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgY29uc3QgYmFzZVVybCA9IGFwaUJhc2VVcmwoX19ORVhUQVVUSCk7XG4gICAgY29uc3QgY3NyZlRva2VuID0gYXdhaXQgZ2V0Q3NyZlRva2VuKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YmFzZVVybH0vc2lnbm91dGAsIHtcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICAgICAgICAgIFwiWC1BdXRoLVJldHVybi1SZWRpcmVjdFwiOiBcIjFcIixcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGNzcmZUb2tlbiwgY2FsbGJhY2tVcmw6IHJlZGlyZWN0VG8gfSksXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgYnJvYWRjYXN0KCkucG9zdE1lc3NhZ2UoeyBldmVudDogXCJzZXNzaW9uXCIsIGRhdGE6IHsgdHJpZ2dlcjogXCJzaWdub3V0XCIgfSB9KTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgICAgY29uc3QgdXJsID0gZGF0YS51cmwgPz8gcmVkaXJlY3RUbztcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgIC8vIElmIHVybCBjb250YWlucyBhIGhhc2gsIHRoZSBicm93c2VyIGRvZXMgbm90IHJlbG9hZCB0aGUgcGFnZS4gV2UgcmVsb2FkIG1hbnVhbGx5XG4gICAgICAgIGlmICh1cmwuaW5jbHVkZXMoXCIjXCIpKVxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IF9fTkVYVEFVVEguX2dldFNlc3Npb24oeyBldmVudDogXCJzdG9yYWdlXCIgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIFtSZWFjdCBDb250ZXh0XShodHRwczovL3JlYWN0LmRldi9sZWFybi9wYXNzaW5nLWRhdGEtZGVlcGx5LXdpdGgtY29udGV4dCkgcHJvdmlkZXIgdG8gd3JhcCB0aGUgYXBwIChgcGFnZXMvYCkgdG8gbWFrZSBzZXNzaW9uIGRhdGEgYXZhaWxhYmxlIGFueXdoZXJlLlxuICpcbiAqIFdoZW4gdXNlZCwgdGhlIHNlc3Npb24gc3RhdGUgaXMgYXV0b21hdGljYWxseSBzeW5jaHJvbml6ZWQgYWNyb3NzIGFsbCBvcGVuIHRhYnMvd2luZG93cyBhbmQgdGhleSBhcmUgYWxsIHVwZGF0ZWQgd2hlbmV2ZXIgdGhleSBnYWluIG9yIGxvc2UgZm9jdXNcbiAqIG9yIHRoZSBzdGF0ZSBjaGFuZ2VzIChlLmcuIGEgdXNlciBzaWducyBpbiBvciBvdXQpIHdoZW4ge0BsaW5rIFNlc3Npb25Qcm92aWRlclByb3BzLnJlZmV0Y2hPbldpbmRvd0ZvY3VzfSBpcyBgdHJ1ZWAuXG4gKlxuICogOjo6aW5mb1xuICogYFNlc3Npb25Qcm92aWRlcmAgaXMgZm9yIGNsaWVudC1zaWRlIHVzZSBvbmx5IGFuZCB3aGVuIHVzaW5nIFtOZXh0LmpzIEFwcCBSb3V0ZXIgKGBhcHAvYCldKGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtMTMtNCNuZXh0anMtYXBwLXJvdXRlcikgeW91IHNob3VsZCBwcmVmZXIgdGhlIGBhdXRoKClgIGV4cG9ydC5cbiAqIDo6OlxuICovXG5leHBvcnQgZnVuY3Rpb24gU2Vzc2lvblByb3ZpZGVyKHByb3BzKSB7XG4gICAgaWYgKCFTZXNzaW9uQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBDb250ZXh0IGlzIHVuYXZhaWxhYmxlIGluIFNlcnZlciBDb21wb25lbnRzXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkcmVuLCBiYXNlUGF0aCwgcmVmZXRjaEludGVydmFsLCByZWZldGNoV2hlbk9mZmxpbmUgfSA9IHByb3BzO1xuICAgIGlmIChiYXNlUGF0aClcbiAgICAgICAgX19ORVhUQVVUSC5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICAgIC8qKlxuICAgICAqIElmIHNlc3Npb24gd2FzIGBudWxsYCwgdGhlcmUgd2FzIGFuIGF0dGVtcHQgdG8gZmV0Y2ggaXQsXG4gICAgICogYnV0IGl0IGZhaWxlZCwgYnV0IHdlIHN0aWxsIHRyZWF0IGl0IGFzIGEgdmFsaWQgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBjb25zdCBoYXNJbml0aWFsU2Vzc2lvbiA9IHByb3BzLnNlc3Npb24gIT09IHVuZGVmaW5lZDtcbiAgICAvKiogSWYgc2Vzc2lvbiB3YXMgcGFzc2VkLCBpbml0aWFsaXplIGFzIGFscmVhZHkgc3luY2VkICovXG4gICAgX19ORVhUQVVUSC5fbGFzdFN5bmMgPSBoYXNJbml0aWFsU2Vzc2lvbiA/IG5vdygpIDogMDtcbiAgICBjb25zdCBbc2Vzc2lvbiwgc2V0U2Vzc2lvbl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmIChoYXNJbml0aWFsU2Vzc2lvbilcbiAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBwcm9wcy5zZXNzaW9uO1xuICAgICAgICByZXR1cm4gcHJvcHMuc2Vzc2lvbjtcbiAgICB9KTtcbiAgICAvKiogSWYgc2Vzc2lvbiB3YXMgcGFzc2VkLCBpbml0aWFsaXplIGFzIG5vdCBsb2FkaW5nICovXG4gICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gUmVhY3QudXNlU3RhdGUoIWhhc0luaXRpYWxTZXNzaW9uKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uID0gYXN5bmMgKHsgZXZlbnQgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VFdmVudCA9IGV2ZW50ID09PSBcInN0b3JhZ2VcIjtcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIHVwZGF0ZSBpZiB3ZSBkb24ndCBoYXZlIGEgY2xpZW50IHNlc3Npb24geWV0XG4gICAgICAgICAgICAgICAgLy8gb3IgaWYgdGhlcmUgYXJlIGV2ZW50cyBmcm9tIG90aGVyIHRhYnMvd2luZG93c1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQgfHwgX19ORVhUQVVUSC5fc2Vzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gbm93KCk7XG4gICAgICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBhd2FpdCBnZXRTZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogIXN0b3JhZ2VFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlc3Npb24oX19ORVhUQVVUSC5fc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHRpbWUgZGVmaW5lZCBmb3Igd2hlbiBhIHNlc3Npb24gc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgICAgICAgICAgICAvLyBzdGFsZSwgdGhlbiBpdCdzIG9rYXkgdG8gdXNlIHRoZSB2YWx1ZSB3ZSBoYXZlIHVudGlsIGFuIGV2ZW50IGlzXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkIHdoaWNoIHVwZGF0ZXMgaXRcbiAgICAgICAgICAgICAgICAhZXZlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNsaWVudCBkb2Vzbid0IGhhdmUgYSBzZXNzaW9uIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgdG8gY2hlY2sgaWYgaXQgZG9lcyAoaWYgdGhleSBoYXZlIHNpZ25lZCBpbiB2aWEgYW5vdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyB0YWIgb3Igd2luZG93IHRoYXQgd2lsbCBjb21lIHRocm91Z2ggYXMgYSBcInN0cm9hZ2VcIiBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVudCBhbnl3YXkpXG4gICAgICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgdGhlIGNsaWVudCBzZXNzaW9uIGlzIG5vdCBzdGFsZSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgbm93KCkgPCBfX05FWFRBVVRILl9sYXN0U3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFuIGV2ZW50IG9yIHNlc3Npb24gc3RhbGVuZXNzIG9jY3VycmVkLCB1cGRhdGUgdGhlIGNsaWVudCBzZXNzaW9uLlxuICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gbm93KCk7XG4gICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IGF3YWl0IGdldFNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uKF9fTkVYVEFVVEguX3Nlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG5ldyBDbGllbnRTZXNzaW9uRXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uKCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9IDA7XG4gICAgICAgICAgICBfX05FWFRBVVRILl9zZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbiA9ICgpID0+IHsgfTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gKCkgPT4gX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7IGV2ZW50OiBcInN0b3JhZ2VcIiB9KTtcbiAgICAgICAgLy8gTGlzdGVuIGZvciBzdG9yYWdlIGV2ZW50cyBhbmQgdXBkYXRlIHNlc3Npb24gaWYgZXZlbnQgZmlyZWQgZnJvbVxuICAgICAgICAvLyBhbm90aGVyIHdpbmRvdyAoYnV0IHN1cHByZXNzIGZpcmluZyBhbm90aGVyIGV2ZW50IHRvIGF2b2lkIGEgbG9vcClcbiAgICAgICAgLy8gRmV0Y2ggbmV3IHNlc3Npb24gZGF0YSBidXQgdGVsbCBpdCB0byBub3QgdG8gZmlyZSBhbm90aGVyIGV2ZW50IHRvXG4gICAgICAgIC8vIGF2b2lkIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgIC8vIE5vdGU6IFdlIGNvdWxkIHBhc3Mgc2Vzc2lvbiBkYXRhIHRocm91Z2ggYW5kIGRvIHNvbWV0aGluZyBsaWtlXG4gICAgICAgIC8vIGBzZXREYXRhKG1lc3NhZ2UuZGF0YSlgIGJ1dCB0aGF0IGNhbiBjYXVzZSBwcm9ibGVtcyBkZXBlbmRpbmdcbiAgICAgICAgLy8gb24gaG93IHRoZSBzZXNzaW9uIG9iamVjdCBpcyBiZWluZyB1c2VkIGluIHRoZSBjbGllbnQ7IGl0IGlzXG4gICAgICAgIC8vIG1vcmUgcm9idXN0IHRvIGhhdmUgZWFjaCB3aW5kb3cvdGFiIGZldGNoIGl0J3Mgb3duIGNvcHkgb2YgdGhlXG4gICAgICAgIC8vIHNlc3Npb24gb2JqZWN0IHJhdGhlciB0aGFuIHNoYXJlIGl0IGFjcm9zcyBpbnN0YW5jZXMuXG4gICAgICAgIGJyb2FkY2FzdCgpLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBicm9hZGNhc3QoKS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGUpO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlZmV0Y2hPbldpbmRvd0ZvY3VzID0gdHJ1ZSB9ID0gcHJvcHM7XG4gICAgICAgIC8vIExpc3RlbiBmb3Igd2hlbiB0aGUgcGFnZSBpcyB2aXNpYmxlLCBpZiB0aGUgdXNlciBzd2l0Y2hlcyB0YWJzXG4gICAgICAgIC8vIGFuZCBtYWtlcyBvdXIgdGFiIHZpc2libGUgYWdhaW4sIHJlLWZldGNoIHRoZSBzZXNzaW9uLCBidXQgb25seSBpZlxuICAgICAgICAvLyB0aGlzIGZlYXR1cmUgaXMgbm90IGRpc2FibGVkLlxuICAgICAgICBjb25zdCB2aXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWZldGNoT25XaW5kb3dGb2N1cyAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKVxuICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24oeyBldmVudDogXCJ2aXNpYmlsaXR5Y2hhbmdlXCIgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB2aXNpYmlsaXR5SGFuZGxlciwgZmFsc2UpO1xuICAgIH0sIFtwcm9wcy5yZWZldGNoT25XaW5kb3dGb2N1c10pO1xuICAgIGNvbnN0IGlzT25saW5lID0gdXNlT25saW5lKCk7XG4gICAgLy8gVE9ETzogRmxpcCB0aGlzIGJlaGF2aW9yIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgIGNvbnN0IHNob3VsZFJlZmV0Y2ggPSByZWZldGNoV2hlbk9mZmxpbmUgIT09IGZhbHNlIHx8IGlzT25saW5lO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChyZWZldGNoSW50ZXJ2YWwgJiYgc2hvdWxkUmVmZXRjaCkge1xuICAgICAgICAgICAgY29uc3QgcmVmZXRjaEludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKF9fTkVYVEFVVEguX3Nlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7IGV2ZW50OiBcInBvbGxcIiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWZldGNoSW50ZXJ2YWwgKiAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKHJlZmV0Y2hJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgfVxuICAgIH0sIFtyZWZldGNoSW50ZXJ2YWwsIHNob3VsZFJlZmV0Y2hdKTtcbiAgICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZGF0YTogc2Vzc2lvbixcbiAgICAgICAgc3RhdHVzOiBsb2FkaW5nXG4gICAgICAgICAgICA/IFwibG9hZGluZ1wiXG4gICAgICAgICAgICA6IHNlc3Npb25cbiAgICAgICAgICAgICAgICA/IFwiYXV0aGVudGljYXRlZFwiXG4gICAgICAgICAgICAgICAgOiBcInVuYXV0aGVudGljYXRlZFwiLFxuICAgICAgICBhc3luYyB1cGRhdGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGxvYWRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Nlc3Npb24gPSBhd2FpdCBmZXRjaERhdGEoXCJzZXNzaW9uXCIsIF9fTkVYVEFVVEgsIGxvZ2dlciwgdHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogeyBib2R5OiB7IGNzcmZUb2tlbjogYXdhaXQgZ2V0Q3NyZlRva2VuKCksIGRhdGEgfSB9KTtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG5ld1Nlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uKG5ld1Nlc3Npb24pO1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdCgpLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwic2Vzc2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHRyaWdnZXI6IFwiZ2V0U2Vzc2lvblwiIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3U2Vzc2lvbjtcbiAgICAgICAgfSxcbiAgICB9KSwgW3Nlc3Npb24sIGxvYWRpbmddKTtcbiAgICByZXR1cm4gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBfanN4KFNlc3Npb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbiJdLCJuYW1lcyI6WyJqc3giLCJfanN4IiwiUmVhY3QiLCJhcGlCYXNlVXJsIiwiQ2xpZW50U2Vzc2lvbkVycm9yIiwiZmV0Y2hEYXRhIiwibm93IiwicGFyc2VVcmwiLCJ1c2VPbmxpbmUiLCJfX05FWFRBVVRIIiwiYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUQVVUSF9VUkwiLCJWRVJDRUxfVVJMIiwib3JpZ2luIiwiYmFzZVBhdGgiLCJwYXRoIiwiYmFzZVVybFNlcnZlciIsIk5FWFRBVVRIX1VSTF9JTlRFUk5BTCIsImJhc2VQYXRoU2VydmVyIiwiX2xhc3RTeW5jIiwiX3Nlc3Npb24iLCJ1bmRlZmluZWQiLCJfZ2V0U2Vzc2lvbiIsImJyb2FkY2FzdENoYW5uZWwiLCJnZXROZXdCcm9hZGNhc3RDaGFubmVsIiwiQnJvYWRjYXN0Q2hhbm5lbCIsInBvc3RNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJuYW1lIiwib25tZXNzYWdlIiwib25tZXNzYWdlZXJyb3IiLCJjbG9zZSIsImRpc3BhdGNoRXZlbnQiLCJicm9hZGNhc3QiLCJsb2dnZXIiLCJkZWJ1ZyIsImNvbnNvbGUiLCJlcnJvciIsIndhcm4iLCJTZXNzaW9uQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VTZXNzaW9uIiwib3B0aW9ucyIsIkVycm9yIiwidmFsdWUiLCJ1c2VDb250ZXh0IiwicmVxdWlyZWQiLCJvblVuYXV0aGVudGljYXRlZCIsInJlcXVpcmVkQW5kTm90TG9hZGluZyIsInN0YXR1cyIsInVzZUVmZmVjdCIsInVybCIsIlVSTFNlYXJjaFBhcmFtcyIsImNhbGxiYWNrVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiZGF0YSIsInVwZGF0ZSIsImdldFNlc3Npb24iLCJwYXJhbXMiLCJzZXNzaW9uIiwiZXZlbnQiLCJ0cmlnZ2VyIiwiZ2V0Q3NyZlRva2VuIiwicmVzcG9uc2UiLCJjc3JmVG9rZW4iLCJnZXRQcm92aWRlcnMiLCJzaWduSW4iLCJwcm92aWRlciIsImF1dGhvcml6YXRpb25QYXJhbXMiLCJyZXN0IiwicmVkaXJlY3QiLCJyZWRpcmVjdFRvIiwic2lnbkluUGFyYW1zIiwicHJvdmlkZXJzIiwicHJvdmlkZXJUeXBlIiwidHlwZSIsIlR5cGVFcnJvciIsImpvaW4iLCJzaWduSW5VcmwiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwianNvbiIsImluY2x1ZGVzIiwicmVsb2FkIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiY29kZSIsIm9rIiwic2lnbk91dCIsIlNlc3Npb25Qcm92aWRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWZldGNoSW50ZXJ2YWwiLCJyZWZldGNoV2hlbk9mZmxpbmUiLCJoYXNJbml0aWFsU2Vzc2lvbiIsInNldFNlc3Npb24iLCJ1c2VTdGF0ZSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwic3RvcmFnZUV2ZW50IiwibWVzc2FnZSIsImhhbmRsZSIsInJlZmV0Y2hPbldpbmRvd0ZvY3VzIiwidmlzaWJpbGl0eUhhbmRsZXIiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsImlzT25saW5lIiwic2hvdWxkUmVmZXRjaCIsInJlZmV0Y2hJbnRlcnZhbFRpbWVyIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidXNlTWVtbyIsIm5ld1Nlc3Npb24iLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-auth/react.js\n");

/***/ })

};
;